/******/ var __webpack_modules__ = ({

/***/ "./node_modules/awaitqueue/lib/Logger.js":
/*!***********************************************!*\
  !*** ./node_modules/awaitqueue/lib/Logger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
const LIB_NAME = 'awaitqueue';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/awaitqueue/lib/Logger.js");
const logger = new Logger_1.Logger();
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
class AwaitQueueStoppedError extends Error {
    constructor(message) {
        super(message ?? 'AwaitQueue stopped');
        this.name = 'AwaitQueueStoppedError';
        // @ts-ignore
        if (typeof Error.captureStackTrace === 'function') {
            // @ts-ignore
            Error.captureStackTrace(this, AwaitQueueStoppedError);
        }
    }
}
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
class AwaitQueueRemovedTaskError extends Error {
    constructor(message) {
        super(message ?? 'AwaitQueue task removed');
        this.name = 'AwaitQueueRemovedTaskError';
        // @ts-ignore
        if (typeof Error.captureStackTrace === 'function') {
            // @ts-ignore
            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
        }
    }
}
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
class AwaitQueue {
    constructor() {
        // Queue of pending tasks (map of PendingTasks indexed by id).
        this.pendingTasks = new Map();
        // Incrementing PendingTask id.
        this.nextTaskId = 0;
        // Whether stop() method is stopping all pending tasks.
        this.stopping = false;
    }
    get size() {
        return this.pendingTasks.size;
    }
    async push(task, name) {
        name = name ?? task.name;
        logger.debug(`push() [name:${name}]`);
        if (typeof task !== 'function') {
            throw new TypeError('given task is not a function');
        }
        if (name) {
            try {
                Object.defineProperty(task, 'name', { value: name });
            }
            catch (error) { }
        }
        return new Promise((resolve, reject) => {
            const pendingTask = {
                id: this.nextTaskId++,
                task: task,
                name: name,
                enqueuedAt: Date.now(),
                executedAt: undefined,
                completed: false,
                resolve: (result) => {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`resolving task [name:${pendingTask.name}]`);
                    // Resolve the task with the obtained result.
                    resolve(result);
                    // Execute the next pending task (if any).
                    const [nextPendingTask] = this.pendingTasks.values();
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                        void this.execute(nextPendingTask);
                    }
                },
                reject: (error) => {
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                    // Reject the task with the obtained error.
                    reject(error);
                    // Execute the next pending task (if any) unless stop() is running.
                    if (!this.stopping) {
                        const [nextPendingTask] = this.pendingTasks.values();
                        // NOTE: During the reject() callback the user app may have interacted
                        // with the queue. For instance, the app may have pushed a task while
                        // the queue was empty so such a task is already being executed. If so,
                        // don't execute it twice.
                        if (nextPendingTask && !nextPendingTask.executedAt) {
                            void this.execute(nextPendingTask);
                        }
                    }
                }
            };
            // Append task to the queue.
            this.pendingTasks.set(pendingTask.id, pendingTask);
            // And execute it if this is the only task in the queue.
            if (this.pendingTasks.size === 1) {
                void this.execute(pendingTask);
            }
        });
    }
    stop() {
        logger.debug('stop()');
        this.stopping = true;
        for (const pendingTask of this.pendingTasks.values()) {
            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
        }
        this.stopping = false;
    }
    remove(taskIdx) {
        logger.debug(`remove() [taskIdx:${taskIdx}]`);
        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
        if (!pendingTask) {
            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
        }
        pendingTask.reject(new AwaitQueueRemovedTaskError());
    }
    dump() {
        const now = Date.now();
        let idx = 0;
        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt
                ? pendingTask.executedAt - pendingTask.enqueuedAt
                : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt
                ? now - pendingTask.executedAt
                : 0
        }));
    }
    async execute(pendingTask) {
        logger.debug(`execute() [name:${pendingTask.name}]`);
        if (pendingTask.executedAt) {
            throw new Error('task already being executed');
        }
        pendingTask.executedAt = Date.now();
        try {
            const result = await pendingTask.task();
            // Resolve the task with its resolved result (if any).
            pendingTask.resolve(result);
        }
        catch (error) {
            // Reject the task with its rejected error.
            pendingTask.reject(error);
        }
    }
}
exports.AwaitQueue = AwaitQueue;


/***/ }),

/***/ "./dist/media.bundle.js":
/*!******************************!*\
  !*** ./dist/media.bundle.js ***!
  \******************************/
/***/ (() => {

function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}function _defineProperty(e,r,t){return(r=_toPropertyKey2(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _superPropGet(t,o,e,r){var p=_get(_getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t);}:p;}function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=_superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value;}},_get.apply(null,arguments);}function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=_getPrototypeOf(t)););return t;}function _typeof2(o){"@babel/helpers - typeof";return _typeof2="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o;},_typeof2(o);}function _toConsumableArray(r){return _arrayWithoutHoles(r)||_iterableToArray(r)||_unsupportedIterableToArray(r)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r);}function _arrayWithoutHoles(r){if(Array.isArray(r))return _arrayLikeToArray(r);}function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]};},e:function e(r){throw r;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var o,a=!0,u=!1;return{s:function s(){t=t.call(r);},n:function n(){var r=t.next();return a=r.done,r;},e:function e(r){u=!0,o=r;},f:function f(){try{a||null==t["return"]||t["return"]();}finally{if(u)throw o;}}};}function _regeneratorRuntime2(){"use strict";/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime2=function _regeneratorRuntime2(){return e;};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value;},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e];}try{define({},"");}catch(t){define=function define(t,e,r){return t[e]=r;};}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a;}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)};}catch(t){return{type:"throw",arg:t};}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,function(){return this;});var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach(function(e){define(t,e,function(t){return this._invoke(e,t);});});}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==_typeof2(h)&&n.call(h,"__await")?e.resolve(h.__await).then(function(t){invoke("next",t,i,a);},function(t){invoke("throw",t,i,a);}):e.resolve(h).then(function(t){u.value=t,i(u);},function(t){return invoke("throw",t,i,a);});}a(c.arg);}var r;o(this,"_invoke",{value:function value(t,n){function callInvokeWithMethodAndArg(){return new e(function(e,r){invoke(t,n,e,r);});}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}});}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0};}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u;}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg);}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done};}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg);}};}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator["return"]&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y);}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e);}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e;}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0);}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next;};return i.next=i;}}throw new TypeError(_typeof2(e)+" is not iterable");}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name));},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t;},e.awrap=function(t){return{__await:t};},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,function(){return this;}),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then(function(t){return t.done?t.value:a.next();});},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,function(){return this;}),define(g,"toString",function(){return"[object Generator]";}),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next;}return next.done=!0,next;};},e.values=values,Context.prototype={constructor:Context,reset:function reset(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t);},stop:function stop(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval;},dispatchException:function dispatchException(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o;}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}}}},abrupt:function abrupt(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break;}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a);},complete:function complete(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y;},finish:function finish(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y;}},"catch":function _catch(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r);}return o;}}throw Error("illegal catch attempt");},delegateYield:function delegateYield(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y;}},e;}function _slicedToArray(r,e){return _arrayWithHoles(r)||_iterableToArrayLimit(r,e)||_unsupportedIterableToArray(r,e)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0;}}function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n;}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1;}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r;}finally{try{if(!f&&null!=t["return"]&&(u=t["return"](),Object(u)!==u))return;}finally{if(o)throw n;}}return a;}}function _arrayWithHoles(r){if(Array.isArray(r))return r;}function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value;}catch(n){return void e(n);}i.done?t(u):Promise.resolve(u).then(r,o);}function _asyncToGenerator2(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n);}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n);}_next(void 0);});};}function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e));}function _possibleConstructorReturn(t,e){if(e&&("object"==_typeof2(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(t);}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e;}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e);}function _wrapNativeSuper(t){var r="function"==typeof Map?new Map():void 0;return _wrapNativeSuper=function _wrapNativeSuper(t){if(null===t||!_isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper);}function Wrapper(){return _construct(t,arguments,_getPrototypeOf(this).constructor);}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),_setPrototypeOf(Wrapper,t);},_wrapNativeSuper(t);}function _construct(t,e,r){if(_isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o))();return r&&_setPrototypeOf(p,r.prototype),p;}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t;})();}function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]");}catch(n){return"function"==typeof t;}}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t;},_setPrototypeOf(t,e);}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t);},_getPrototypeOf(t);}function _classCallCheck2(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function");}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey2(o.key),o);}}function _createClass2(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e;}function _toPropertyKey2(t){var i=_toPrimitive2(t,"string");return"symbol"==_typeof2(i)?i:i+"";}function _toPrimitive2(t,r){if("object"!=_typeof2(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof2(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return("string"===r?String:Number)(t);}/******/var __webpack_modules__={/***/"./node_modules/awaitqueue/lib/Logger.js":(/*!***********************************************!*\
  !*** ./node_modules/awaitqueue/lib/Logger.js ***!
  \***********************************************//***/function _node_modules_awaitqueue_lib_LoggerJs(__unused_webpack_module,exports,__nested_webpack_require_15833__){Object.defineProperty(exports,"__esModule",{value:true});exports.Logger=void 0;var debug_1=__nested_webpack_require_15833__(/*! debug */"./node_modules/debug/src/browser.js");var LIB_NAME='awaitqueue';var Logger=/*#__PURE__*/function(){function Logger(prefix){_classCallCheck2(this,Logger);if(prefix){this._debug=(0,debug_1["default"])("".concat(LIB_NAME,":").concat(prefix));this._warn=(0,debug_1["default"])("".concat(LIB_NAME,":WARN:").concat(prefix));this._error=(0,debug_1["default"])("".concat(LIB_NAME,":ERROR:").concat(prefix));}else{this._debug=(0,debug_1["default"])(LIB_NAME);this._warn=(0,debug_1["default"])("".concat(LIB_NAME,":WARN"));this._error=(0,debug_1["default"])("".concat(LIB_NAME,":ERROR"));}/* eslint-disable no-console */this._debug.log=console.info.bind(console);this._warn.log=console.warn.bind(console);this._error.log=console.error.bind(console);/* eslint-enable no-console */}return _createClass2(Logger,[{key:"debug",get:function get(){return this._debug;}},{key:"warn",get:function get(){return this._warn;}},{key:"error",get:function get(){return this._error;}}]);}();exports.Logger=Logger;/***/}),/***/"./node_modules/awaitqueue/lib/index.js":(/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************//***/function _node_modules_awaitqueue_lib_indexJs(__unused_webpack_module,exports,__nested_webpack_require_17257__){Object.defineProperty(exports,"__esModule",{value:true});exports.AwaitQueue=exports.AwaitQueueRemovedTaskError=exports.AwaitQueueStoppedError=void 0;var Logger_1=__nested_webpack_require_17257__(/*! ./Logger */"./node_modules/awaitqueue/lib/Logger.js");var logger=new Logger_1.Logger();/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */var AwaitQueueStoppedError=/*#__PURE__*/function(_Error){function AwaitQueueStoppedError(message){var _this;_classCallCheck2(this,AwaitQueueStoppedError);_this=_callSuper(this,AwaitQueueStoppedError,[message!==null&&message!==void 0?message:'AwaitQueue stopped']);_this.name='AwaitQueueStoppedError';// @ts-ignore
if(typeof Error.captureStackTrace==='function'){// @ts-ignore
Error.captureStackTrace(_this,AwaitQueueStoppedError);}return _this;}_inherits(AwaitQueueStoppedError,_Error);return _createClass2(AwaitQueueStoppedError);}(/*#__PURE__*/_wrapNativeSuper(Error));exports.AwaitQueueStoppedError=AwaitQueueStoppedError;/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */var AwaitQueueRemovedTaskError=/*#__PURE__*/function(_Error2){function AwaitQueueRemovedTaskError(message){var _this2;_classCallCheck2(this,AwaitQueueRemovedTaskError);_this2=_callSuper(this,AwaitQueueRemovedTaskError,[message!==null&&message!==void 0?message:'AwaitQueue task removed']);_this2.name='AwaitQueueRemovedTaskError';// @ts-ignore
if(typeof Error.captureStackTrace==='function'){// @ts-ignore
Error.captureStackTrace(_this2,AwaitQueueRemovedTaskError);}return _this2;}_inherits(AwaitQueueRemovedTaskError,_Error2);return _createClass2(AwaitQueueRemovedTaskError);}(/*#__PURE__*/_wrapNativeSuper(Error));exports.AwaitQueueRemovedTaskError=AwaitQueueRemovedTaskError;var AwaitQueue=/*#__PURE__*/function(){function AwaitQueue(){_classCallCheck2(this,AwaitQueue);// Queue of pending tasks (map of PendingTasks indexed by id).
this.pendingTasks=new Map();// Incrementing PendingTask id.
this.nextTaskId=0;// Whether stop() method is stopping all pending tasks.
this.stopping=false;}return _createClass2(AwaitQueue,[{key:"size",get:function get(){return this.pendingTasks.size;}},{key:"push",value:function(){var _push=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee17(task,name){var _name,_this3=this;return _regeneratorRuntime2().wrap(function _callee17$(_context17){while(1)switch(_context17.prev=_context17.next){case 0:name=(_name=name)!==null&&_name!==void 0?_name:task.name;logger.debug("push() [name:".concat(name,"]"));if(!(typeof task!=='function')){_context17.next=4;break;}throw new TypeError('given task is not a function');case 4:if(name){try{Object.defineProperty(task,'name',{value:name});}catch(error){}}return _context17.abrupt("return",new Promise(function(_resolve,_reject){var pendingTask={id:_this3.nextTaskId++,task:task,name:name,enqueuedAt:Date.now(),executedAt:undefined,completed:false,resolve:function resolve(result){// pendingTask.resolve() can only be called in execute() method. Since
// resolve() was called it means that the task successfully completed.
// However the task may have been stopped before it completed (via
// stop() or remove()) so its completed flag was already set. If this
// is the case, abort here since next task (if any) is already being
// executed.
if(pendingTask.completed){return;}pendingTask.completed=true;// Remove the task from the queue.
_this3.pendingTasks["delete"](pendingTask.id);logger.debug("resolving task [name:".concat(pendingTask.name,"]"));// Resolve the task with the obtained result.
_resolve(result);// Execute the next pending task (if any).
var _this3$pendingTasks$v=_this3.pendingTasks.values(),_this3$pendingTasks$v2=_slicedToArray(_this3$pendingTasks$v,1),nextPendingTask=_this3$pendingTasks$v2[0];// NOTE: During the resolve() callback the user app may have interacted
// with the queue. For instance, the app may have pushed a task while
// the queue was empty so such a task is already being executed. If so,
// don't execute it twice.
if(nextPendingTask&&!nextPendingTask.executedAt){void _this3.execute(nextPendingTask);}},reject:function reject(error){// pendingTask.reject() can be called within execute() method if the
// task completed with error. However it may have also been called in
// stop() or remove() methods (before or while being executed) so its
// completed flag was already set. If so, abort here since next task
// (if any) is already being executed.
if(pendingTask.completed){return;}pendingTask.completed=true;// Remove the task from the queue.
_this3.pendingTasks["delete"](pendingTask.id);logger.debug("rejecting task [name:".concat(pendingTask.name,"]: %s"),String(error));// Reject the task with the obtained error.
_reject(error);// Execute the next pending task (if any) unless stop() is running.
if(!_this3.stopping){var _this3$pendingTasks$v3=_this3.pendingTasks.values(),_this3$pendingTasks$v4=_slicedToArray(_this3$pendingTasks$v3,1),nextPendingTask=_this3$pendingTasks$v4[0];// NOTE: During the reject() callback the user app may have interacted
// with the queue. For instance, the app may have pushed a task while
// the queue was empty so such a task is already being executed. If so,
// don't execute it twice.
if(nextPendingTask&&!nextPendingTask.executedAt){void _this3.execute(nextPendingTask);}}}};// Append task to the queue.
_this3.pendingTasks.set(pendingTask.id,pendingTask);// And execute it if this is the only task in the queue.
if(_this3.pendingTasks.size===1){void _this3.execute(pendingTask);}}));case 6:case"end":return _context17.stop();}},_callee17);}));function push(_x17,_x18){return _push.apply(this,arguments);}return push;}()},{key:"stop",value:function stop(){logger.debug('stop()');this.stopping=true;var _iterator=_createForOfIteratorHelper(this.pendingTasks.values()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var pendingTask=_step.value;logger.debug("stop() | stopping task [name:".concat(pendingTask.name,"]"));pendingTask.reject(new AwaitQueueStoppedError());}}catch(err){_iterator.e(err);}finally{_iterator.f();}this.stopping=false;}},{key:"remove",value:function remove(taskIdx){logger.debug("remove() [taskIdx:".concat(taskIdx,"]"));var pendingTask=Array.from(this.pendingTasks.values())[taskIdx];if(!pendingTask){logger.debug("stop() | no task with given idx [taskIdx:".concat(taskIdx,"]"));return;}pendingTask.reject(new AwaitQueueRemovedTaskError());}},{key:"dump",value:function dump(){var now=Date.now();var idx=0;return Array.from(this.pendingTasks.values()).map(function(pendingTask){return{idx:idx++,task:pendingTask.task,name:pendingTask.name,enqueuedTime:pendingTask.executedAt?pendingTask.executedAt-pendingTask.enqueuedAt:now-pendingTask.enqueuedAt,executionTime:pendingTask.executedAt?now-pendingTask.executedAt:0};});}},{key:"execute",value:function(){var _execute=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee18(pendingTask){var result;return _regeneratorRuntime2().wrap(function _callee18$(_context18){while(1)switch(_context18.prev=_context18.next){case 0:logger.debug("execute() [name:".concat(pendingTask.name,"]"));if(!pendingTask.executedAt){_context18.next=3;break;}throw new Error('task already being executed');case 3:pendingTask.executedAt=Date.now();_context18.prev=4;_context18.next=7;return pendingTask.task();case 7:result=_context18.sent;// Resolve the task with its resolved result (if any).
pendingTask.resolve(result);_context18.next=14;break;case 11:_context18.prev=11;_context18.t0=_context18["catch"](4);// Reject the task with its rejected error.
pendingTask.reject(_context18.t0);case 14:case"end":return _context18.stop();}},_callee18,null,[[4,11]]);}));function execute(_x19){return _execute.apply(this,arguments);}return execute;}()}]);}();exports.AwaitQueue=AwaitQueue;/***/}),/***/"./services/chatService.js":(/*!*********************************!*\
  !*** ./services/chatService.js ***!
  \*********************************//***/function _services_chatServiceJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.chatroom=chatroom;exports.message=message;function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o;},_typeof(o);}function _regeneratorRuntime(){"use strict";/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function _regeneratorRuntime(){return e;};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value;},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e];}try{define({},"");}catch(t){define=function define(t,e,r){return t[e]=r;};}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a;}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)};}catch(t){return{type:"throw",arg:t};}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,function(){return this;});var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach(function(e){define(t,e,function(t){return this._invoke(e,t);});});}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==_typeof(h)&&n.call(h,"__await")?e.resolve(h.__await).then(function(t){invoke("next",t,i,a);},function(t){invoke("throw",t,i,a);}):e.resolve(h).then(function(t){u.value=t,i(u);},function(t){return invoke("throw",t,i,a);});}a(c.arg);}var r;o(this,"_invoke",{value:function value(t,n){function callInvokeWithMethodAndArg(){return new e(function(e,r){invoke(t,n,e,r);});}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}});}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0};}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u;}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg);}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done};}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg);}};}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator["return"]&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y);}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e);}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e;}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0);}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next;};return i.next=i;}}throw new TypeError(_typeof(e)+" is not iterable");}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name));},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t;},e.awrap=function(t){return{__await:t};},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,function(){return this;}),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then(function(t){return t.done?t.value:a.next();});},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,function(){return this;}),define(g,"toString",function(){return"[object Generator]";}),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next;}return next.done=!0,next;};},e.values=values,Context.prototype={constructor:Context,reset:function reset(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t);},stop:function stop(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval;},dispatchException:function dispatchException(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o;}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}}}},abrupt:function abrupt(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break;}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a);},complete:function complete(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y;},finish:function finish(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y;}},"catch":function _catch(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r);}return o;}}throw Error("illegal catch attempt");},delegateYield:function delegateYield(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y;}},e;}function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value;}catch(n){return void e(n);}i.done?t(u):Promise.resolve(u).then(r,o);}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n);}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n);}_next(void 0);});};}// import socketManager from './socketService.js';
function chatroom(roomId,username,socket){console.log("imported room id ".concat(roomId," and username ").concat(username));console.log('chatroom socket: ',socket);socket.emit('joinChatRoom',{roomId:roomId,name:username});}function message(_x){return _message.apply(this,arguments);}function _message(){_message=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(text){var socket;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:socket=window.socketService.getSocket();console.log('socket: ',socket);// if (!socket) {
//     console.warn('Socket not initialized, queuing message');
//     return;
// }
socket.once('connect',function(){try{console.log('Sending message:',text);socket.emit('chat',{content:text,timestamp:Date.now()});}catch(error){console.error('Error sending message:',error);}});case 3:case"end":return _context.stop();}},_callee);}));return _message.apply(this,arguments);}/***/}),/***/"./services/socketService.js":(/*!***********************************!*\
  !*** ./services/socketService.js ***!
  \***********************************//***/function _services_socketServiceJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.createConnection=createConnection;exports["default"]=void 0;function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o;},_typeof(o);}function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function");}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey(o.key),o);}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e;}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+"";}function _toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return("string"===r?String:Number)(t);}var SocketService=/*#__PURE__*/function(){function SocketService(){_classCallCheck(this,SocketService);this.socket=null;// Add this to make the instance available globally
window.socketService=this;}return _createClass(SocketService,[{key:"initialize",value:function initialize(){if(!this.socket){this.socket=io('http://127.0.0.1:3000',{autoConnect:false});}return this.socket;}},{key:"connect",value:function connect(){if(this.socket&&!this.socket.connected){this.socket.connect();}}},{key:"disconnect",value:function disconnect(){if(this.socket&&this.socket.connected){this.socket.disconnect();}}},{key:"getSocket",value:function getSocket(){return this.socket;}// Add this method to make it easy to access from anywhere
}],[{key:"getInstance",value:function getInstance(){return window.socketService;}}]);}();// Create and expose the instance
var socketService=new SocketService();var _default=exports["default"]=socketService;var currentUserId=null;function createConnection(roomId,username){console.log("room id ".concat(roomId," and username ").concat(username));// this is used because server will not initiate connection automatically as we have set 
// autoConnect: false
if(!socket.connected){socket.connect();// return new Promise((resolve, reject) => {
//     socket.on('connect', () => {
//         currentUserId = socket.id;
//         console.log("A client connected: ",socket.id);
//         // sendMessage(socketId,socket);
//         resolve(socket);
//     })
//     socket.on('connect_error', (err) => {
//         console.log("Socket connection error:", err);
//         reject(err); // Reject if thereâ€™s a connection error
//       });
// });
}// socket.on('disconnect',() => {
//     console.log('disconnected from server');
// })
// socket.on('recvMessage', ({msg,userId}) => {
//     console.log('message: ',msg);
//     displayMessage(msg,userId,currentUserId);
// })
}/***/}),/***/"./node_modules/debug/src/browser.js":(/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************//***/function _node_modules_debug_src_browserJs(module,exports,__nested_webpack_require_38598__){/* eslint-env browser *//**
 * This is the web browser implementation of `debug()`.
 */exports.formatArgs=formatArgs;exports.save=save;exports.load=load;exports.useColors=useColors;exports.storage=localstorage();exports.destroy=function(){var warned=false;return function(){if(!warned){warned=true;console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');}};}();/**
 * Colors.
 */exports.colors=['#0000CC','#0000FF','#0033CC','#0033FF','#0066CC','#0066FF','#0099CC','#0099FF','#00CC00','#00CC33','#00CC66','#00CC99','#00CCCC','#00CCFF','#3300CC','#3300FF','#3333CC','#3333FF','#3366CC','#3366FF','#3399CC','#3399FF','#33CC00','#33CC33','#33CC66','#33CC99','#33CCCC','#33CCFF','#6600CC','#6600FF','#6633CC','#6633FF','#66CC00','#66CC33','#9900CC','#9900FF','#9933CC','#9933FF','#99CC00','#99CC33','#CC0000','#CC0033','#CC0066','#CC0099','#CC00CC','#CC00FF','#CC3300','#CC3333','#CC3366','#CC3399','#CC33CC','#CC33FF','#CC6600','#CC6633','#CC9900','#CC9933','#CCCC00','#CCCC33','#FF0000','#FF0033','#FF0066','#FF0099','#FF00CC','#FF00FF','#FF3300','#FF3333','#FF3366','#FF3399','#FF33CC','#FF33FF','#FF6600','#FF6633','#FF9900','#FF9933','#FFCC00','#FFCC33'];/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */// eslint-disable-next-line complexity
function useColors(){// NB: In an Electron preload script, document will be defined but not fully
// initialized. Since we know we're in Chrome, we'll just detect this case
// explicitly
if(typeof window!=='undefined'&&window.process&&(window.process.type==='renderer'||window.process.__nwjs)){return true;}// Internet Explorer and Edge do not support colors.
if(typeof navigator!=='undefined'&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)){return false;}var m;// Is webkit? http://stackoverflow.com/a/16459606/376773
// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
return typeof document!=='undefined'&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||// Is firebug? http://stackoverflow.com/a/398120/376773
typeof window!=='undefined'&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||// Is firefox >= v31?
// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
typeof navigator!=='undefined'&&navigator.userAgent&&(m=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(m[1],10)>=31||// Double check webkit in userAgent just in case we are in a worker
typeof navigator!=='undefined'&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);}/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */function formatArgs(args){args[0]=(this.useColors?'%c':'')+this.namespace+(this.useColors?' %c':' ')+args[0]+(this.useColors?'%c ':' ')+'+'+module.exports.humanize(this.diff);if(!this.useColors){return;}var c='color: '+this.color;args.splice(1,0,c,'color: inherit');// The final "%c" is somewhat tricky, because there could be other
// arguments passed either before or after the %c, so we need to
// figure out the correct index to insert the CSS into
var index=0;var lastC=0;args[0].replace(/%[a-zA-Z%]/g,function(match){if(match==='%%'){return;}index++;if(match==='%c'){// We only are interested in the *last* %c
// (the user may have provided their own)
lastC=index;}});args.splice(lastC,0,c);}/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */exports.log=console.debug||console.log||function(){};/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */function save(namespaces){try{if(namespaces){exports.storage.setItem('debug',namespaces);}else{exports.storage.removeItem('debug');}}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}}/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */function load(){var r;try{r=exports.storage.getItem('debug');}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
if(!r&&typeof process!=='undefined'&&'env'in process){r=process.env.DEBUG;}return r;}/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */function localstorage(){try{// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
// The Browser also has localStorage in the global context.
return localStorage;}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}}module.exports=__nested_webpack_require_38598__(/*! ./common */"./node_modules/debug/src/common.js")(exports);var formatters=module.exports.formatters;/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */formatters.j=function(v){try{return JSON.stringify(v);}catch(error){return'[UnexpectedJSONParseError]: '+error.message;}};/***/}),/***/"./node_modules/debug/src/common.js":(/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************//***/function _node_modules_debug_src_commonJs(module,__unused_webpack_exports,__nested_webpack_require_44365__){/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */function setup(env){createDebug.debug=createDebug;createDebug["default"]=createDebug;createDebug.coerce=coerce;createDebug.disable=disable;createDebug.enable=enable;createDebug.enabled=enabled;createDebug.humanize=__nested_webpack_require_44365__(/*! ms */"./node_modules/ms/index.js");createDebug.destroy=destroy;Object.keys(env).forEach(function(key){createDebug[key]=env[key];});/**
	* The currently active debug mode names, and names to skip.
	*/createDebug.names=[];createDebug.skips=[];/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/createDebug.formatters={};/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/function selectColor(namespace){var hash=0;for(var i=0;i<namespace.length;i++){hash=(hash<<5)-hash+namespace.charCodeAt(i);hash|=0;// Convert to 32bit integer
}return createDebug.colors[Math.abs(hash)%createDebug.colors.length];}createDebug.selectColor=selectColor;/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/function createDebug(namespace){var prevTime;var enableOverride=null;var namespacesCache;var enabledCache;function debug(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}// Disabled?
if(!debug.enabled){return;}var self=debug;// Set `diff` timestamp
var curr=Number(new Date());var ms=curr-(prevTime||curr);self.diff=ms;self.prev=prevTime;self.curr=curr;prevTime=curr;args[0]=createDebug.coerce(args[0]);if(typeof args[0]!=='string'){// Anything else let's inspect with %O
args.unshift('%O');}// Apply any `formatters` transformations
var index=0;args[0]=args[0].replace(/%([a-zA-Z%])/g,function(match,format){// If we encounter an escaped % then don't increase the array index
if(match==='%%'){return'%';}index++;var formatter=createDebug.formatters[format];if(typeof formatter==='function'){var val=args[index];match=formatter.call(self,val);// Now we need to remove `args[index]` since it's inlined in the `format`
args.splice(index,1);index--;}return match;});// Apply env-specific formatting (colors, etc.)
createDebug.formatArgs.call(self,args);var logFn=self.log||createDebug.log;logFn.apply(self,args);}debug.namespace=namespace;debug.useColors=createDebug.useColors();debug.color=createDebug.selectColor(namespace);debug.extend=extend;debug.destroy=createDebug.destroy;// XXX Temporary. Will be removed in the next major release.
Object.defineProperty(debug,'enabled',{enumerable:true,configurable:false,get:function get(){if(enableOverride!==null){return enableOverride;}if(namespacesCache!==createDebug.namespaces){namespacesCache=createDebug.namespaces;enabledCache=createDebug.enabled(namespace);}return enabledCache;},set:function set(v){enableOverride=v;}});// Env-specific initialization logic for debug instances
if(typeof createDebug.init==='function'){createDebug.init(debug);}return debug;}function extend(namespace,delimiter){var newDebug=createDebug(this.namespace+(typeof delimiter==='undefined'?':':delimiter)+namespace);newDebug.log=this.log;return newDebug;}/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/function enable(namespaces){createDebug.save(namespaces);createDebug.namespaces=namespaces;createDebug.names=[];createDebug.skips=[];var i;var split=(typeof namespaces==='string'?namespaces:'').split(/[\s,]+/);var len=split.length;for(i=0;i<len;i++){if(!split[i]){// ignore empty strings
continue;}namespaces=split[i].replace(/\*/g,'.*?');if(namespaces[0]==='-'){createDebug.skips.push(new RegExp('^'+namespaces.slice(1)+'$'));}else{createDebug.names.push(new RegExp('^'+namespaces+'$'));}}}/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/function disable(){var namespaces=[].concat(_toConsumableArray(createDebug.names.map(toNamespace)),_toConsumableArray(createDebug.skips.map(toNamespace).map(function(namespace){return'-'+namespace;}))).join(',');createDebug.enable('');return namespaces;}/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/function enabled(name){if(name[name.length-1]==='*'){return true;}var i;var len;for(i=0,len=createDebug.skips.length;i<len;i++){if(createDebug.skips[i].test(name)){return false;}}for(i=0,len=createDebug.names.length;i<len;i++){if(createDebug.names[i].test(name)){return true;}}return false;}/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/function toNamespace(regexp){return regexp.toString().substring(2,regexp.toString().length-2).replace(/\.\*\?$/,'*');}/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/function coerce(val){if(val instanceof Error){return val.stack||val.message;}return val;}/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/function destroy(){console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');}createDebug.enable(createDebug.load());return createDebug;}module.exports=setup;/***/}),/***/"./node_modules/h264-profile-level-id/lib/Logger.js":(/*!**********************************************************!*\
  !*** ./node_modules/h264-profile-level-id/lib/Logger.js ***!
  \**********************************************************//***/function _node_modules_h264ProfileLevelId_lib_LoggerJs(__unused_webpack_module,exports,__nested_webpack_require_50340__){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});exports.Logger=void 0;var debug_1=__importDefault(__nested_webpack_require_50340__(/*! debug */"./node_modules/debug/src/browser.js"));var APP_NAME='h264-profile-level-id';var Logger=/*#__PURE__*/function(){function Logger(prefix){_classCallCheck2(this,Logger);if(prefix){this._debug=(0,debug_1["default"])("".concat(APP_NAME,":").concat(prefix));this._warn=(0,debug_1["default"])("".concat(APP_NAME,":WARN:").concat(prefix));this._error=(0,debug_1["default"])("".concat(APP_NAME,":ERROR:").concat(prefix));}else{this._debug=(0,debug_1["default"])(APP_NAME);this._warn=(0,debug_1["default"])("".concat(APP_NAME,":WARN"));this._error=(0,debug_1["default"])("".concat(APP_NAME,":ERROR"));}/* eslint-disable no-console */this._debug.log=console.info.bind(console);this._warn.log=console.warn.bind(console);this._error.log=console.error.bind(console);/* eslint-enable no-console */}return _createClass2(Logger,[{key:"debug",get:function get(){return this._debug;}},{key:"warn",get:function get(){return this._warn;}},{key:"error",get:function get(){return this._error;}}]);}();exports.Logger=Logger;/***/}),/***/"./node_modules/h264-profile-level-id/lib/index.js":(/*!*********************************************************!*\
  !*** ./node_modules/h264-profile-level-id/lib/index.js ***!
  \*********************************************************//***/function _node_modules_h264ProfileLevelId_lib_indexJs(__unused_webpack_module,exports,__nested_webpack_require_51955__){Object.defineProperty(exports,"__esModule",{value:true});exports.generateProfileLevelIdStringForAnswer=exports.isSameProfile=exports.parseSdpProfileLevelId=exports.levelToString=exports.profileToString=exports.profileLevelIdToString=exports.parseProfileLevelId=exports.ProfileLevelId=exports.Level=exports.Profile=void 0;var Logger_1=__nested_webpack_require_51955__(/*! ./Logger */"./node_modules/h264-profile-level-id/lib/Logger.js");var logger=new Logger_1.Logger();/**
 * Supported profiles.
 */// ESLint absurdly complains about "'Profile' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Profile;(function(Profile){Profile[Profile["ConstrainedBaseline"]=1]="ConstrainedBaseline";Profile[Profile["Baseline"]=2]="Baseline";Profile[Profile["Main"]=3]="Main";Profile[Profile["ConstrainedHigh"]=4]="ConstrainedHigh";Profile[Profile["High"]=5]="High";Profile[Profile["PredictiveHigh444"]=6]="PredictiveHigh444";})(Profile||(exports.Profile=Profile={}));/**
 * Supported levels.
 */// ESLint absurdly complains about "'Level' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Level;(function(Level){Level[Level["L1_b"]=0]="L1_b";Level[Level["L1"]=10]="L1";Level[Level["L1_1"]=11]="L1_1";Level[Level["L1_2"]=12]="L1_2";Level[Level["L1_3"]=13]="L1_3";Level[Level["L2"]=20]="L2";Level[Level["L2_1"]=21]="L2_1";Level[Level["L2_2"]=22]="L2_2";Level[Level["L3"]=30]="L3";Level[Level["L3_1"]=31]="L3_1";Level[Level["L3_2"]=32]="L3_2";Level[Level["L4"]=40]="L4";Level[Level["L4_1"]=41]="L4_1";Level[Level["L4_2"]=42]="L4_2";Level[Level["L5"]=50]="L5";Level[Level["L5_1"]=51]="L5_1";Level[Level["L5_2"]=52]="L5_2";})(Level||(exports.Level=Level={}));/**
 * Represents a parsed h264 profile-level-id value.
 */var ProfileLevelId=/*#__PURE__*/_createClass2(function ProfileLevelId(profile,level){_classCallCheck2(this,ProfileLevelId);this.profile=profile;this.level=level;});exports.ProfileLevelId=ProfileLevelId;// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
var DefaultProfileLevelId=new ProfileLevelId(Profile.ConstrainedBaseline,Level.L3_1);/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */var BitPattern=/*#__PURE__*/function(){function BitPattern(str){_classCallCheck2(this,BitPattern);this.mask=~byteMaskString('x',str);this.masked_value=byteMaskString('1',str);}return _createClass2(BitPattern,[{key:"isMatch",value:function isMatch(value){return this.masked_value===(value&this.mask);}}]);}();/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */var ProfilePattern=/*#__PURE__*/_createClass2(function ProfilePattern(profile_idc,profile_iop,profile){_classCallCheck2(this,ProfilePattern);this.profile_idc=profile_idc;this.profile_iop=profile_iop;this.profile=profile;});// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
var ProfilePatterns=[new ProfilePattern(0x42,new BitPattern('x1xx0000'),Profile.ConstrainedBaseline),new ProfilePattern(0x4D,new BitPattern('1xxx0000'),Profile.ConstrainedBaseline),new ProfilePattern(0x58,new BitPattern('11xx0000'),Profile.ConstrainedBaseline),new ProfilePattern(0x42,new BitPattern('x0xx0000'),Profile.Baseline),new ProfilePattern(0x58,new BitPattern('10xx0000'),Profile.Baseline),new ProfilePattern(0x4D,new BitPattern('0x0x0000'),Profile.Main),new ProfilePattern(0x64,new BitPattern('00000000'),Profile.High),new ProfilePattern(0x64,new BitPattern('00001100'),Profile.ConstrainedHigh),new ProfilePattern(0xF4,new BitPattern('00000000'),Profile.PredictiveHigh444)];/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */function parseProfileLevelId(str){// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
// flag specifies if level 1b or level 1.1 is used.
var ConstraintSet3Flag=0x10;// The string should consist of 3 bytes in hexadecimal format.
if(typeof str!=='string'||str.length!==6){return undefined;}var profile_level_id_numeric=parseInt(str,16);if(profile_level_id_numeric===0){return undefined;}// Separate into three bytes.
var level_idc=profile_level_id_numeric&0xFF;var profile_iop=profile_level_id_numeric>>8&0xFF;var profile_idc=profile_level_id_numeric>>16&0xFF;// Parse level based on level_idc and constraint set 3 flag.
var level;switch(level_idc){case Level.L1_1:{level=(profile_iop&ConstraintSet3Flag)!==0?Level.L1_b:Level.L1_1;break;}case Level.L1:case Level.L1_2:case Level.L1_3:case Level.L2:case Level.L2_1:case Level.L2_2:case Level.L3:case Level.L3_1:case Level.L3_2:case Level.L4:case Level.L4_1:case Level.L4_2:case Level.L5:case Level.L5_1:case Level.L5_2:{level=level_idc;break;}// Unrecognized level_idc.
default:{logger.warn("parseProfileLevelId() | unrecognized level_idc [str:".concat(str,", level_idc:").concat(level_idc,"]"));return undefined;}}// Parse profile_idc/profile_iop into a Profile enum.
var _iterator2=_createForOfIteratorHelper(ProfilePatterns),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var pattern=_step2.value;if(profile_idc===pattern.profile_idc&&pattern.profile_iop.isMatch(profile_iop)){return new ProfileLevelId(pattern.profile,level);}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}logger.warn("parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:".concat(str,", profile_idc:").concat(profile_idc,", profile_iop:").concat(profile_iop,"]"));return undefined;}exports.parseProfileLevelId=parseProfileLevelId;/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */function profileLevelIdToString(profile_level_id){// Handle special case level == 1b.
if(profile_level_id.level==Level.L1_b){switch(profile_level_id.profile){case Profile.ConstrainedBaseline:{return'42f00b';}case Profile.Baseline:{return'42100b';}case Profile.Main:{return'4d100b';}// Level 1_b is not allowed for other profiles.
default:{logger.warn("profileLevelIdToString() | Level 1_b not is allowed for profile ".concat(profile_level_id.profile));return undefined;}}}var profile_idc_iop_string;switch(profile_level_id.profile){case Profile.ConstrainedBaseline:{profile_idc_iop_string='42e0';break;}case Profile.Baseline:{profile_idc_iop_string='4200';break;}case Profile.Main:{profile_idc_iop_string='4d00';break;}case Profile.ConstrainedHigh:{profile_idc_iop_string='640c';break;}case Profile.High:{profile_idc_iop_string='6400';break;}case Profile.PredictiveHigh444:{profile_idc_iop_string='f400';break;}default:{logger.warn("profileLevelIdToString() | unrecognized profile ".concat(profile_level_id.profile));return undefined;}}var levelStr=profile_level_id.level.toString(16);if(levelStr.length===1){levelStr="0".concat(levelStr);}return"".concat(profile_idc_iop_string).concat(levelStr);}exports.profileLevelIdToString=profileLevelIdToString;/**
 * Returns a human friendly name for the given profile.
 */function profileToString(profile){switch(profile){case Profile.ConstrainedBaseline:{return'ConstrainedBaseline';}case Profile.Baseline:{return'Baseline';}case Profile.Main:{return'Main';}case Profile.ConstrainedHigh:{return'ConstrainedHigh';}case Profile.High:{return'High';}case Profile.PredictiveHigh444:{return'PredictiveHigh444';}default:{logger.warn("profileToString() | unrecognized profile ".concat(profile));return undefined;}}}exports.profileToString=profileToString;/**
 * Returns a human friendly name for the given level.
 */function levelToString(level){switch(level){case Level.L1_b:{return'1b';}case Level.L1:{return'1';}case Level.L1_1:{return'1.1';}case Level.L1_2:{return'1.2';}case Level.L1_3:{return'1.3';}case Level.L2:{return'2';}case Level.L2_1:{return'2.1';}case Level.L2_2:{return'2.2';}case Level.L3:{return'3';}case Level.L3_1:{return'3.1';}case Level.L3_2:{return'3.2';}case Level.L4:{return'4';}case Level.L4_1:{return'4.1';}case Level.L4_2:{return'4.2';}case Level.L5:{return'5';}case Level.L5_1:{return'5.1';}case Level.L5_2:{return'5.2';}default:{logger.warn("levelToString() | unrecognized level ".concat(level));return undefined;}}}exports.levelToString=levelToString;/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */function parseSdpProfileLevelId(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var profile_level_id=params['profile-level-id'];return profile_level_id?parseProfileLevelId(profile_level_id):DefaultProfileLevelId;}exports.parseSdpProfileLevelId=parseSdpProfileLevelId;/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 */function isSameProfile(){var params1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var params2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var profile_level_id_1=parseSdpProfileLevelId(params1);var profile_level_id_2=parseSdpProfileLevelId(params2);// Compare H264 profiles, but not levels.
return Boolean(profile_level_id_1&&profile_level_id_2&&profile_level_id_1.profile===profile_level_id_2.profile);}exports.isSameProfile=isSameProfile;/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */function generateProfileLevelIdStringForAnswer(){var local_supported_params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var remote_offered_params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// If both local and remote params do not contain profile-level-id, they are
// both using the default profile. In this case, don't return anything.
if(!local_supported_params['profile-level-id']&&!remote_offered_params['profile-level-id']){logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');return undefined;}// Parse profile-level-ids.
var local_profile_level_id=parseSdpProfileLevelId(local_supported_params);var remote_profile_level_id=parseSdpProfileLevelId(remote_offered_params);// The local and remote codec must have valid and equal H264 Profiles.
if(!local_profile_level_id){throw new TypeError('invalid local_profile_level_id');}if(!remote_profile_level_id){throw new TypeError('invalid remote_profile_level_id');}if(local_profile_level_id.profile!==remote_profile_level_id.profile){throw new TypeError('H264 Profile mismatch');}// Parse level information.
var level_asymmetry_allowed=isLevelAsymmetryAllowed(local_supported_params)&&isLevelAsymmetryAllowed(remote_offered_params);var local_level=local_profile_level_id.level;var remote_level=remote_profile_level_id.level;var min_level=minLevel(local_level,remote_level);// Determine answer level. When level asymmetry is not allowed, level upgrade
// is not allowed, i.e., the level in the answer must be equal to or lower
// than the level in the offer.
var answer_level=level_asymmetry_allowed?local_level:min_level;logger.debug("generateProfileLevelIdStringForAnswer() | result [profile:".concat(local_profile_level_id.profile,", level:").concat(answer_level,"]"));// Return the resulting profile-level-id for the answer parameters.
return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile,answer_level));}exports.generateProfileLevelIdStringForAnswer=generateProfileLevelIdStringForAnswer;/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */function byteMaskString(c,str){return Number(str[0]===c)<<7|Number(str[1]===c)<<6|Number(str[2]===c)<<5|Number(str[3]===c)<<4|Number(str[4]===c)<<3|Number(str[5]===c)<<2|Number(str[6]===c)<<1|Number(str[7]===c)<<0;}// Compare H264 levels and handle the level 1b case.
function isLessLevel(a,b){if(a===Level.L1_b){return b!==Level.L1&&b!==Level.L1_b;}if(b===Level.L1_b){return a!==Level.L1;}return a<b;}function minLevel(a,b){return isLessLevel(a,b)?a:b;}function isLevelAsymmetryAllowed(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var level_asymmetry_allowed=params['level-asymmetry-allowed'];return level_asymmetry_allowed===true||level_asymmetry_allowed===1||level_asymmetry_allowed==='1';}/***/}),/***/"./node_modules/mediasoup-client/lib/Consumer.js":(/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Consumer.js ***!
  \*******************************************************//***/function _node_modules_mediasoupClient_lib_ConsumerJs(__unused_webpack_module,exports,__nested_webpack_require_66284__){Object.defineProperty(exports,"__esModule",{value:true});exports.Consumer=void 0;var Logger_1=__nested_webpack_require_66284__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_66284__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var errors_1=__nested_webpack_require_66284__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js");var logger=new Logger_1.Logger('Consumer');var Consumer=/*#__PURE__*/function(_enhancedEvents_1$Enh){function Consumer(_ref){var _this4;var id=_ref.id,localId=_ref.localId,producerId=_ref.producerId,rtpReceiver=_ref.rtpReceiver,track=_ref.track,rtpParameters=_ref.rtpParameters,appData=_ref.appData;_classCallCheck2(this,Consumer);_this4=_callSuper(this,Consumer);// Closed flag.
_this4._closed=false;// Observer instance.
_this4._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor()');_this4._id=id;_this4._localId=localId;_this4._producerId=producerId;_this4._rtpReceiver=rtpReceiver;_this4._track=track;_this4._rtpParameters=rtpParameters;_this4._paused=!track.enabled;_this4._appData=appData!==null&&appData!==void 0?appData:{};_this4.onTrackEnded=_this4.onTrackEnded.bind(_this4);_this4.handleTrack();return _this4;}/**
     * Consumer id.
     */_inherits(Consumer,_enhancedEvents_1$Enh);return _createClass2(Consumer,[{key:"id",get:function get(){return this._id;}/**
     * Local id.
     */},{key:"localId",get:function get(){return this._localId;}/**
     * Associated Producer id.
     */},{key:"producerId",get:function get(){return this._producerId;}/**
     * Whether the Consumer is closed.
     */},{key:"closed",get:function get(){return this._closed;}/**
     * Media kind.
     */},{key:"kind",get:function get(){return this._track.kind;}/**
     * Associated RTCRtpReceiver.
     */},{key:"rtpReceiver",get:function get(){return this._rtpReceiver;}/**
     * The associated track.
     */},{key:"track",get:function get(){return this._track;}/**
     * RTP parameters.
     */},{key:"rtpParameters",get:function get(){return this._rtpParameters;}/**
     * Whether the Consumer is paused.
     */},{key:"paused",get:function get(){return this._paused;}/**
     * App custom data.
     */},{key:"appData",get:function get(){return this._appData;}/**
     * App custom data setter.
     */,set:function set(appData){this._appData=appData;}},{key:"observer",get:function get(){return this._observer;}/**
     * Closes the Consumer.
     */},{key:"close",value:function close(){if(this._closed){return;}logger.debug('close()');this._closed=true;this.destroyTrack();this.emit('@close');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Transport was closed.
     */},{key:"transportClosed",value:function transportClosed(){if(this._closed){return;}logger.debug('transportClosed()');this._closed=true;this.destroyTrack();this.safeEmit('transportclose');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Get associated RTCRtpReceiver stats.
     */},{key:"getStats",value:(function(){var _getStats=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee19(){var _this5=this;return _regeneratorRuntime2().wrap(function _callee19$(_context19){while(1)switch(_context19.prev=_context19.next){case 0:if(!this._closed){_context19.next=2;break;}throw new errors_1.InvalidStateError('closed');case 2:return _context19.abrupt("return",new Promise(function(resolve,reject){_this5.safeEmit('@getstats',resolve,reject);}));case 3:case"end":return _context19.stop();}},_callee19,this);}));function getStats(){return _getStats.apply(this,arguments);}return getStats;}()/**
     * Pauses receiving media.
     */)},{key:"pause",value:function pause(){logger.debug('pause()');if(this._closed){logger.error('pause() | Consumer closed');return;}if(this._paused){logger.debug('pause() | Consumer is already paused');return;}this._paused=true;this._track.enabled=false;this.emit('@pause');// Emit observer event.
this._observer.safeEmit('pause');}/**
     * Resumes receiving media.
     */},{key:"resume",value:function resume(){logger.debug('resume()');if(this._closed){logger.error('resume() | Consumer closed');return;}if(!this._paused){logger.debug('resume() | Consumer is already resumed');return;}this._paused=false;this._track.enabled=true;this.emit('@resume');// Emit observer event.
this._observer.safeEmit('resume');}},{key:"onTrackEnded",value:function onTrackEnded(){logger.debug('track "ended" event');this.safeEmit('trackended');// Emit observer event.
this._observer.safeEmit('trackended');}},{key:"handleTrack",value:function handleTrack(){this._track.addEventListener('ended',this.onTrackEnded);}},{key:"destroyTrack",value:function destroyTrack(){try{this._track.removeEventListener('ended',this.onTrackEnded);this._track.stop();}catch(error){}}}]);}(enhancedEvents_1.EnhancedEventEmitter);exports.Consumer=Consumer;/***/}),/***/"./node_modules/mediasoup-client/lib/DataConsumer.js":(/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \***********************************************************//***/function _node_modules_mediasoupClient_lib_DataConsumerJs(__unused_webpack_module,exports,__nested_webpack_require_71573__){Object.defineProperty(exports,"__esModule",{value:true});exports.DataConsumer=void 0;var Logger_1=__nested_webpack_require_71573__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_71573__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var logger=new Logger_1.Logger('DataConsumer');var DataConsumer=/*#__PURE__*/function(_enhancedEvents_1$Enh2){function DataConsumer(_ref2){var _this6;var id=_ref2.id,dataProducerId=_ref2.dataProducerId,dataChannel=_ref2.dataChannel,sctpStreamParameters=_ref2.sctpStreamParameters,appData=_ref2.appData;_classCallCheck2(this,DataConsumer);_this6=_callSuper(this,DataConsumer);// Closed flag.
_this6._closed=false;// Observer instance.
_this6._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor()');_this6._id=id;_this6._dataProducerId=dataProducerId;_this6._dataChannel=dataChannel;_this6._sctpStreamParameters=sctpStreamParameters;_this6._appData=appData!==null&&appData!==void 0?appData:{};_this6.handleDataChannel();return _this6;}/**
     * DataConsumer id.
     */_inherits(DataConsumer,_enhancedEvents_1$Enh2);return _createClass2(DataConsumer,[{key:"id",get:function get(){return this._id;}/**
     * Associated DataProducer id.
     */},{key:"dataProducerId",get:function get(){return this._dataProducerId;}/**
     * Whether the DataConsumer is closed.
     */},{key:"closed",get:function get(){return this._closed;}/**
     * SCTP stream parameters.
     */},{key:"sctpStreamParameters",get:function get(){return this._sctpStreamParameters;}/**
     * DataChannel readyState.
     */},{key:"readyState",get:function get(){return this._dataChannel.readyState;}/**
     * DataChannel label.
     */},{key:"label",get:function get(){return this._dataChannel.label;}/**
     * DataChannel protocol.
     */},{key:"protocol",get:function get(){return this._dataChannel.protocol;}/**
     * DataChannel binaryType.
     */},{key:"binaryType",get:function get(){return this._dataChannel.binaryType;}/**
     * Set DataChannel binaryType.
     */,set:function set(binaryType){this._dataChannel.binaryType=binaryType;}/**
     * App custom data.
     */},{key:"appData",get:function get(){return this._appData;}/**
     * App custom data setter.
     */,set:function set(appData){this._appData=appData;}},{key:"observer",get:function get(){return this._observer;}/**
     * Closes the DataConsumer.
     */},{key:"close",value:function close(){if(this._closed){return;}logger.debug('close()');this._closed=true;this._dataChannel.close();this.emit('@close');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Transport was closed.
     */},{key:"transportClosed",value:function transportClosed(){if(this._closed){return;}logger.debug('transportClosed()');this._closed=true;this._dataChannel.close();this.safeEmit('transportclose');// Emit observer event.
this._observer.safeEmit('close');}},{key:"handleDataChannel",value:function handleDataChannel(){var _this7=this;this._dataChannel.addEventListener('open',function(){if(_this7._closed){return;}logger.debug('DataChannel "open" event');_this7.safeEmit('open');});this._dataChannel.addEventListener('error',function(event){if(_this7._closed){return;}var error=event.error;if(!error){error=new Error('unknown DataChannel error');}if(error.errorDetail==='sctp-failure'){logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s',error.sctpCauseCode,error.message);}else{logger.error('DataChannel "error" event: %o',error);}_this7.safeEmit('error',error);});this._dataChannel.addEventListener('close',function(){if(_this7._closed){return;}logger.warn('DataChannel "close" event');_this7._closed=true;_this7.emit('@close');_this7.safeEmit('close');// Emit observer event.
_this7._observer.safeEmit('close');});this._dataChannel.addEventListener('message',function(event){if(_this7._closed){return;}_this7.safeEmit('message',event.data);});}}]);}(enhancedEvents_1.EnhancedEventEmitter);exports.DataConsumer=DataConsumer;/***/}),/***/"./node_modules/mediasoup-client/lib/DataProducer.js":(/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataProducer.js ***!
  \***********************************************************//***/function _node_modules_mediasoupClient_lib_DataProducerJs(__unused_webpack_module,exports,__nested_webpack_require_75966__){Object.defineProperty(exports,"__esModule",{value:true});exports.DataProducer=void 0;var Logger_1=__nested_webpack_require_75966__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_75966__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var errors_1=__nested_webpack_require_75966__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js");var logger=new Logger_1.Logger('DataProducer');var DataProducer=/*#__PURE__*/function(_enhancedEvents_1$Enh3){function DataProducer(_ref13){var _this8;var id=_ref13.id,dataChannel=_ref13.dataChannel,sctpStreamParameters=_ref13.sctpStreamParameters,appData=_ref13.appData;_classCallCheck2(this,DataProducer);_this8=_callSuper(this,DataProducer);// Closed flag.
_this8._closed=false;// Observer instance.
_this8._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor()');_this8._id=id;_this8._dataChannel=dataChannel;_this8._sctpStreamParameters=sctpStreamParameters;_this8._appData=appData!==null&&appData!==void 0?appData:{};_this8.handleDataChannel();return _this8;}/**
     * DataProducer id.
     */_inherits(DataProducer,_enhancedEvents_1$Enh3);return _createClass2(DataProducer,[{key:"id",get:function get(){return this._id;}/**
     * Whether the DataProducer is closed.
     */},{key:"closed",get:function get(){return this._closed;}/**
     * SCTP stream parameters.
     */},{key:"sctpStreamParameters",get:function get(){return this._sctpStreamParameters;}/**
     * DataChannel readyState.
     */},{key:"readyState",get:function get(){return this._dataChannel.readyState;}/**
     * DataChannel label.
     */},{key:"label",get:function get(){return this._dataChannel.label;}/**
     * DataChannel protocol.
     */},{key:"protocol",get:function get(){return this._dataChannel.protocol;}/**
     * DataChannel bufferedAmount.
     */},{key:"bufferedAmount",get:function get(){return this._dataChannel.bufferedAmount;}/**
     * DataChannel bufferedAmountLowThreshold.
     */},{key:"bufferedAmountLowThreshold",get:function get(){return this._dataChannel.bufferedAmountLowThreshold;}/**
     * Set DataChannel bufferedAmountLowThreshold.
     */,set:function set(bufferedAmountLowThreshold){this._dataChannel.bufferedAmountLowThreshold=bufferedAmountLowThreshold;}/**
     * App custom data.
     */},{key:"appData",get:function get(){return this._appData;}/**
     * App custom data setter.
     */,set:function set(appData){this._appData=appData;}},{key:"observer",get:function get(){return this._observer;}/**
     * Closes the DataProducer.
     */},{key:"close",value:function close(){if(this._closed){return;}logger.debug('close()');this._closed=true;this._dataChannel.close();this.emit('@close');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Transport was closed.
     */},{key:"transportClosed",value:function transportClosed(){if(this._closed){return;}logger.debug('transportClosed()');this._closed=true;this._dataChannel.close();this.safeEmit('transportclose');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */},{key:"send",value:function send(data){logger.debug('send()');if(this._closed){throw new errors_1.InvalidStateError('closed');}this._dataChannel.send(data);}},{key:"handleDataChannel",value:function handleDataChannel(){var _this9=this;this._dataChannel.addEventListener('open',function(){if(_this9._closed){return;}logger.debug('DataChannel "open" event');_this9.safeEmit('open');});this._dataChannel.addEventListener('error',function(event){if(_this9._closed){return;}var error=event.error;if(!error){error=new Error('unknown DataChannel error');}if(error.errorDetail==='sctp-failure'){logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s',error.sctpCauseCode,error.message);}else{logger.error('DataChannel "error" event: %o',error);}_this9.safeEmit('error',error);});this._dataChannel.addEventListener('close',function(){if(_this9._closed){return;}logger.warn('DataChannel "close" event');_this9._closed=true;_this9.emit('@close');_this9.safeEmit('close');// Emit observer event.
_this9._observer.safeEmit('close');});this._dataChannel.addEventListener('message',function(){if(_this9._closed){return;}logger.warn('DataChannel "message" event in a DataProducer, message discarded');});this._dataChannel.addEventListener('bufferedamountlow',function(){if(_this9._closed){return;}_this9.safeEmit('bufferedamountlow');});}}]);}(enhancedEvents_1.EnhancedEventEmitter);exports.DataProducer=DataProducer;/***/}),/***/"./node_modules/mediasoup-client/lib/Device.js":(/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Device.js ***!
  \*****************************************************//***/function _node_modules_mediasoupClient_lib_DeviceJs(__unused_webpack_module,exports,__nested_webpack_require_80912__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Device=void 0;exports.detectDevice=detectDevice;var ua_parser_js_1=__nested_webpack_require_80912__(/*! ua-parser-js */"./node_modules/ua-parser-js/src/ua-parser.js");var Logger_1=__nested_webpack_require_80912__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_80912__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var errors_1=__nested_webpack_require_80912__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_80912__(/*! ./utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_80912__(/*! ./ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var Transport_1=__nested_webpack_require_80912__(/*! ./Transport */"./node_modules/mediasoup-client/lib/Transport.js");var Chrome111_1=__nested_webpack_require_80912__(/*! ./handlers/Chrome111 */"./node_modules/mediasoup-client/lib/handlers/Chrome111.js");var Chrome74_1=__nested_webpack_require_80912__(/*! ./handlers/Chrome74 */"./node_modules/mediasoup-client/lib/handlers/Chrome74.js");var Chrome70_1=__nested_webpack_require_80912__(/*! ./handlers/Chrome70 */"./node_modules/mediasoup-client/lib/handlers/Chrome70.js");var Chrome67_1=__nested_webpack_require_80912__(/*! ./handlers/Chrome67 */"./node_modules/mediasoup-client/lib/handlers/Chrome67.js");var Chrome55_1=__nested_webpack_require_80912__(/*! ./handlers/Chrome55 */"./node_modules/mediasoup-client/lib/handlers/Chrome55.js");var Firefox120_1=__nested_webpack_require_80912__(/*! ./handlers/Firefox120 */"./node_modules/mediasoup-client/lib/handlers/Firefox120.js");var Firefox60_1=__nested_webpack_require_80912__(/*! ./handlers/Firefox60 */"./node_modules/mediasoup-client/lib/handlers/Firefox60.js");var Safari12_1=__nested_webpack_require_80912__(/*! ./handlers/Safari12 */"./node_modules/mediasoup-client/lib/handlers/Safari12.js");var Safari11_1=__nested_webpack_require_80912__(/*! ./handlers/Safari11 */"./node_modules/mediasoup-client/lib/handlers/Safari11.js");var Edge11_1=__nested_webpack_require_80912__(/*! ./handlers/Edge11 */"./node_modules/mediasoup-client/lib/handlers/Edge11.js");var ReactNativeUnifiedPlan_1=__nested_webpack_require_80912__(/*! ./handlers/ReactNativeUnifiedPlan */"./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js");var ReactNative_1=__nested_webpack_require_80912__(/*! ./handlers/ReactNative */"./node_modules/mediasoup-client/lib/handlers/ReactNative.js");var logger=new Logger_1.Logger('Device');function detectDevice(userAgent){// React-Native.
// NOTE: react-native-webrtc >= 1.75.0 is required.
// NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
if(!userAgent&&(typeof navigator==="undefined"?"undefined":_typeof2(navigator))==='object'&&navigator.product==='ReactNative'){logger.debug('detectDevice() | React-Native detected');if(typeof RTCPeerConnection==='undefined'){logger.warn('detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');return undefined;}if(typeof RTCRtpTransceiver!=='undefined'){logger.debug('detectDevice() | ReactNative UnifiedPlan handler chosen');return'ReactNativeUnifiedPlan';}else{logger.debug('detectDevice() | ReactNative PlanB handler chosen');return'ReactNative';}}// Browser.
else if(userAgent||(typeof navigator==="undefined"?"undefined":_typeof2(navigator))==='object'&&typeof navigator.userAgent==='string'){var _userAgent,_browser$name,_browser$major,_engine$name,_os$name,_os$version,_device$model;(_userAgent=userAgent)!==null&&_userAgent!==void 0?_userAgent:userAgent=navigator.userAgent;var uaParser=new ua_parser_js_1.UAParser(userAgent);logger.debug('detectDevice() | browser detected [userAgent:%s, parsed:%o]',userAgent,uaParser.getResult());var browser=uaParser.getBrowser();var browserName=(_browser$name=browser.name)===null||_browser$name===void 0?void 0:_browser$name.toLowerCase();var browserVersion=parseInt((_browser$major=browser.major)!==null&&_browser$major!==void 0?_browser$major:'0');var engine=uaParser.getEngine();var engineName=(_engine$name=engine.name)===null||_engine$name===void 0?void 0:_engine$name.toLowerCase();var os=uaParser.getOS();var osName=(_os$name=os.name)===null||_os$name===void 0?void 0:_os$name.toLowerCase();var osVersion=parseFloat((_os$version=os.version)!==null&&_os$version!==void 0?_os$version:'0');var device=uaParser.getDevice();var deviceModel=(_device$model=device.model)===null||_device$model===void 0?void 0:_device$model.toLowerCase();var isIOS=osName==='ios'||deviceModel==='ipad';var isChrome=browserName&&['chrome','chromium','mobile chrome','chrome webview','chrome headless'].includes(browserName);var isFirefox=browserName&&['firefox','mobile firefox','mobile focus'].includes(browserName);var isSafari=browserName&&['safari','mobile safari'].includes(browserName);var isEdge=browserName&&['edge'].includes(browserName);// Chrome, Chromium, and Edge.
if((isChrome||isEdge)&&!isIOS&&browserVersion>=111){return'Chrome111';}else if(isChrome&&!isIOS&&browserVersion>=74||isEdge&&!isIOS&&browserVersion>=88){return'Chrome74';}else if(isChrome&&!isIOS&&browserVersion>=70){return'Chrome70';}else if(isChrome&&!isIOS&&browserVersion>=67){return'Chrome67';}else if(isChrome&&!isIOS&&browserVersion>=55){return'Chrome55';}// Firefox.
else if(isFirefox&&!isIOS&&browserVersion>=120){return'Firefox120';}else if(isFirefox&&!isIOS&&browserVersion>=60){return'Firefox60';}// Firefox on iOS (so Safari).
else if(isFirefox&&isIOS&&osVersion>=14.3){return'Safari12';}// Safari with Unified-Plan support enabled.
else if(isSafari&&browserVersion>=12&&typeof RTCRtpTransceiver!=='undefined'&&RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')){return'Safari12';}// Safari with Plab-B support.
else if(isSafari&&browserVersion>=11){return'Safari11';}// Old Edge with ORTC support.
else if(isEdge&&!isIOS&&browserVersion>=11&&browserVersion<=18){return'Edge11';}// Best effort for WebKit based browsers in iOS.
else if(engineName==='webkit'&&isIOS&&typeof RTCRtpTransceiver!=='undefined'&&RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')){return'Safari12';}// Best effort for Chromium based browsers.
else if(engineName==='blink'){// eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
var match=userAgent.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);if(match){var version=Number(match[1]);if(version>=111){return'Chrome111';}else if(version>=74){return'Chrome74';}else if(version>=70){return'Chrome70';}else if(version>=67){return'Chrome67';}else{return'Chrome55';}}else{return'Chrome111';}}// Unsupported browser.
else{logger.warn('detectDevice() | browser not supported [name:%s, version:%s]',browserName,browserVersion);return undefined;}}// Unknown device.
else{logger.warn('detectDevice() | unknown device');return undefined;}}var Device=/*#__PURE__*/function(){/**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */function Device(){var _ref14=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},handlerName=_ref14.handlerName,handlerFactory=_ref14.handlerFactory;_classCallCheck2(this,Device);// Loaded flag.
this._loaded=false;// Observer instance.
this._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor()');if(handlerName&&handlerFactory){throw new TypeError('just one of handlerName or handlerInterface can be given');}if(handlerFactory){this._handlerFactory=handlerFactory;}else{if(handlerName){logger.debug('constructor() | handler given: %s',handlerName);}else{handlerName=detectDevice();if(handlerName){logger.debug('constructor() | detected handler: %s',handlerName);}else{throw new errors_1.UnsupportedError('device not supported');}}switch(handlerName){case'Chrome111':{this._handlerFactory=Chrome111_1.Chrome111.createFactory();break;}case'Chrome74':{this._handlerFactory=Chrome74_1.Chrome74.createFactory();break;}case'Chrome70':{this._handlerFactory=Chrome70_1.Chrome70.createFactory();break;}case'Chrome67':{this._handlerFactory=Chrome67_1.Chrome67.createFactory();break;}case'Chrome55':{this._handlerFactory=Chrome55_1.Chrome55.createFactory();break;}case'Firefox120':{this._handlerFactory=Firefox120_1.Firefox120.createFactory();break;}case'Firefox60':{this._handlerFactory=Firefox60_1.Firefox60.createFactory();break;}case'Safari12':{this._handlerFactory=Safari12_1.Safari12.createFactory();break;}case'Safari11':{this._handlerFactory=Safari11_1.Safari11.createFactory();break;}case'Edge11':{this._handlerFactory=Edge11_1.Edge11.createFactory();break;}case'ReactNativeUnifiedPlan':{this._handlerFactory=ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();break;}case'ReactNative':{this._handlerFactory=ReactNative_1.ReactNative.createFactory();break;}default:{throw new TypeError("unknown handlerName \"".concat(handlerName,"\""));}}}// Create a temporal handler to get its name.
var handler=this._handlerFactory();this._handlerName=handler.name;handler.close();this._extendedRtpCapabilities=undefined;this._recvRtpCapabilities=undefined;this._canProduceByKind={audio:false,video:false};this._sctpCapabilities=undefined;}/**
     * The RTC handler name.
     */return _createClass2(Device,[{key:"handlerName",get:function get(){return this._handlerName;}/**
     * Whether the Device is loaded.
     */},{key:"loaded",get:function get(){return this._loaded;}/**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */},{key:"rtpCapabilities",get:function get(){if(!this._loaded){throw new errors_1.InvalidStateError('not loaded');}return this._recvRtpCapabilities;}/**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */},{key:"sctpCapabilities",get:function get(){if(!this._loaded){throw new errors_1.InvalidStateError('not loaded');}return this._sctpCapabilities;}},{key:"observer",get:function get(){return this._observer;}/**
     * Initialize the Device.
     */},{key:"load",value:(function(){var _load=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee20(_ref15){var routerRtpCapabilities,handler,clonedRouterRtpCapabilities,nativeRtpCapabilities,clonedNativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee20$(_context20){while(1)switch(_context20.prev=_context20.next){case 0:routerRtpCapabilities=_ref15.routerRtpCapabilities;logger.debug('load() [routerRtpCapabilities:%o]',routerRtpCapabilities);// Temporal handler to get its capabilities.
_context20.prev=2;if(!this._loaded){_context20.next=5;break;}throw new errors_1.InvalidStateError('already loaded');case 5:// Clone given router RTP capabilities to not modify input data.
clonedRouterRtpCapabilities=utils.clone(routerRtpCapabilities);// This may throw.
ortc.validateRtpCapabilities(clonedRouterRtpCapabilities);handler=this._handlerFactory();_context20.next=10;return handler.getNativeRtpCapabilities();case 10:nativeRtpCapabilities=_context20.sent;logger.debug('load() | got native RTP capabilities:%o',nativeRtpCapabilities);// Clone obtained native RTP capabilities to not modify input data.
clonedNativeRtpCapabilities=utils.clone(nativeRtpCapabilities);// This may throw.
ortc.validateRtpCapabilities(clonedNativeRtpCapabilities);// Get extended RTP capabilities.
this._extendedRtpCapabilities=ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities,clonedRouterRtpCapabilities);logger.debug('load() | got extended RTP capabilities:%o',this._extendedRtpCapabilities);// Check whether we can produce audio/video.
this._canProduceByKind.audio=ortc.canSend('audio',this._extendedRtpCapabilities);this._canProduceByKind.video=ortc.canSend('video',this._extendedRtpCapabilities);// Generate our receiving RTP capabilities for receiving media.
this._recvRtpCapabilities=ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);// This may throw.
ortc.validateRtpCapabilities(this._recvRtpCapabilities);logger.debug('load() | got receiving RTP capabilities:%o',this._recvRtpCapabilities);// Generate our SCTP capabilities.
_context20.next=23;return handler.getNativeSctpCapabilities();case 23:this._sctpCapabilities=_context20.sent;logger.debug('load() | got native SCTP capabilities:%o',this._sctpCapabilities);// This may throw.
ortc.validateSctpCapabilities(this._sctpCapabilities);logger.debug('load() succeeded');this._loaded=true;handler.close();_context20.next=35;break;case 31:_context20.prev=31;_context20.t0=_context20["catch"](2);if(handler){handler.close();}throw _context20.t0;case 35:case"end":return _context20.stop();}},_callee20,this,[[2,31]]);}));function load(_x20){return _load.apply(this,arguments);}return load;}()/**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */)},{key:"canProduce",value:function canProduce(kind){if(!this._loaded){throw new errors_1.InvalidStateError('not loaded');}else if(kind!=='audio'&&kind!=='video'){throw new TypeError("invalid kind \"".concat(kind,"\""));}return this._canProduceByKind[kind];}/**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */},{key:"createSendTransport",value:function createSendTransport(_ref16){var id=_ref16.id,iceParameters=_ref16.iceParameters,iceCandidates=_ref16.iceCandidates,dtlsParameters=_ref16.dtlsParameters,sctpParameters=_ref16.sctpParameters,iceServers=_ref16.iceServers,iceTransportPolicy=_ref16.iceTransportPolicy,additionalSettings=_ref16.additionalSettings,proprietaryConstraints=_ref16.proprietaryConstraints,appData=_ref16.appData;logger.debug('createSendTransport()');return this.createTransport({direction:'send',id:id,iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,iceServers:iceServers,iceTransportPolicy:iceTransportPolicy,additionalSettings:additionalSettings,proprietaryConstraints:proprietaryConstraints,appData:appData});}/**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */},{key:"createRecvTransport",value:function createRecvTransport(_ref17){var id=_ref17.id,iceParameters=_ref17.iceParameters,iceCandidates=_ref17.iceCandidates,dtlsParameters=_ref17.dtlsParameters,sctpParameters=_ref17.sctpParameters,iceServers=_ref17.iceServers,iceTransportPolicy=_ref17.iceTransportPolicy,additionalSettings=_ref17.additionalSettings,proprietaryConstraints=_ref17.proprietaryConstraints,appData=_ref17.appData;logger.debug('createRecvTransport()');return this.createTransport({direction:'recv',id:id,iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,iceServers:iceServers,iceTransportPolicy:iceTransportPolicy,additionalSettings:additionalSettings,proprietaryConstraints:proprietaryConstraints,appData:appData});}},{key:"createTransport",value:function createTransport(_ref18){var direction=_ref18.direction,id=_ref18.id,iceParameters=_ref18.iceParameters,iceCandidates=_ref18.iceCandidates,dtlsParameters=_ref18.dtlsParameters,sctpParameters=_ref18.sctpParameters,iceServers=_ref18.iceServers,iceTransportPolicy=_ref18.iceTransportPolicy,additionalSettings=_ref18.additionalSettings,proprietaryConstraints=_ref18.proprietaryConstraints,appData=_ref18.appData;if(!this._loaded){throw new errors_1.InvalidStateError('not loaded');}else if(typeof id!=='string'){throw new TypeError('missing id');}else if(_typeof2(iceParameters)!=='object'){throw new TypeError('missing iceParameters');}else if(!Array.isArray(iceCandidates)){throw new TypeError('missing iceCandidates');}else if(_typeof2(dtlsParameters)!=='object'){throw new TypeError('missing dtlsParameters');}else if(sctpParameters&&_typeof2(sctpParameters)!=='object'){throw new TypeError('wrong sctpParameters');}else if(appData&&_typeof2(appData)!=='object'){throw new TypeError('if given, appData must be an object');}// Create a new Transport.
var transport=new Transport_1.Transport({direction:direction,id:id,iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,iceServers:iceServers,iceTransportPolicy:iceTransportPolicy,additionalSettings:additionalSettings,proprietaryConstraints:proprietaryConstraints,appData:appData,handlerFactory:this._handlerFactory,extendedRtpCapabilities:this._extendedRtpCapabilities,canProduceByKind:this._canProduceByKind});// Emit observer event.
this._observer.safeEmit('newtransport',transport);return transport;}}]);}();exports.Device=Device;/***/}),/***/"./node_modules/mediasoup-client/lib/Logger.js":(/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Logger.js ***!
  \*****************************************************//***/function _node_modules_mediasoupClient_lib_LoggerJs(__unused_webpack_module,exports,__nested_webpack_require_98744__){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});exports.Logger=void 0;var debug_1=__importDefault(__nested_webpack_require_98744__(/*! debug */"./node_modules/debug/src/browser.js"));var APP_NAME='mediasoup-client';var Logger=/*#__PURE__*/function(){function Logger(prefix){_classCallCheck2(this,Logger);if(prefix){this._debug=(0,debug_1["default"])("".concat(APP_NAME,":").concat(prefix));this._warn=(0,debug_1["default"])("".concat(APP_NAME,":WARN:").concat(prefix));this._error=(0,debug_1["default"])("".concat(APP_NAME,":ERROR:").concat(prefix));}else{this._debug=(0,debug_1["default"])(APP_NAME);this._warn=(0,debug_1["default"])("".concat(APP_NAME,":WARN"));this._error=(0,debug_1["default"])("".concat(APP_NAME,":ERROR"));}/* eslint-disable no-console */this._debug.log=console.info.bind(console);this._warn.log=console.warn.bind(console);this._error.log=console.error.bind(console);/* eslint-enable no-console */}return _createClass2(Logger,[{key:"debug",get:function get(){return this._debug;}},{key:"warn",get:function get(){return this._warn;}},{key:"error",get:function get(){return this._error;}}]);}();exports.Logger=Logger;/***/}),/***/"./node_modules/mediasoup-client/lib/Producer.js":(/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Producer.js ***!
  \*******************************************************//***/function _node_modules_mediasoupClient_lib_ProducerJs(__unused_webpack_module,exports,__nested_webpack_require_100346__){Object.defineProperty(exports,"__esModule",{value:true});exports.Producer=void 0;var Logger_1=__nested_webpack_require_100346__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_100346__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var errors_1=__nested_webpack_require_100346__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js");var logger=new Logger_1.Logger('Producer');var Producer=/*#__PURE__*/function(_enhancedEvents_1$Enh4){function Producer(_ref19){var _this10;var id=_ref19.id,localId=_ref19.localId,rtpSender=_ref19.rtpSender,track=_ref19.track,rtpParameters=_ref19.rtpParameters,stopTracks=_ref19.stopTracks,disableTrackOnPause=_ref19.disableTrackOnPause,zeroRtpOnPause=_ref19.zeroRtpOnPause,appData=_ref19.appData;_classCallCheck2(this,Producer);_this10=_callSuper(this,Producer);// Closed flag.
_this10._closed=false;// Observer instance.
_this10._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor()');_this10._id=id;_this10._localId=localId;_this10._rtpSender=rtpSender;_this10._track=track;_this10._kind=track.kind;_this10._rtpParameters=rtpParameters;_this10._paused=disableTrackOnPause?!track.enabled:false;_this10._maxSpatialLayer=undefined;_this10._stopTracks=stopTracks;_this10._disableTrackOnPause=disableTrackOnPause;_this10._zeroRtpOnPause=zeroRtpOnPause;_this10._appData=appData!==null&&appData!==void 0?appData:{};_this10.onTrackEnded=_this10.onTrackEnded.bind(_this10);// NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
// '@replacetrack' event here, so RTCRtpSender.track won't be null.
_this10.handleTrack();return _this10;}/**
     * Producer id.
     */_inherits(Producer,_enhancedEvents_1$Enh4);return _createClass2(Producer,[{key:"id",get:function get(){return this._id;}/**
     * Local id.
     */},{key:"localId",get:function get(){return this._localId;}/**
     * Whether the Producer is closed.
     */},{key:"closed",get:function get(){return this._closed;}/**
     * Media kind.
     */},{key:"kind",get:function get(){return this._kind;}/**
     * Associated RTCRtpSender.
     */},{key:"rtpSender",get:function get(){return this._rtpSender;}/**
     * The associated track.
     */},{key:"track",get:function get(){return this._track;}/**
     * RTP parameters.
     */},{key:"rtpParameters",get:function get(){return this._rtpParameters;}/**
     * Whether the Producer is paused.
     */},{key:"paused",get:function get(){return this._paused;}/**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */},{key:"maxSpatialLayer",get:function get(){return this._maxSpatialLayer;}/**
     * App custom data.
     */},{key:"appData",get:function get(){return this._appData;}/**
     * App custom data setter.
     */,set:function set(appData){this._appData=appData;}},{key:"observer",get:function get(){return this._observer;}/**
     * Closes the Producer.
     */},{key:"close",value:function close(){if(this._closed){return;}logger.debug('close()');this._closed=true;this.destroyTrack();this.emit('@close');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Transport was closed.
     */},{key:"transportClosed",value:function transportClosed(){if(this._closed){return;}logger.debug('transportClosed()');this._closed=true;this.destroyTrack();this.safeEmit('transportclose');// Emit observer event.
this._observer.safeEmit('close');}/**
     * Get associated RTCRtpSender stats.
     */},{key:"getStats",value:(function(){var _getStats2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee21(){var _this11=this;return _regeneratorRuntime2().wrap(function _callee21$(_context21){while(1)switch(_context21.prev=_context21.next){case 0:if(!this._closed){_context21.next=2;break;}throw new errors_1.InvalidStateError('closed');case 2:return _context21.abrupt("return",new Promise(function(resolve,reject){_this11.safeEmit('@getstats',resolve,reject);}));case 3:case"end":return _context21.stop();}},_callee21,this);}));function getStats(){return _getStats2.apply(this,arguments);}return getStats;}()/**
     * Pauses sending media.
     */)},{key:"pause",value:function pause(){var _this12=this;logger.debug('pause()');if(this._closed){logger.error('pause() | Producer closed');return;}this._paused=true;if(this._track&&this._disableTrackOnPause){this._track.enabled=false;}if(this._zeroRtpOnPause){new Promise(function(resolve,reject){_this12.safeEmit('@pause',resolve,reject);})["catch"](function(){});}// Emit observer event.
this._observer.safeEmit('pause');}/**
     * Resumes sending media.
     */},{key:"resume",value:function resume(){var _this13=this;logger.debug('resume()');if(this._closed){logger.error('resume() | Producer closed');return;}this._paused=false;if(this._track&&this._disableTrackOnPause){this._track.enabled=true;}if(this._zeroRtpOnPause){new Promise(function(resolve,reject){_this13.safeEmit('@resume',resolve,reject);})["catch"](function(){});}// Emit observer event.
this._observer.safeEmit('resume');}/**
     * Replaces the current track with a new one or null.
     */},{key:"replaceTrack",value:(function(){var _replaceTrack=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee22(_ref20){var _this14=this;var track;return _regeneratorRuntime2().wrap(function _callee22$(_context22){while(1)switch(_context22.prev=_context22.next){case 0:track=_ref20.track;logger.debug('replaceTrack() [track:%o]',track);if(!this._closed){_context22.next=7;break;}// This must be done here. Otherwise there is no chance to stop the given
// track.
if(track&&this._stopTracks){try{track.stop();}catch(error){}}throw new errors_1.InvalidStateError('closed');case 7:if(!(track&&track.readyState==='ended')){_context22.next=9;break;}throw new errors_1.InvalidStateError('track ended');case 9:if(!(track===this._track)){_context22.next=12;break;}logger.debug('replaceTrack() | same track, ignored');return _context22.abrupt("return");case 12:_context22.next=14;return new Promise(function(resolve,reject){_this14.safeEmit('@replacetrack',track,resolve,reject);});case 14:// Destroy the previous track.
this.destroyTrack();// Set the new track.
this._track=track;// If this Producer was paused/resumed and the state of the new
// track does not match, fix it.
if(this._track&&this._disableTrackOnPause){if(!this._paused){this._track.enabled=true;}else if(this._paused){this._track.enabled=false;}}// Handle the effective track.
this.handleTrack();case 18:case"end":return _context22.stop();}},_callee22,this);}));function replaceTrack(_x21){return _replaceTrack.apply(this,arguments);}return replaceTrack;}()/**
     * Sets the video max spatial layer to be sent.
     */)},{key:"setMaxSpatialLayer",value:(function(){var _setMaxSpatialLayer=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee23(spatialLayer){var _this15=this;return _regeneratorRuntime2().wrap(function _callee23$(_context23){while(1)switch(_context23.prev=_context23.next){case 0:if(!this._closed){_context23.next=4;break;}throw new errors_1.InvalidStateError('closed');case 4:if(!(this._kind!=='video')){_context23.next=8;break;}throw new errors_1.UnsupportedError('not a video Producer');case 8:if(!(typeof spatialLayer!=='number')){_context23.next=10;break;}throw new TypeError('invalid spatialLayer');case 10:if(!(spatialLayer===this._maxSpatialLayer)){_context23.next=12;break;}return _context23.abrupt("return");case 12:_context23.next=14;return new Promise(function(resolve,reject){_this15.safeEmit('@setmaxspatiallayer',spatialLayer,resolve,reject);})["catch"](function(){});case 14:this._maxSpatialLayer=spatialLayer;case 15:case"end":return _context23.stop();}},_callee23,this);}));function setMaxSpatialLayer(_x22){return _setMaxSpatialLayer.apply(this,arguments);}return setMaxSpatialLayer;}())},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee24(params){var _this16=this;return _regeneratorRuntime2().wrap(function _callee24$(_context24){while(1)switch(_context24.prev=_context24.next){case 0:if(!this._closed){_context24.next=4;break;}throw new errors_1.InvalidStateError('closed');case 4:if(!(_typeof2(params)!=='object')){_context24.next=6;break;}throw new TypeError('invalid params');case 6:_context24.next=8;return new Promise(function(resolve,reject){_this16.safeEmit('@setrtpencodingparameters',params,resolve,reject);});case 8:case"end":return _context24.stop();}},_callee24,this);}));function setRtpEncodingParameters(_x23){return _setRtpEncodingParameters.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"onTrackEnded",value:function onTrackEnded(){logger.debug('track "ended" event');this.safeEmit('trackended');// Emit observer event.
this._observer.safeEmit('trackended');}},{key:"handleTrack",value:function handleTrack(){if(!this._track){return;}this._track.addEventListener('ended',this.onTrackEnded);}},{key:"destroyTrack",value:function destroyTrack(){if(!this._track){return;}try{this._track.removeEventListener('ended',this.onTrackEnded);// Just stop the track unless the app set stopTracks: false.
if(this._stopTracks){this._track.stop();}}catch(error){}}}]);}(enhancedEvents_1.EnhancedEventEmitter);exports.Producer=Producer;/***/}),/***/"./node_modules/mediasoup-client/lib/RtpParameters.js":(/*!************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/RtpParameters.js ***!
  \************************************************************//***/function _node_modules_mediasoupClient_lib_RtpParametersJs(__unused_webpack_module,exports){/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */Object.defineProperty(exports,"__esModule",{value:true});/***/}),/***/"./node_modules/mediasoup-client/lib/SctpParameters.js":(/*!*************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/SctpParameters.js ***!
  \*************************************************************//***/function _node_modules_mediasoupClient_lib_SctpParametersJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});/***/}),/***/"./node_modules/mediasoup-client/lib/Transport.js":(/*!********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Transport.js ***!
  \********************************************************//***/function _node_modules_mediasoupClient_lib_TransportJs(__unused_webpack_module,exports,__nested_webpack_require_110974__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});exports.Transport=void 0;var awaitqueue_1=__nested_webpack_require_110974__(/*! awaitqueue */"./node_modules/awaitqueue/lib/index.js");var queue_microtask_1=__importDefault(__nested_webpack_require_110974__(/*! queue-microtask */"./node_modules/queue-microtask/index.js"));var Logger_1=__nested_webpack_require_110974__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEvents_1=__nested_webpack_require_110974__(/*! ./enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var errors_1=__nested_webpack_require_110974__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_110974__(/*! ./utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_110974__(/*! ./ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var Producer_1=__nested_webpack_require_110974__(/*! ./Producer */"./node_modules/mediasoup-client/lib/Producer.js");var Consumer_1=__nested_webpack_require_110974__(/*! ./Consumer */"./node_modules/mediasoup-client/lib/Consumer.js");var DataProducer_1=__nested_webpack_require_110974__(/*! ./DataProducer */"./node_modules/mediasoup-client/lib/DataProducer.js");var DataConsumer_1=__nested_webpack_require_110974__(/*! ./DataConsumer */"./node_modules/mediasoup-client/lib/DataConsumer.js");var logger=new Logger_1.Logger('Transport');var ConsumerCreationTask=/*#__PURE__*/_createClass2(function ConsumerCreationTask(consumerOptions){var _this17=this;_classCallCheck2(this,ConsumerCreationTask);this.consumerOptions=consumerOptions;this.promise=new Promise(function(resolve,reject){_this17.resolve=resolve;_this17.reject=reject;});});var Transport=/*#__PURE__*/function(_enhancedEvents_1$Enh5){function Transport(_ref21){var _utils$clone;var _this18;var direction=_ref21.direction,id=_ref21.id,iceParameters=_ref21.iceParameters,iceCandidates=_ref21.iceCandidates,dtlsParameters=_ref21.dtlsParameters,sctpParameters=_ref21.sctpParameters,iceServers=_ref21.iceServers,iceTransportPolicy=_ref21.iceTransportPolicy,additionalSettings=_ref21.additionalSettings,proprietaryConstraints=_ref21.proprietaryConstraints,appData=_ref21.appData,handlerFactory=_ref21.handlerFactory,extendedRtpCapabilities=_ref21.extendedRtpCapabilities,canProduceByKind=_ref21.canProduceByKind;_classCallCheck2(this,Transport);_this18=_callSuper(this,Transport);// Closed flag.
_this18._closed=false;// Transport ICE gathering state.
_this18._iceGatheringState='new';// Transport connection state.
_this18._connectionState='new';// Map of Producers indexed by id.
_this18._producers=new Map();// Map of Consumers indexed by id.
_this18._consumers=new Map();// Map of DataProducers indexed by id.
_this18._dataProducers=new Map();// Map of DataConsumers indexed by id.
_this18._dataConsumers=new Map();// Whether the Consumer for RTP probation has been created.
_this18._probatorConsumerCreated=false;// AwaitQueue instance to make async tasks happen sequentially.
_this18._awaitQueue=new awaitqueue_1.AwaitQueue();// Consumer creation tasks awaiting to be processed.
_this18._pendingConsumerTasks=[];// Consumer creation in progress flag.
_this18._consumerCreationInProgress=false;// Consumers pending to be paused.
_this18._pendingPauseConsumers=new Map();// Consumer pause in progress flag.
_this18._consumerPauseInProgress=false;// Consumers pending to be resumed.
_this18._pendingResumeConsumers=new Map();// Consumer resume in progress flag.
_this18._consumerResumeInProgress=false;// Consumers pending to be closed.
_this18._pendingCloseConsumers=new Map();// Consumer close in progress flag.
_this18._consumerCloseInProgress=false;// Observer instance.
_this18._observer=new enhancedEvents_1.EnhancedEventEmitter();logger.debug('constructor() [id:%s, direction:%s]',id,direction);_this18._id=id;_this18._direction=direction;_this18._extendedRtpCapabilities=extendedRtpCapabilities;_this18._canProduceByKind=canProduceByKind;_this18._maxSctpMessageSize=sctpParameters?sctpParameters.maxMessageSize:null;// Clone and sanitize additionalSettings.
var clonedAdditionalSettings=(_utils$clone=utils.clone(additionalSettings))!==null&&_utils$clone!==void 0?_utils$clone:{};delete clonedAdditionalSettings.iceServers;delete clonedAdditionalSettings.iceTransportPolicy;delete clonedAdditionalSettings.bundlePolicy;delete clonedAdditionalSettings.rtcpMuxPolicy;delete clonedAdditionalSettings.sdpSemantics;_this18._handler=handlerFactory();_this18._handler.run({direction:direction,iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,iceServers:iceServers,iceTransportPolicy:iceTransportPolicy,additionalSettings:clonedAdditionalSettings,proprietaryConstraints:proprietaryConstraints,extendedRtpCapabilities:extendedRtpCapabilities});_this18._appData=appData!==null&&appData!==void 0?appData:{};_this18.handleHandler();return _this18;}/**
     * Transport id.
     */_inherits(Transport,_enhancedEvents_1$Enh5);return _createClass2(Transport,[{key:"id",get:function get(){return this._id;}/**
     * Whether the Transport is closed.
     */},{key:"closed",get:function get(){return this._closed;}/**
     * Transport direction.
     */},{key:"direction",get:function get(){return this._direction;}/**
     * RTC handler instance.
     */},{key:"handler",get:function get(){return this._handler;}/**
     * ICE gathering state.
     */},{key:"iceGatheringState",get:function get(){return this._iceGatheringState;}/**
     * Connection state.
     */},{key:"connectionState",get:function get(){return this._connectionState;}/**
     * App custom data.
     */},{key:"appData",get:function get(){return this._appData;}/**
     * App custom data setter.
     */,set:function set(appData){this._appData=appData;}},{key:"observer",get:function get(){return this._observer;}/**
     * Close the Transport.
     */},{key:"close",value:function close(){if(this._closed){return;}logger.debug('close()');this._closed=true;// Stop the AwaitQueue.
this._awaitQueue.stop();// Close the handler.
this._handler.close();// Change connection state to 'closed' since the handler may not emit
// '@connectionstatechange' event.
this._connectionState='closed';// Close all Producers.
var _iterator3=_createForOfIteratorHelper(this._producers.values()),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var producer=_step3.value;producer.transportClosed();}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}this._producers.clear();// Close all Consumers.
var _iterator4=_createForOfIteratorHelper(this._consumers.values()),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var consumer=_step4.value;consumer.transportClosed();}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}this._consumers.clear();// Close all DataProducers.
var _iterator5=_createForOfIteratorHelper(this._dataProducers.values()),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var dataProducer=_step5.value;dataProducer.transportClosed();}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}this._dataProducers.clear();// Close all DataConsumers.
var _iterator6=_createForOfIteratorHelper(this._dataConsumers.values()),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var dataConsumer=_step6.value;dataConsumer.transportClosed();}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}this._dataConsumers.clear();// Emit observer event.
this._observer.safeEmit('close');}/**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */},{key:"getStats",value:(function(){var _getStats3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee25(){return _regeneratorRuntime2().wrap(function _callee25$(_context25){while(1)switch(_context25.prev=_context25.next){case 0:if(!this._closed){_context25.next=2;break;}throw new errors_1.InvalidStateError('closed');case 2:return _context25.abrupt("return",this._handler.getTransportStats());case 3:case"end":return _context25.stop();}},_callee25,this);}));function getStats(){return _getStats3.apply(this,arguments);}return getStats;}()/**
     * Restart ICE connection.
     */)},{key:"restartIce",value:(function(){var _restartIce=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee27(_ref22){var _this19=this;var iceParameters;return _regeneratorRuntime2().wrap(function _callee27$(_context27){while(1)switch(_context27.prev=_context27.next){case 0:iceParameters=_ref22.iceParameters;logger.debug('restartIce()');if(!this._closed){_context27.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(iceParameters){_context27.next=8;break;}throw new TypeError('missing iceParameters');case 8:return _context27.abrupt("return",this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee26(){return _regeneratorRuntime2().wrap(function _callee26$(_context26){while(1)switch(_context26.prev=_context26.next){case 0:_context26.next=2;return _this19._handler.restartIce(iceParameters);case 2:return _context26.abrupt("return",_context26.sent);case 3:case"end":return _context26.stop();}},_callee26);})),'transport.restartIce()'));case 9:case"end":return _context27.stop();}},_callee27,this);}));function restartIce(_x24){return _restartIce.apply(this,arguments);}return restartIce;}()/**
     * Update ICE servers.
     */)},{key:"updateIceServers",value:(function(){var _updateIceServers=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee29(){var _this20=this;var _ref24,iceServers,_args13=arguments;return _regeneratorRuntime2().wrap(function _callee29$(_context29){while(1)switch(_context29.prev=_context29.next){case 0:_ref24=_args13.length>0&&_args13[0]!==undefined?_args13[0]:{},iceServers=_ref24.iceServers;logger.debug('updateIceServers()');if(!this._closed){_context29.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(Array.isArray(iceServers)){_context29.next=8;break;}throw new TypeError('missing iceServers');case 8:return _context29.abrupt("return",this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee28(){return _regeneratorRuntime2().wrap(function _callee28$(_context28){while(1)switch(_context28.prev=_context28.next){case 0:return _context28.abrupt("return",_this20._handler.updateIceServers(iceServers));case 1:case"end":return _context28.stop();}},_callee28);})),'transport.updateIceServers()'));case 9:case"end":return _context29.stop();}},_callee29,this);}));function updateIceServers(){return _updateIceServers.apply(this,arguments);}return updateIceServers;}()/**
     * Create a Producer.
     */)},{key:"produce",value:(function(){var _produce=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee31(){var _this21=this;var _ref26,track,encodings,codecOptions,codec,_ref26$stopTracks,stopTracks,_ref26$disableTrackOn,disableTrackOnPause,_ref26$zeroRtpOnPause,zeroRtpOnPause,onRtpSender,_ref26$appData,appData,_args15=arguments;return _regeneratorRuntime2().wrap(function _callee31$(_context31){while(1)switch(_context31.prev=_context31.next){case 0:_ref26=_args15.length>0&&_args15[0]!==undefined?_args15[0]:{},track=_ref26.track,encodings=_ref26.encodings,codecOptions=_ref26.codecOptions,codec=_ref26.codec,_ref26$stopTracks=_ref26.stopTracks,stopTracks=_ref26$stopTracks===void 0?true:_ref26$stopTracks,_ref26$disableTrackOn=_ref26.disableTrackOnPause,disableTrackOnPause=_ref26$disableTrackOn===void 0?true:_ref26$disableTrackOn,_ref26$zeroRtpOnPause=_ref26.zeroRtpOnPause,zeroRtpOnPause=_ref26$zeroRtpOnPause===void 0?false:_ref26$zeroRtpOnPause,onRtpSender=_ref26.onRtpSender,_ref26$appData=_ref26.appData,appData=_ref26$appData===void 0?{}:_ref26$appData;logger.debug('produce() [track:%o]',track);if(!this._closed){_context31.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(track){_context31.next=10;break;}throw new TypeError('missing track');case 10:if(!(this._direction!=='send')){_context31.next=14;break;}throw new errors_1.UnsupportedError('not a sending Transport');case 14:if(this._canProduceByKind[track.kind]){_context31.next=18;break;}throw new errors_1.UnsupportedError("cannot produce ".concat(track.kind));case 18:if(!(track.readyState==='ended')){_context31.next=22;break;}throw new errors_1.InvalidStateError('track ended');case 22:if(!(this.listenerCount('connect')===0&&this._connectionState==='new')){_context31.next=26;break;}throw new TypeError('no "connect" listener set into this transport');case 26:if(!(this.listenerCount('produce')===0)){_context31.next=30;break;}throw new TypeError('no "produce" listener set into this transport');case 30:if(!(appData&&_typeof2(appData)!=='object')){_context31.next=32;break;}throw new TypeError('if given, appData must be an object');case 32:return _context31.abrupt("return",this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee30(){var normalizedEncodings,_yield$_this21$_handl,localId,rtpParameters,rtpSender,_yield$Promise,id,producer;return _regeneratorRuntime2().wrap(function _callee30$(_context30){while(1)switch(_context30.prev=_context30.next){case 0:if(!(encodings&&!Array.isArray(encodings))){_context30.next=4;break;}throw TypeError('encodings must be an array');case 4:if(encodings&&encodings.length===0){normalizedEncodings=undefined;}else if(encodings){normalizedEncodings=encodings.map(function(encoding){var normalizedEncoding={active:true};if(encoding.active===false){normalizedEncoding.active=false;}if(typeof encoding.dtx==='boolean'){normalizedEncoding.dtx=encoding.dtx;}if(typeof encoding.scalabilityMode==='string'){normalizedEncoding.scalabilityMode=encoding.scalabilityMode;}if(typeof encoding.scaleResolutionDownBy==='number'){normalizedEncoding.scaleResolutionDownBy=encoding.scaleResolutionDownBy;}if(typeof encoding.maxBitrate==='number'){normalizedEncoding.maxBitrate=encoding.maxBitrate;}if(typeof encoding.maxFramerate==='number'){normalizedEncoding.maxFramerate=encoding.maxFramerate;}if(typeof encoding.adaptivePtime==='boolean'){normalizedEncoding.adaptivePtime=encoding.adaptivePtime;}if(typeof encoding.priority==='string'){normalizedEncoding.priority=encoding.priority;}if(typeof encoding.networkPriority==='string'){normalizedEncoding.networkPriority=encoding.networkPriority;}return normalizedEncoding;});}case 5:_context30.next=7;return _this21._handler.send({track:track,encodings:normalizedEncodings,codecOptions:codecOptions,codec:codec,onRtpSender:onRtpSender});case 7:_yield$_this21$_handl=_context30.sent;localId=_yield$_this21$_handl.localId;rtpParameters=_yield$_this21$_handl.rtpParameters;rtpSender=_yield$_this21$_handl.rtpSender;_context30.prev=11;// This will fill rtpParameters's missing fields with default values.
ortc.validateRtpParameters(rtpParameters);_context30.next=15;return new Promise(function(resolve,reject){_this21.safeEmit('produce',{kind:track.kind,rtpParameters:rtpParameters,appData:appData},resolve,reject);});case 15:_yield$Promise=_context30.sent;id=_yield$Promise.id;producer=new Producer_1.Producer({id:id,localId:localId,rtpSender:rtpSender,track:track,rtpParameters:rtpParameters,stopTracks:stopTracks,disableTrackOnPause:disableTrackOnPause,zeroRtpOnPause:zeroRtpOnPause,appData:appData});_this21._producers.set(producer.id,producer);_this21.handleProducer(producer);// Emit observer event.
_this21._observer.safeEmit('newproducer',producer);return _context30.abrupt("return",producer);case 24:_context30.prev=24;_context30.t0=_context30["catch"](11);_this21._handler.stopSending(localId)["catch"](function(){});throw _context30.t0;case 28:case"end":return _context30.stop();}},_callee30,null,[[11,24]]);})),'transport.produce()')// This catch is needed to stop the given track if the command above
// failed due to closed Transport.
["catch"](function(error){if(stopTracks){try{track.stop();}catch(error2){}}throw error;}));case 33:case"end":return _context31.stop();}},_callee31,this);}));function produce(){return _produce.apply(this,arguments);}return produce;}()/**
     * Create a Consumer to consume a remote Producer.
     */)},{key:"consume",value:(function(){var _consume2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee32(_ref28){var _this22=this;var id,producerId,kind,rtpParameters,streamId,onRtpReceiver,_ref28$appData,appData,clonedRtpParameters,canConsume,consumerCreationTask;return _regeneratorRuntime2().wrap(function _callee32$(_context32){while(1)switch(_context32.prev=_context32.next){case 0:id=_ref28.id,producerId=_ref28.producerId,kind=_ref28.kind,rtpParameters=_ref28.rtpParameters,streamId=_ref28.streamId,onRtpReceiver=_ref28.onRtpReceiver,_ref28$appData=_ref28.appData,appData=_ref28$appData===void 0?{}:_ref28$appData;logger.debug('consume()');if(!this._closed){_context32.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(!(this._direction!=='recv')){_context32.next=10;break;}throw new errors_1.UnsupportedError('not a receiving Transport');case 10:if(!(typeof id!=='string')){_context32.next=14;break;}throw new TypeError('missing id');case 14:if(!(typeof producerId!=='string')){_context32.next=18;break;}throw new TypeError('missing producerId');case 18:if(!(kind!=='audio'&&kind!=='video')){_context32.next=22;break;}throw new TypeError("invalid kind '".concat(kind,"'"));case 22:if(!(this.listenerCount('connect')===0&&this._connectionState==='new')){_context32.next=26;break;}throw new TypeError('no "connect" listener set into this transport');case 26:if(!(appData&&_typeof2(appData)!=='object')){_context32.next=28;break;}throw new TypeError('if given, appData must be an object');case 28:// Clone given RTP parameters to not modify input data.
clonedRtpParameters=utils.clone(rtpParameters);// Ensure the device can consume it.
canConsume=ortc.canReceive(clonedRtpParameters,this._extendedRtpCapabilities);if(canConsume){_context32.next=32;break;}throw new errors_1.UnsupportedError('cannot consume this Producer');case 32:consumerCreationTask=new ConsumerCreationTask({id:id,producerId:producerId,kind:kind,rtpParameters:clonedRtpParameters,streamId:streamId,onRtpReceiver:onRtpReceiver,appData:appData});// Store the Consumer creation task.
this._pendingConsumerTasks.push(consumerCreationTask);// There is no Consumer creation in progress, create it now.
(0,queue_microtask_1["default"])(function(){if(_this22._closed){return;}if(_this22._consumerCreationInProgress===false){void _this22.createPendingConsumers();}});return _context32.abrupt("return",consumerCreationTask.promise);case 36:case"end":return _context32.stop();}},_callee32,this);}));function consume(_x25){return _consume2.apply(this,arguments);}return consume;}()/**
     * Create a DataProducer
     */)},{key:"produceData",value:(function(){var _produceData=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee34(){var _this23=this;var _ref29,_ref29$ordered,ordered,maxPacketLifeTime,maxRetransmits,_ref29$label,label,_ref29$protocol,protocol,_ref29$appData,appData,_args18=arguments;return _regeneratorRuntime2().wrap(function _callee34$(_context34){while(1)switch(_context34.prev=_context34.next){case 0:_ref29=_args18.length>0&&_args18[0]!==undefined?_args18[0]:{},_ref29$ordered=_ref29.ordered,ordered=_ref29$ordered===void 0?true:_ref29$ordered,maxPacketLifeTime=_ref29.maxPacketLifeTime,maxRetransmits=_ref29.maxRetransmits,_ref29$label=_ref29.label,label=_ref29$label===void 0?'':_ref29$label,_ref29$protocol=_ref29.protocol,protocol=_ref29$protocol===void 0?'':_ref29$protocol,_ref29$appData=_ref29.appData,appData=_ref29$appData===void 0?{}:_ref29$appData;logger.debug('produceData()');if(!this._closed){_context34.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(!(this._direction!=='send')){_context34.next=10;break;}throw new errors_1.UnsupportedError('not a sending Transport');case 10:if(this._maxSctpMessageSize){_context34.next=14;break;}throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');case 14:if(!(this.listenerCount('connect')===0&&this._connectionState==='new')){_context34.next=18;break;}throw new TypeError('no "connect" listener set into this transport');case 18:if(!(this.listenerCount('producedata')===0)){_context34.next=22;break;}throw new TypeError('no "producedata" listener set into this transport');case 22:if(!(appData&&_typeof2(appData)!=='object')){_context34.next=24;break;}throw new TypeError('if given, appData must be an object');case 24:if(maxPacketLifeTime||maxRetransmits){ordered=false;}// Enqueue command.
return _context34.abrupt("return",this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee33(){var _yield$_this23$_handl,dataChannel,sctpStreamParameters,_yield$Promise2,id,dataProducer;return _regeneratorRuntime2().wrap(function _callee33$(_context33){while(1)switch(_context33.prev=_context33.next){case 0:_context33.next=2;return _this23._handler.sendDataChannel({ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,label:label,protocol:protocol});case 2:_yield$_this23$_handl=_context33.sent;dataChannel=_yield$_this23$_handl.dataChannel;sctpStreamParameters=_yield$_this23$_handl.sctpStreamParameters;// This will fill sctpStreamParameters's missing fields with default values.
ortc.validateSctpStreamParameters(sctpStreamParameters);_context33.next=8;return new Promise(function(resolve,reject){_this23.safeEmit('producedata',{sctpStreamParameters:sctpStreamParameters,label:label,protocol:protocol,appData:appData},resolve,reject);});case 8:_yield$Promise2=_context33.sent;id=_yield$Promise2.id;dataProducer=new DataProducer_1.DataProducer({id:id,dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters,appData:appData});_this23._dataProducers.set(dataProducer.id,dataProducer);_this23.handleDataProducer(dataProducer);// Emit observer event.
_this23._observer.safeEmit('newdataproducer',dataProducer);return _context33.abrupt("return",dataProducer);case 15:case"end":return _context33.stop();}},_callee33);})),'transport.produceData()'));case 26:case"end":return _context34.stop();}},_callee34,this);}));function produceData(){return _produceData.apply(this,arguments);}return produceData;}()/**
     * Create a DataConsumer
     */)},{key:"consumeData",value:(function(){var _consumeData=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee36(_ref31){var _this24=this;var id,dataProducerId,sctpStreamParameters,_ref31$label,label,_ref31$protocol,protocol,_ref31$appData,appData,clonedSctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee36$(_context36){while(1)switch(_context36.prev=_context36.next){case 0:id=_ref31.id,dataProducerId=_ref31.dataProducerId,sctpStreamParameters=_ref31.sctpStreamParameters,_ref31$label=_ref31.label,label=_ref31$label===void 0?'':_ref31$label,_ref31$protocol=_ref31.protocol,protocol=_ref31$protocol===void 0?'':_ref31$protocol,_ref31$appData=_ref31.appData,appData=_ref31$appData===void 0?{}:_ref31$appData;logger.debug('consumeData()');if(!this._closed){_context36.next=6;break;}throw new errors_1.InvalidStateError('closed');case 6:if(!(this._direction!=='recv')){_context36.next=10;break;}throw new errors_1.UnsupportedError('not a receiving Transport');case 10:if(this._maxSctpMessageSize){_context36.next=14;break;}throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');case 14:if(!(typeof id!=='string')){_context36.next=18;break;}throw new TypeError('missing id');case 18:if(!(typeof dataProducerId!=='string')){_context36.next=22;break;}throw new TypeError('missing dataProducerId');case 22:if(!(this.listenerCount('connect')===0&&this._connectionState==='new')){_context36.next=26;break;}throw new TypeError('no "connect" listener set into this transport');case 26:if(!(appData&&_typeof2(appData)!=='object')){_context36.next=28;break;}throw new TypeError('if given, appData must be an object');case 28:// Clone given SCTP stream parameters to not modify input data.
clonedSctpStreamParameters=utils.clone(sctpStreamParameters);// This may throw.
ortc.validateSctpStreamParameters(clonedSctpStreamParameters);// Enqueue command.
return _context36.abrupt("return",this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee35(){var _yield$_this24$_handl,dataChannel,dataConsumer;return _regeneratorRuntime2().wrap(function _callee35$(_context35){while(1)switch(_context35.prev=_context35.next){case 0:_context35.next=2;return _this24._handler.receiveDataChannel({sctpStreamParameters:clonedSctpStreamParameters,label:label,protocol:protocol});case 2:_yield$_this24$_handl=_context35.sent;dataChannel=_yield$_this24$_handl.dataChannel;dataConsumer=new DataConsumer_1.DataConsumer({id:id,dataProducerId:dataProducerId,dataChannel:dataChannel,sctpStreamParameters:clonedSctpStreamParameters,appData:appData});_this24._dataConsumers.set(dataConsumer.id,dataConsumer);_this24.handleDataConsumer(dataConsumer);// Emit observer event.
_this24._observer.safeEmit('newdataconsumer',dataConsumer);return _context35.abrupt("return",dataConsumer);case 9:case"end":return _context35.stop();}},_callee35);})),'transport.consumeData()'));case 31:case"end":return _context36.stop();}},_callee36,this);}));function consumeData(_x26){return _consumeData.apply(this,arguments);}return consumeData;}()// This method is guaranteed to never throw.
)},{key:"createPendingConsumers",value:function(){var _createPendingConsumers=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee38(){var _this25=this;return _regeneratorRuntime2().wrap(function _callee38$(_context38){while(1)switch(_context38.prev=_context38.next){case 0:this._consumerCreationInProgress=true;this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee37(){var pendingConsumerTasks,videoConsumerForProbator,optionsList,_iterator7,_step7,_task2,_task2$consumerOption,_id,_kind,_rtpParameters,streamId,onRtpReceiver,results,idx,task,result,_task$consumerOptions,id,producerId,kind,rtpParameters,appData,localId,rtpReceiver,track,consumer,_iterator8,_step8,_task,probatorRtpParameters;return _regeneratorRuntime2().wrap(function _callee37$(_context37){while(1)switch(_context37.prev=_context37.next){case 0:if(!(_this25._pendingConsumerTasks.length===0)){_context37.next=3;break;}logger.debug('createPendingConsumers() | there is no Consumer to be created');return _context37.abrupt("return");case 3:pendingConsumerTasks=_toConsumableArray(_this25._pendingConsumerTasks);// Clear pending Consumer tasks.
_this25._pendingConsumerTasks=[];// Video Consumer in order to create the probator.
videoConsumerForProbator=undefined;// Fill options list.
optionsList=[];_iterator7=_createForOfIteratorHelper(pendingConsumerTasks);try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){_task2=_step7.value;_task2$consumerOption=_task2.consumerOptions,_id=_task2$consumerOption.id,_kind=_task2$consumerOption.kind,_rtpParameters=_task2$consumerOption.rtpParameters,streamId=_task2$consumerOption.streamId,onRtpReceiver=_task2$consumerOption.onRtpReceiver;optionsList.push({trackId:_id,kind:_kind,rtpParameters:_rtpParameters,streamId:streamId,onRtpReceiver:onRtpReceiver});}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}_context37.prev=9;_context37.next=12;return _this25._handler.receive(optionsList);case 12:results=_context37.sent;for(idx=0;idx<results.length;++idx){task=pendingConsumerTasks[idx];result=results[idx];_task$consumerOptions=task.consumerOptions,id=_task$consumerOptions.id,producerId=_task$consumerOptions.producerId,kind=_task$consumerOptions.kind,rtpParameters=_task$consumerOptions.rtpParameters,appData=_task$consumerOptions.appData;localId=result.localId,rtpReceiver=result.rtpReceiver,track=result.track;consumer=new Consumer_1.Consumer({id:id,localId:localId,producerId:producerId,rtpReceiver:rtpReceiver,track:track,rtpParameters:rtpParameters,appData:appData});_this25._consumers.set(consumer.id,consumer);_this25.handleConsumer(consumer);// If this is the first video Consumer and the Consumer for RTP probation
// has not yet been created, it's time to create it.
if(!_this25._probatorConsumerCreated&&!videoConsumerForProbator&&kind==='video'){videoConsumerForProbator=consumer;}// Emit observer event.
_this25._observer.safeEmit('newconsumer',consumer);task.resolve(consumer);}_context37.next=20;break;case 16:_context37.prev=16;_context37.t0=_context37["catch"](9);_iterator8=_createForOfIteratorHelper(pendingConsumerTasks);try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){_task=_step8.value;_task.reject(_context37.t0);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}case 20:if(!videoConsumerForProbator){_context37.next=32;break;}_context37.prev=21;probatorRtpParameters=ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);_context37.next=25;return _this25._handler.receive([{trackId:'probator',kind:'video',rtpParameters:probatorRtpParameters}]);case 25:logger.debug('createPendingConsumers() | Consumer for RTP probation created');_this25._probatorConsumerCreated=true;_context37.next=32;break;case 29:_context37.prev=29;_context37.t1=_context37["catch"](21);logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o',_context37.t1);case 32:case"end":return _context37.stop();}},_callee37,null,[[9,16],[21,29]]);})),'transport.createPendingConsumers()').then(function(){_this25._consumerCreationInProgress=false;// There are pending Consumer tasks, enqueue their creation.
if(_this25._pendingConsumerTasks.length>0){void _this25.createPendingConsumers();}})// NOTE: We only get here when the await queue is closed.
["catch"](function(){});case 2:case"end":return _context38.stop();}},_callee38,this);}));function createPendingConsumers(){return _createPendingConsumers.apply(this,arguments);}return createPendingConsumers;}()},{key:"pausePendingConsumers",value:function pausePendingConsumers(){var _this26=this;this._consumerPauseInProgress=true;this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee39(){var pendingPauseConsumers,localIds;return _regeneratorRuntime2().wrap(function _callee39$(_context39){while(1)switch(_context39.prev=_context39.next){case 0:if(!(_this26._pendingPauseConsumers.size===0)){_context39.next=3;break;}logger.debug('pausePendingConsumers() | there is no Consumer to be paused');return _context39.abrupt("return");case 3:pendingPauseConsumers=Array.from(_this26._pendingPauseConsumers.values());// Clear pending pause Consumer map.
_this26._pendingPauseConsumers.clear();_context39.prev=5;localIds=pendingPauseConsumers.map(function(consumer){return consumer.localId;});_context39.next=9;return _this26._handler.pauseReceiving(localIds);case 9:_context39.next=14;break;case 11:_context39.prev=11;_context39.t0=_context39["catch"](5);logger.error('pausePendingConsumers() | failed to pause Consumers:',_context39.t0);case 14:case"end":return _context39.stop();}},_callee39,null,[[5,11]]);})),'transport.pausePendingConsumers').then(function(){_this26._consumerPauseInProgress=false;// There are pending Consumers to be paused, do it.
if(_this26._pendingPauseConsumers.size>0){_this26.pausePendingConsumers();}})// NOTE: We only get here when the await queue is closed.
["catch"](function(){});}},{key:"resumePendingConsumers",value:function resumePendingConsumers(){var _this27=this;this._consumerResumeInProgress=true;this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee40(){var pendingResumeConsumers,localIds;return _regeneratorRuntime2().wrap(function _callee40$(_context40){while(1)switch(_context40.prev=_context40.next){case 0:if(!(_this27._pendingResumeConsumers.size===0)){_context40.next=3;break;}logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');return _context40.abrupt("return");case 3:pendingResumeConsumers=Array.from(_this27._pendingResumeConsumers.values());// Clear pending resume Consumer map.
_this27._pendingResumeConsumers.clear();_context40.prev=5;localIds=pendingResumeConsumers.map(function(consumer){return consumer.localId;});_context40.next=9;return _this27._handler.resumeReceiving(localIds);case 9:_context40.next=14;break;case 11:_context40.prev=11;_context40.t0=_context40["catch"](5);logger.error('resumePendingConsumers() | failed to resume Consumers:',_context40.t0);case 14:case"end":return _context40.stop();}},_callee40,null,[[5,11]]);})),'transport.resumePendingConsumers').then(function(){_this27._consumerResumeInProgress=false;// There are pending Consumer to be resumed, do it.
if(_this27._pendingResumeConsumers.size>0){_this27.resumePendingConsumers();}})// NOTE: We only get here when the await queue is closed.
["catch"](function(){});}},{key:"closePendingConsumers",value:function closePendingConsumers(){var _this28=this;this._consumerCloseInProgress=true;this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee41(){var pendingCloseConsumers;return _regeneratorRuntime2().wrap(function _callee41$(_context41){while(1)switch(_context41.prev=_context41.next){case 0:if(!(_this28._pendingCloseConsumers.size===0)){_context41.next=3;break;}logger.debug('closePendingConsumers() | there is no Consumer to be closed');return _context41.abrupt("return");case 3:pendingCloseConsumers=Array.from(_this28._pendingCloseConsumers.values());// Clear pending close Consumer map.
_this28._pendingCloseConsumers.clear();_context41.prev=5;_context41.next=8;return _this28._handler.stopReceiving(pendingCloseConsumers.map(function(consumer){return consumer.localId;}));case 8:_context41.next=13;break;case 10:_context41.prev=10;_context41.t0=_context41["catch"](5);logger.error('closePendingConsumers() | failed to close Consumers:',_context41.t0);case 13:case"end":return _context41.stop();}},_callee41,null,[[5,10]]);})),'transport.closePendingConsumers').then(function(){_this28._consumerCloseInProgress=false;// There are pending Consumer to be resumed, do it.
if(_this28._pendingCloseConsumers.size>0){_this28.closePendingConsumers();}})// NOTE: We only get here when the await queue is closed.
["catch"](function(){});}},{key:"handleHandler",value:function handleHandler(){var _this29=this;var handler=this._handler;handler.on('@connect',function(_ref37,callback,errback){var dtlsParameters=_ref37.dtlsParameters;if(_this29._closed){errback(new errors_1.InvalidStateError('closed'));return;}_this29.safeEmit('connect',{dtlsParameters:dtlsParameters},callback,errback);});handler.on('@icegatheringstatechange',function(iceGatheringState){if(iceGatheringState===_this29._iceGatheringState){return;}logger.debug('ICE gathering state changed to %s',iceGatheringState);_this29._iceGatheringState=iceGatheringState;if(!_this29._closed){_this29.safeEmit('icegatheringstatechange',iceGatheringState);}});handler.on('@connectionstatechange',function(connectionState){if(connectionState===_this29._connectionState){return;}logger.debug('connection state changed to %s',connectionState);_this29._connectionState=connectionState;if(!_this29._closed){_this29.safeEmit('connectionstatechange',connectionState);}});}},{key:"handleProducer",value:function handleProducer(producer){var _this30=this;producer.on('@close',function(){_this30._producers["delete"](producer.id);if(_this30._closed){return;}_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee42(){return _regeneratorRuntime2().wrap(function _callee42$(_context42){while(1)switch(_context42.prev=_context42.next){case 0:_context42.next=2;return _this30._handler.stopSending(producer.localId);case 2:return _context42.abrupt("return",_context42.sent);case 3:case"end":return _context42.stop();}},_callee42);})),'producer @close event')["catch"](function(error){return logger.warn('producer.close() failed:%o',error);});});producer.on('@pause',function(callback,errback){_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee43(){return _regeneratorRuntime2().wrap(function _callee43$(_context43){while(1)switch(_context43.prev=_context43.next){case 0:_context43.next=2;return _this30._handler.pauseSending(producer.localId);case 2:return _context43.abrupt("return",_context43.sent);case 3:case"end":return _context43.stop();}},_callee43);})),'producer @pause event').then(callback)["catch"](errback);});producer.on('@resume',function(callback,errback){_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee44(){return _regeneratorRuntime2().wrap(function _callee44$(_context44){while(1)switch(_context44.prev=_context44.next){case 0:_context44.next=2;return _this30._handler.resumeSending(producer.localId);case 2:return _context44.abrupt("return",_context44.sent);case 3:case"end":return _context44.stop();}},_callee44);})),'producer @resume event').then(callback)["catch"](errback);});producer.on('@replacetrack',function(track,callback,errback){_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee45(){return _regeneratorRuntime2().wrap(function _callee45$(_context45){while(1)switch(_context45.prev=_context45.next){case 0:_context45.next=2;return _this30._handler.replaceTrack(producer.localId,track);case 2:return _context45.abrupt("return",_context45.sent);case 3:case"end":return _context45.stop();}},_callee45);})),'producer @replacetrack event').then(callback)["catch"](errback);});producer.on('@setmaxspatiallayer',function(spatialLayer,callback,errback){_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee46(){return _regeneratorRuntime2().wrap(function _callee46$(_context46){while(1)switch(_context46.prev=_context46.next){case 0:_context46.next=2;return _this30._handler.setMaxSpatialLayer(producer.localId,spatialLayer);case 2:return _context46.abrupt("return",_context46.sent);case 3:case"end":return _context46.stop();}},_callee46);})),'producer @setmaxspatiallayer event').then(callback)["catch"](errback);});producer.on('@setrtpencodingparameters',function(params,callback,errback){_this30._awaitQueue.push(/*#__PURE__*/_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee47(){return _regeneratorRuntime2().wrap(function _callee47$(_context47){while(1)switch(_context47.prev=_context47.next){case 0:_context47.next=2;return _this30._handler.setRtpEncodingParameters(producer.localId,params);case 2:return _context47.abrupt("return",_context47.sent);case 3:case"end":return _context47.stop();}},_callee47);})),'producer @setrtpencodingparameters event').then(callback)["catch"](errback);});producer.on('@getstats',function(callback,errback){if(_this30._closed){return errback(new errors_1.InvalidStateError('closed'));}_this30._handler.getSenderStats(producer.localId).then(callback)["catch"](errback);});}},{key:"handleConsumer",value:function handleConsumer(consumer){var _this31=this;consumer.on('@close',function(){_this31._consumers["delete"](consumer.id);_this31._pendingPauseConsumers["delete"](consumer.id);_this31._pendingResumeConsumers["delete"](consumer.id);if(_this31._closed){return;}// Store the Consumer into the close list.
_this31._pendingCloseConsumers.set(consumer.id,consumer);// There is no Consumer close in progress, do it now.
if(_this31._consumerCloseInProgress===false){_this31.closePendingConsumers();}});consumer.on('@pause',function(){// If Consumer is pending to be resumed, remove from pending resume list.
if(_this31._pendingResumeConsumers.has(consumer.id)){_this31._pendingResumeConsumers["delete"](consumer.id);}// Store the Consumer into the pending list.
_this31._pendingPauseConsumers.set(consumer.id,consumer);// There is no Consumer pause in progress, do it now.
(0,queue_microtask_1["default"])(function(){if(_this31._closed){return;}if(_this31._consumerPauseInProgress===false){_this31.pausePendingConsumers();}});});consumer.on('@resume',function(){// If Consumer is pending to be paused, remove from pending pause list.
if(_this31._pendingPauseConsumers.has(consumer.id)){_this31._pendingPauseConsumers["delete"](consumer.id);}// Store the Consumer into the pending list.
_this31._pendingResumeConsumers.set(consumer.id,consumer);// There is no Consumer resume in progress, do it now.
(0,queue_microtask_1["default"])(function(){if(_this31._closed){return;}if(_this31._consumerResumeInProgress===false){_this31.resumePendingConsumers();}});});consumer.on('@getstats',function(callback,errback){if(_this31._closed){return errback(new errors_1.InvalidStateError('closed'));}_this31._handler.getReceiverStats(consumer.localId).then(callback)["catch"](errback);});}},{key:"handleDataProducer",value:function handleDataProducer(dataProducer){var _this32=this;dataProducer.on('@close',function(){_this32._dataProducers["delete"](dataProducer.id);});}},{key:"handleDataConsumer",value:function handleDataConsumer(dataConsumer){var _this33=this;dataConsumer.on('@close',function(){_this33._dataConsumers["delete"](dataConsumer.id);});}}]);}(enhancedEvents_1.EnhancedEventEmitter);exports.Transport=Transport;/***/}),/***/"./node_modules/mediasoup-client/lib/enhancedEvents.js":(/*!*************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/enhancedEvents.js ***!
  \*************************************************************//***/function _node_modules_mediasoupClient_lib_enhancedEventsJs(__unused_webpack_module,exports,__nested_webpack_require_153671__){Object.defineProperty(exports,"__esModule",{value:true});exports.EnhancedEventEmitter=void 0;var npm_events_package_1=__nested_webpack_require_153671__(/*! npm-events-package */"./node_modules/npm-events-package/events.js");var Logger_1=__nested_webpack_require_153671__(/*! ./Logger */"./node_modules/mediasoup-client/lib/Logger.js");var enhancedEventEmitterLogger=new Logger_1.Logger('EnhancedEventEmitter');var EnhancedEventEmitter=/*#__PURE__*/function(_npm_events_package_){function EnhancedEventEmitter(){var _this34;_classCallCheck2(this,EnhancedEventEmitter);_this34=_callSuper(this,EnhancedEventEmitter);_this34.setMaxListeners(Infinity);return _this34;}_inherits(EnhancedEventEmitter,_npm_events_package_);return _createClass2(EnhancedEventEmitter,[{key:"emit",value:function emit(eventName){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}return _superPropGet(EnhancedEventEmitter,"emit",this,3)([eventName].concat(args));}/**
     * Special addition to the EventEmitter API.
     */},{key:"safeEmit",value:function safeEmit(eventName){try{for(var _len3=arguments.length,args=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){args[_key3-1]=arguments[_key3];}return _superPropGet(EnhancedEventEmitter,"emit",this,3)([eventName].concat(args));}catch(error){enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o',eventName,error);try{_superPropGet(EnhancedEventEmitter,"emit",this,3)(['listenererror',eventName,error]);}catch(error2){// Ignore it.
}return Boolean(_superPropGet(EnhancedEventEmitter,"listenerCount",this,3)([eventName]));}}},{key:"on",value:function on(eventName,listener){_superPropGet(EnhancedEventEmitter,"on",this,3)([eventName,listener]);return this;}},{key:"off",value:function off(eventName,listener){_superPropGet(EnhancedEventEmitter,"off",this,3)([eventName,listener]);return this;}},{key:"addListener",value:function addListener(eventName,listener){_superPropGet(EnhancedEventEmitter,"on",this,3)([eventName,listener]);return this;}},{key:"prependListener",value:function prependListener(eventName,listener){_superPropGet(EnhancedEventEmitter,"prependListener",this,3)([eventName,listener]);return this;}},{key:"once",value:function once(eventName,listener){_superPropGet(EnhancedEventEmitter,"once",this,3)([eventName,listener]);return this;}},{key:"prependOnceListener",value:function prependOnceListener(eventName,listener){_superPropGet(EnhancedEventEmitter,"prependOnceListener",this,3)([eventName,listener]);return this;}},{key:"removeListener",value:function removeListener(eventName,listener){_superPropGet(EnhancedEventEmitter,"off",this,3)([eventName,listener]);return this;}},{key:"removeAllListeners",value:function removeAllListeners(eventName){_superPropGet(EnhancedEventEmitter,"removeAllListeners",this,3)([eventName]);return this;}},{key:"listenerCount",value:function listenerCount(eventName){return _superPropGet(EnhancedEventEmitter,"listenerCount",this,3)([eventName]);}},{key:"listeners",value:function listeners(eventName){return _superPropGet(EnhancedEventEmitter,"listeners",this,3)([eventName]);}},{key:"rawListeners",value:function rawListeners(eventName){return _superPropGet(EnhancedEventEmitter,"rawListeners",this,3)([eventName]);}}]);}(npm_events_package_1.EventEmitter);exports.EnhancedEventEmitter=EnhancedEventEmitter;/***/}),/***/"./node_modules/mediasoup-client/lib/errors.js":(/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/errors.js ***!
  \*****************************************************//***/function _node_modules_mediasoupClient_lib_errorsJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.InvalidStateError=exports.UnsupportedError=void 0;/**
 * Error indicating not support for something.
 */var UnsupportedError=/*#__PURE__*/function(_Error3){function UnsupportedError(message){var _this35;_classCallCheck2(this,UnsupportedError);_this35=_callSuper(this,UnsupportedError,[message]);_this35.name='UnsupportedError';if(Error.hasOwnProperty('captureStackTrace')){Error.captureStackTrace(_this35,UnsupportedError);}else{_this35.stack=new Error(message).stack;}return _this35;}_inherits(UnsupportedError,_Error3);return _createClass2(UnsupportedError);}(/*#__PURE__*/_wrapNativeSuper(Error));exports.UnsupportedError=UnsupportedError;/**
 * Error produced when calling a method in an invalid state.
 */var InvalidStateError=/*#__PURE__*/function(_Error4){function InvalidStateError(message){var _this36;_classCallCheck2(this,InvalidStateError);_this36=_callSuper(this,InvalidStateError,[message]);_this36.name='InvalidStateError';if(Error.hasOwnProperty('captureStackTrace')){// Just in V8.
Error.captureStackTrace(_this36,InvalidStateError);}else{_this36.stack=new Error(message).stack;}return _this36;}_inherits(InvalidStateError,_Error4);return _createClass2(InvalidStateError);}(/*#__PURE__*/_wrapNativeSuper(Error));exports.InvalidStateError=InvalidStateError;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Chrome111.js":(/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome111.js ***!
  \*****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Chrome111Js(__unused_webpack_module,exports,__nested_webpack_require_159130__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Chrome111=void 0;var sdpTransform=__importStar(__nested_webpack_require_159130__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_159130__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_159130__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_159130__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_159130__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_159130__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var ortcUtils=__importStar(__nested_webpack_require_159130__(/*! ./ortc/utils */"./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));var errors_1=__nested_webpack_require_159130__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var HandlerInterface_1=__nested_webpack_require_159130__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_159130__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_159130__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Chrome111');var NAME='Chrome111';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Chrome111=/*#__PURE__*/function(_HandlerInterface_1$H){function Chrome111(){var _this37;_classCallCheck2(this,Chrome111);_this37=_callSuper(this,Chrome111);// Closed flag.
_this37._closed=false;// Map of RTCTransceivers indexed by MID.
_this37._mapMidTransceiver=new Map();// Local stream for sending.
_this37._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this37._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this37._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this37._transportReady=false;return _this37;}_inherits(Chrome111,_HandlerInterface_1$H);return _createClass2(Chrome111,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee48(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee48$(_context48){while(1)switch(_context48.prev=_context48.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'});_context48.prev=2;pc.addTransceiver('audio');pc.addTransceiver('video');_context48.next=7;return pc.createOffer();case 7:offer=_context48.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});// libwebrtc supports NACK for OPUS but doesn't announce it.
ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);return _context48.abrupt("return",nativeRtpCapabilities);case 15:_context48.prev=15;_context48.t0=_context48["catch"](2);try{pc.close();}catch(error2){}throw _context48.t0;case 19:case"end":return _context48.stop();}},_callee48,null,[[2,15]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee49(){return _regeneratorRuntime2().wrap(function _callee49$(_context49){while(1)switch(_context49.prev=_context49.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context49.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context49.stop();}},_callee49);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref44){var _this38=this;var direction=_ref44.direction,iceParameters=_ref44.iceParameters,iceCandidates=_ref44.iceCandidates,dtlsParameters=_ref44.dtlsParameters,sctpParameters=_ref44.sctpParameters,iceServers=_ref44.iceServers,iceTransportPolicy=_ref44.iceTransportPolicy,additionalSettings=_ref44.additionalSettings,proprietaryConstraints=_ref44.proprietaryConstraints,extendedRtpCapabilities=_ref44.extendedRtpCapabilities;this.assertNotClosed();logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this38.emit('@icegatheringstatechange',_this38._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this38.emit('@connectionstatechange',_this38._pc.connectionState);});}else{logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');this._pc.addEventListener('iceconnectionstatechange',function(){switch(_this38._pc.iceConnectionState){case'checking':{_this38.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this38.emit('@connectionstatechange','connected');break;}case'failed':{_this38.emit('@connectionstatechange','failed');break;}case'disconnected':{_this38.emit('@connectionstatechange','disconnected');break;}case'closed':{_this38.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee50(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee50$(_context50){while(1)switch(_context50.prev=_context50.next){case 0:this.assertNotClosed();logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 5:case"end":return _context50.stop();}},_callee50,this);}));function updateIceServers(_x27){return _updateIceServers2.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee51(iceParameters){var offer,answer,_offer,_answer;return _regeneratorRuntime2().wrap(function _callee51$(_context51){while(1)switch(_context51.prev=_context51.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context51.next=5;break;}return _context51.abrupt("return");case 5:if(!(this._direction==='send')){_context51.next=18;break;}_context51.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context51.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context51.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context51.next=16;return this._pc.setRemoteDescription(answer);case 16:_context51.next=28;break;case 18:_offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer);_context51.next=22;return this._pc.setRemoteDescription(_offer);case 22:_context51.next=24;return this._pc.createAnswer();case 24:_answer=_context51.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer);_context51.next=28;return this._pc.setLocalDescription(_answer);case 28:case"end":return _context51.stop();}},_callee51,this);}));function restartIce(_x28){return _restartIce2.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee52(){return _regeneratorRuntime2().wrap(function _callee52$(_context52){while(1)switch(_context52.prev=_context52.next){case 0:this.assertNotClosed();return _context52.abrupt("return",this._pc.getStats());case 2:case"end":return _context52.stop();}},_callee52,this);}));function getTransportStats(){return _getTransportStats.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee53(_ref45){var track,encodings,codecOptions,codec,onRtpSender,maxTemporalLayers,_iterator9,_step9,encoding,temporalLayers,sendingRtpParameters,sendingRemoteRtpParameters,mediaSectionIdx,transceiver,offer,localSdpObject,_this$_forcedLocalDtl,localId,offerMediaObject,newEncodings,answer;return _regeneratorRuntime2().wrap(function _callee53$(_context53){while(1)switch(_context53.prev=_context53.next){case 0:track=_ref45.track,encodings=_ref45.encodings,codecOptions=_ref45.codecOptions,codec=_ref45.codec,onRtpSender=_ref45.onRtpSender;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(encodings&&encodings.length>1){// Set rid and verify scalabilityMode in each encoding.
// NOTE: Even if WebRTC allows different scalabilityMode (different number
// of temporal layers) per simulcast stream, we need that those are the
// same in all them, so let's pick up the highest value.
// NOTE: If scalabilityMode is not given, Chrome will use L1T3.
maxTemporalLayers=1;_iterator9=_createForOfIteratorHelper(encodings);try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){encoding=_step9.value;temporalLayers=encoding.scalabilityMode?(0,scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers:3;if(temporalLayers>maxTemporalLayers){maxTemporalLayers=temporalLayers;}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}encodings.forEach(function(encoding,idx){encoding.rid="r".concat(idx);encoding.scalabilityMode="L1T".concat(maxTemporalLayers);});}sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);mediaSectionIdx=this._remoteSdp.getNextMediaSectionIdx();transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream],sendEncodings:encodings});if(onRtpSender){onRtpSender(transceiver.sender);}_context53.next=14;return this._pc.createOffer();case 14:offer=_context53.sent;localSdpObject=sdpTransform.parse(offer.sdp);if(this._transportReady){_context53.next=19;break;}_context53.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl!==void 0?_this$_forcedLocalDtl:'client',localSdpObject:localSdpObject});case 19:logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context53.next=22;return this._pc.setLocalDescription(offer);case 22:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings by parsing the SDP offer if no encodings are given.
if(!encodings){sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});}// Set RTP encodings by parsing the SDP offer and complete them with given
// one if just a single encoding has been given.
else if(encodings.length===1){newEncodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});Object.assign(newEncodings[0],encodings[0]);sendingRtpParameters.encodings=newEncodings;}// Otherwise if more than 1 encoding are given use them verbatim.
else{sendingRtpParameters.encodings=encodings;}this._remoteSdp.send({offerMediaObject:offerMediaObject,reuseMid:mediaSectionIdx.reuseMid,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions,extmapAllowMixed:true});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context53.next=33;return this._pc.setRemoteDescription(answer);case 33:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context53.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 35:case"end":return _context53.stop();}},_callee53,this);}));function send(_x29){return _send.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee54(localId){var transceiver,mediaSectionClosed,offer,answer;return _regeneratorRuntime2().wrap(function _callee54$(_context54){while(1)switch(_context54.prev=_context54.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);if(!this._closed){_context54.next=4;break;}return _context54.abrupt("return");case 4:transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context54.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:void transceiver.sender.replaceTrack(null);this._pc.removeTrack(transceiver.sender);mediaSectionClosed=this._remoteSdp.closeMediaSection(transceiver.mid);if(mediaSectionClosed){try{transceiver.stop();}catch(error){}}_context54.next=13;return this._pc.createOffer();case 13:offer=_context54.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context54.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context54.next=21;return this._pc.setRemoteDescription(answer);case 21:this._mapMidTransceiver["delete"](localId);case 22:case"end":return _context54.stop();}},_callee54,this);}));function stopSending(_x30){return _stopSending.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee55(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee55$(_context55){while(1)switch(_context55.prev=_context55.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context55.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context55.next=10;return this._pc.createOffer();case 10:offer=_context55.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context55.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context55.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context55.stop();}},_callee55,this);}));function pauseSending(_x31){return _pauseSending.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee56(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee56$(_context56){while(1)switch(_context56.prev=_context56.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);this._remoteSdp.resumeSendingMediaSection(localId);if(transceiver){_context56.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:transceiver.direction='sendonly';_context56.next=10;return this._pc.createOffer();case 10:offer=_context56.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context56.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context56.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context56.stop();}},_callee56,this);}));function resumeSending(_x32){return _resumeSending.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee57(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee57$(_context57){while(1)switch(_context57.prev=_context57.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context57.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context57.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context57.stop();}},_callee57,this);}));function replaceTrack(_x33,_x34){return _replaceTrack2.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee58(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee58$(_context58){while(1)switch(_context58.prev=_context58.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context58.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context58.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context58.next=13;return this._pc.createOffer();case 13:offer=_context58.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context58.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context58.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context58.stop();}},_callee58,this);}));function setMaxSpatialLayer(_x35,_x36){return _setMaxSpatialLayer2.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee59(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee59$(_context59){while(1)switch(_context59.prev=_context59.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context59.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context59.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context59.next=13;return this._pc.createOffer();case 13:offer=_context59.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context59.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context59.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context59.stop();}},_callee59,this);}));function setRtpEncodingParameters(_x37,_x38){return _setRtpEncodingParameters2.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee60(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee60$(_context60){while(1)switch(_context60.prev=_context60.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context60.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context60.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context60.stop();}},_callee60,this);}));function getSenderStats(_x39){return _getSenderStats.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee61(_ref46){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl2,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee61$(_context61){while(1)switch(_context61.prev=_context61.next){case 0:ordered=_ref46.ordered,maxPacketLifeTime=_ref46.maxPacketLifeTime,maxRetransmits=_ref46.maxRetransmits,label=_ref46.label,protocol=_ref46.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context61.next=25;break;}_context61.next=10;return this._pc.createOffer();case 10:offer=_context61.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context61.next=16;break;}_context61.next=16;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl2=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl2!==void 0?_this$_forcedLocalDtl2:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context61.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context61.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context61.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context61.stop();}},_callee61,this);}));function sendDataChannel(_x40){return _sendDataChannel.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee62(optionsList){var _this39=this;var results,mapLocalId,_iterator10,_step10,_rtpParameters$mid,options,trackId,kind,rtpParameters,streamId,localId,offer,_iterator11,_step11,_loop,answer,localSdpObject,_iterator12,_step12,_loop2,_this$_forcedLocalDtl3,_iterator13,_step13,_loop3;return _regeneratorRuntime2().wrap(function _callee62$(_context65){while(1)switch(_context65.prev=_context65.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator10=_createForOfIteratorHelper(optionsList);try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){options=_step10.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid=rtpParameters.mid)!==null&&_rtpParameters$mid!==void 0?_rtpParameters$mid:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context65.next=10;return this._pc.setRemoteDescription(offer);case 10:_iterator11=_createForOfIteratorHelper(optionsList);_context65.prev=11;_loop=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop(){var options,trackId,onRtpReceiver,_localId,transceiver;return _regeneratorRuntime2().wrap(function _loop$(_context62){while(1)switch(_context62.prev=_context62.next){case 0:options=_step11.value;trackId=options.trackId,onRtpReceiver=options.onRtpReceiver;if(!onRtpReceiver){_context62.next=8;break;}_localId=mapLocalId.get(trackId);transceiver=_this39._pc.getTransceivers().find(function(t){return t.mid===_localId;});if(transceiver){_context62.next=7;break;}throw new Error('transceiver not found');case 7:onRtpReceiver(transceiver.receiver);case 8:case"end":return _context62.stop();}},_loop);});_iterator11.s();case 14:if((_step11=_iterator11.n()).done){_context65.next=18;break;}return _context65.delegateYield(_loop(),"t0",16);case 16:_context65.next=14;break;case 18:_context65.next=23;break;case 20:_context65.prev=20;_context65.t1=_context65["catch"](11);_iterator11.e(_context65.t1);case 23:_context65.prev=23;_iterator11.f();return _context65.finish(23);case 26:_context65.next=28;return this._pc.createAnswer();case 28:answer=_context65.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator12=_createForOfIteratorHelper(optionsList);_context65.prev=31;_loop2=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop2(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop2$(_context63){while(1)switch(_context63.prev=_context63.next){case 0:options=_step12.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context63.stop();}},_loop2);});_iterator12.s();case 34:if((_step12=_iterator12.n()).done){_context65.next=38;break;}return _context65.delegateYield(_loop2(),"t2",36);case 36:_context65.next=34;break;case 38:_context65.next=43;break;case 40:_context65.prev=40;_context65.t3=_context65["catch"](31);_iterator12.e(_context65.t3);case 43:_context65.prev=43;_iterator12.f();return _context65.finish(43);case 46:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context65.next=50;break;}_context65.next=50;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl3=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl3!==void 0?_this$_forcedLocalDtl3:'client',localSdpObject:localSdpObject});case 50:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context65.next=53;return this._pc.setLocalDescription(answer);case 53:_iterator13=_createForOfIteratorHelper(optionsList);_context65.prev=54;_loop3=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop3(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop3$(_context64){while(1)switch(_context64.prev=_context64.next){case 0:options=_step13.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this39._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context64.next=8;break;}throw new Error('new RTCRtpTransceiver not found');case 8:// Store in the map.
_this39._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 10:case"end":return _context64.stop();}},_loop3);});_iterator13.s();case 57:if((_step13=_iterator13.n()).done){_context65.next=61;break;}return _context65.delegateYield(_loop3(),"t4",59);case 59:_context65.next=57;break;case 61:_context65.next=66;break;case 63:_context65.prev=63;_context65.t5=_context65["catch"](54);_iterator13.e(_context65.t5);case 66:_context65.prev=66;_iterator13.f();return _context65.finish(66);case 69:return _context65.abrupt("return",results);case 70:case"end":return _context65.stop();}},_callee62,this,[[11,20,23,26],[31,40,43,46],[54,63,66,69]]);}));function receive(_x41){return _receive.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee63(localIds){var _iterator14,_step14,localId,transceiver,offer,answer,_iterator15,_step15,_localId2;return _regeneratorRuntime2().wrap(function _callee63$(_context66){while(1)switch(_context66.prev=_context66.next){case 0:this.assertRecvDirection();if(!this._closed){_context66.next=3;break;}return _context66.abrupt("return");case 3:_iterator14=_createForOfIteratorHelper(localIds);_context66.prev=4;_iterator14.s();case 6:if((_step14=_iterator14.n()).done){_context66.next=15;break;}localId=_step14.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context66.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context66.next=6;break;case 15:_context66.next=20;break;case 17:_context66.prev=17;_context66.t0=_context66["catch"](4);_iterator14.e(_context66.t0);case 20:_context66.prev=20;_iterator14.f();return _context66.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context66.next=27;return this._pc.setRemoteDescription(offer);case 27:_context66.next=29;return this._pc.createAnswer();case 29:answer=_context66.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context66.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator15=_createForOfIteratorHelper(localIds);try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){_localId2=_step15.value;this._mapMidTransceiver["delete"](_localId2);}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}case 35:case"end":return _context66.stop();}},_callee63,this,[[4,17,20,23]]);}));function stopReceiving(_x42){return _stopReceiving.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee64(localIds){var _iterator16,_step16,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee64$(_context67){while(1)switch(_context67.prev=_context67.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator16=_createForOfIteratorHelper(localIds);_context67.prev=3;_iterator16.s();case 5:if((_step16=_iterator16.n()).done){_context67.next=15;break;}localId=_step16.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context67.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context67.next=5;break;case 15:_context67.next=20;break;case 17:_context67.prev=17;_context67.t0=_context67["catch"](3);_iterator16.e(_context67.t0);case 20:_context67.prev=20;_iterator16.f();return _context67.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context67.next=27;return this._pc.setRemoteDescription(offer);case 27:_context67.next=29;return this._pc.createAnswer();case 29:answer=_context67.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context67.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context67.stop();}},_callee64,this,[[3,17,20,23]]);}));function pauseReceiving(_x43){return _pauseReceiving.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee65(localIds){var _iterator17,_step17,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee65$(_context68){while(1)switch(_context68.prev=_context68.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator17=_createForOfIteratorHelper(localIds);_context68.prev=3;_iterator17.s();case 5:if((_step17=_iterator17.n()).done){_context68.next=15;break;}localId=_step17.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context68.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context68.next=5;break;case 15:_context68.next=20;break;case 17:_context68.prev=17;_context68.t0=_context68["catch"](3);_iterator17.e(_context68.t0);case 20:_context68.prev=20;_iterator17.f();return _context68.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context68.next=27;return this._pc.setRemoteDescription(offer);case 27:_context68.next=29;return this._pc.createAnswer();case 29:answer=_context68.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context68.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context68.stop();}},_callee65,this,[[3,17,20,23]]);}));function resumeReceiving(_x44){return _resumeReceiving.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee66(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee66$(_context69){while(1)switch(_context69.prev=_context69.next){case 0:this.assertNotClosed();this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context69.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context69.abrupt("return",transceiver.receiver.getStats());case 6:case"end":return _context69.stop();}},_callee66,this);}));function getReceiverStats(_x45){return _getReceiverStats.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee67(_ref47){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl4,localSdpObject;return _regeneratorRuntime2().wrap(function _callee67$(_context70){while(1)switch(_context70.prev=_context70.next){case 0:sctpStreamParameters=_ref47.sctpStreamParameters,label=_ref47.label,protocol=_ref47.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context70.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context70.next=13;return this._pc.setRemoteDescription(offer);case 13:_context70.next=15;return this._pc.createAnswer();case 15:answer=_context70.sent;if(this._transportReady){_context70.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context70.next=20;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl4=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl4!==void 0?_this$_forcedLocalDtl4:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context70.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context70.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context70.stop();}},_callee67,this);}));function receiveDataChannel(_x46){return _receiveDataChannel.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee68(_ref48){var _this40=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee68$(_context71){while(1)switch(_context71.prev=_context71.next){case 0:localDtlsRole=_ref48.localDtlsRole,localSdpObject=_ref48.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context71.next=7;return new Promise(function(resolve,reject){_this40.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context71.stop();}},_callee68,this);}));function setupTransport(_x47){return _setupTransport.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Chrome111();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Chrome111=Chrome111;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Chrome55.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Chrome55Js(__unused_webpack_module,exports,__nested_webpack_require_201945__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Chrome55=void 0;var sdpTransform=__importStar(__nested_webpack_require_201945__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_201945__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var errors_1=__nested_webpack_require_201945__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_201945__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_201945__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_201945__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpPlanBUtils=__importStar(__nested_webpack_require_201945__(/*! ./sdp/planBUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));var HandlerInterface_1=__nested_webpack_require_201945__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_201945__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var logger=new Logger_1.Logger('Chrome55');var NAME='Chrome55';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Chrome55=/*#__PURE__*/function(_HandlerInterface_1$H2){function Chrome55(){var _this41;_classCallCheck2(this,Chrome55);_this41=_callSuper(this,Chrome55);// Local stream for sending.
_this41._sendStream=new MediaStream();// Map of sending MediaStreamTracks indexed by localId.
_this41._mapSendLocalIdTrack=new Map();// Next sending localId.
_this41._nextSendLocalId=0;// Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
// Value is an Object with mid, rtpParameters and rtpReceiver.
_this41._mapRecvLocalIdInfo=new Map();// Whether a DataChannel m=application section has been created.
_this41._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this41._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this41._transportReady=false;return _this41;}_inherits(Chrome55,_HandlerInterface_1$H2);return _createClass2(Chrome55,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee69(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee69$(_context72){while(1)switch(_context72.prev=_context72.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'});_context72.prev=2;_context72.next=5;return pc.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:true});case 5:offer=_context72.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context72.abrupt("return",nativeRtpCapabilities);case 12:_context72.prev=12;_context72.t0=_context72["catch"](2);try{pc.close();}catch(error2){}throw _context72.t0;case 16:case"end":return _context72.stop();}},_callee69,null,[[2,12]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities2.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee70(){return _regeneratorRuntime2().wrap(function _callee70$(_context73){while(1)switch(_context73.prev=_context73.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context73.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context73.stop();}},_callee70);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities2.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref49){var _this42=this;var direction=_ref49.direction,iceParameters=_ref49.iceParameters,iceCandidates=_ref49.iceCandidates,dtlsParameters=_ref49.dtlsParameters,sctpParameters=_ref49.sctpParameters,iceServers=_ref49.iceServers,iceTransportPolicy=_ref49.iceTransportPolicy,additionalSettings=_ref49.additionalSettings,proprietaryConstraints=_ref49.proprietaryConstraints,extendedRtpCapabilities=_ref49.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,planB:true});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this42.emit('@icegatheringstatechange',_this42._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this42.emit('@connectionstatechange',_this42._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this42._pc.iceConnectionState){case'checking':{_this42.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this42.emit('@connectionstatechange','connected');break;}case'failed':{_this42.emit('@connectionstatechange','failed');break;}case'disconnected':{_this42.emit('@connectionstatechange','disconnected');break;}case'closed':{_this42.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee71(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee71$(_context74){while(1)switch(_context74.prev=_context74.next){case 0:logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 4:case"end":return _context74.stop();}},_callee71,this);}));function updateIceServers(_x48){return _updateIceServers3.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee72(iceParameters){var offer,answer,_offer2,_answer2;return _regeneratorRuntime2().wrap(function _callee72$(_context75){while(1)switch(_context75.prev=_context75.next){case 0:logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context75.next=4;break;}return _context75.abrupt("return");case 4:if(!(this._direction==='send')){_context75.next=17;break;}_context75.next=7;return this._pc.createOffer({iceRestart:true});case 7:offer=_context75.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context75.next=11;return this._pc.setLocalDescription(offer);case 11:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context75.next=15;return this._pc.setRemoteDescription(answer);case 15:_context75.next=27;break;case 17:_offer2={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer2);_context75.next=21;return this._pc.setRemoteDescription(_offer2);case 21:_context75.next=23;return this._pc.createAnswer();case 23:_answer2=_context75.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer2);_context75.next=27;return this._pc.setLocalDescription(_answer2);case 27:case"end":return _context75.stop();}},_callee72,this);}));function restartIce(_x49){return _restartIce3.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee73(){return _regeneratorRuntime2().wrap(function _callee73$(_context76){while(1)switch(_context76.prev=_context76.next){case 0:return _context76.abrupt("return",this._pc.getStats());case 1:case"end":return _context76.stop();}},_callee73,this);}));function getTransportStats(){return _getTransportStats2.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee74(_ref50){var track,encodings,codecOptions,codec,offer,localSdpObject,offerMediaObject,sendingRtpParameters,sendingRemoteRtpParameters,_this$_forcedLocalDtl5,idx,_iterator18,_step18,encoding,answer,localId;return _regeneratorRuntime2().wrap(function _callee74$(_context77){while(1)switch(_context77.prev=_context77.next){case 0:track=_ref50.track,encodings=_ref50.encodings,codecOptions=_ref50.codecOptions,codec=_ref50.codec;this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(codec){logger.warn('send() | codec selection is not available in %s handler',this.name);}this._sendStream.addTrack(track);this._pc.addStream(this._sendStream);_context77.next=8;return this._pc.createOffer();case 8:offer=_context77.sent;localSdpObject=sdpTransform.parse(offer.sdp);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);if(this._transportReady){_context77.next=17;break;}_context77.next=17;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl5=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl5!==void 0?_this$_forcedLocalDtl5:'client',localSdpObject:localSdpObject});case 17:if(track.kind==='video'&&encodings&&encodings.length>1){logger.debug('send() | enabling simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='video';});sdpPlanBUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,track:track,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context77.next=21;return this._pc.setLocalDescription(offer);case 21:localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type===track.kind;});// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:offerMediaObject,track:track});// Complete encodings with given values.
if(encodings){for(idx=0;idx<sendingRtpParameters.encodings.length;++idx){if(encodings[idx]){Object.assign(sendingRtpParameters.encodings[idx],encodings[idx]);}}}// If VP8 and there is effective simulcast, add scalabilityMode to each
// encoding.
if(sendingRtpParameters.encodings.length>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'){_iterator18=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){encoding=_step18.value;encoding.scalabilityMode='L1T3';}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context77.next=32;return this._pc.setRemoteDescription(answer);case 32:localId=String(this._nextSendLocalId);this._nextSendLocalId++;// Insert into the map.
this._mapSendLocalIdTrack.set(localId,track);return _context77.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters});case 36:case"end":return _context77.stop();}},_callee74,this);}));function send(_x50){return _send2.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee75(localId){var track,offer,answer;return _regeneratorRuntime2().wrap(function _callee75$(_context78){while(1)switch(_context78.prev=_context78.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);track=this._mapSendLocalIdTrack.get(localId);if(track){_context78.next=5;break;}throw new Error('track not found');case 5:this._mapSendLocalIdTrack["delete"](localId);this._sendStream.removeTrack(track);this._pc.addStream(this._sendStream);_context78.next=10;return this._pc.createOffer();case 10:offer=_context78.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context78.prev=12;_context78.next=15;return this._pc.setLocalDescription(offer);case 15:_context78.next=23;break;case 17:_context78.prev=17;_context78.t0=_context78["catch"](12);if(!(this._sendStream.getTracks().length===0)){_context78.next=22;break;}logger.warn('stopSending() | ignoring expected error due no sending tracks: %s',_context78.t0.toString());return _context78.abrupt("return");case 22:throw _context78.t0;case 23:if(!(this._pc.signalingState==='stable')){_context78.next=25;break;}return _context78.abrupt("return");case 25:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context78.next=29;return this._pc.setRemoteDescription(answer);case 29:case"end":return _context78.stop();}},_callee75,this,[[12,17]]);}));function stopSending(_x51){return _stopSending2.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee76(localId){return _regeneratorRuntime2().wrap(function _callee76$(_context79){while(1)switch(_context79.prev=_context79.next){case 0:case"end":return _context79.stop();}},_callee76);}));function pauseSending(_x52){return _pauseSending2.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee77(localId){return _regeneratorRuntime2().wrap(function _callee77$(_context80){while(1)switch(_context80.prev=_context80.next){case 0:case"end":return _context80.stop();}},_callee77);}));function resumeSending(_x53){return _resumeSending2.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee78(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localId,// eslint-disable-next-line @typescript-eslint/no-unused-vars
track){return _regeneratorRuntime2().wrap(function _callee78$(_context81){while(1)switch(_context81.prev=_context81.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context81.stop();}},_callee78);}));function replaceTrack(_x54,_x55){return _replaceTrack3.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee79(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localId,// eslint-disable-next-line @typescript-eslint/no-unused-vars
spatialLayer){return _regeneratorRuntime2().wrap(function _callee79$(_context82){while(1)switch(_context82.prev=_context82.next){case 0:throw new errors_1.UnsupportedError(' not implemented');case 1:case"end":return _context82.stop();}},_callee79);}));function setMaxSpatialLayer(_x56,_x57){return _setMaxSpatialLayer3.apply(this,arguments);}return setMaxSpatialLayer;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee80(localId,params){return _regeneratorRuntime2().wrap(function _callee80$(_context83){while(1)switch(_context83.prev=_context83.next){case 0:throw new errors_1.UnsupportedError('not supported');case 1:case"end":return _context83.stop();}},_callee80);}));function setRtpEncodingParameters(_x58,_x59){return _setRtpEncodingParameters3.apply(this,arguments);}return setRtpEncodingParameters;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"getSenderStats",value:function(){var _getSenderStats2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee81(localId){return _regeneratorRuntime2().wrap(function _callee81$(_context84){while(1)switch(_context84.prev=_context84.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context84.stop();}},_callee81);}));function getSenderStats(_x60){return _getSenderStats2.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee82(_ref51){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl6,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee82$(_context85){while(1)switch(_context85.prev=_context85.next){case 0:ordered=_ref51.ordered,maxPacketLifeTime=_ref51.maxPacketLifeTime,maxRetransmits=_ref51.maxRetransmits,label=_ref51.label,protocol=_ref51.protocol;this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context85.next=24;break;}_context85.next=9;return this._pc.createOffer();case 9:offer=_context85.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context85.next=15;break;}_context85.next=15;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl6=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl6!==void 0?_this$_forcedLocalDtl6:'client',localSdpObject:localSdpObject});case 15:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context85.next=18;return this._pc.setLocalDescription(offer);case 18:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context85.next=23;return this._pc.setRemoteDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context85.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 26:case"end":return _context85.stop();}},_callee82,this);}));function sendDataChannel(_x61){return _sendDataChannel2.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee83(optionsList){var _this43=this;var results,_iterator19,_step19,options,trackId,kind,rtpParameters,streamId,mid,offer,answer,localSdpObject,_iterator20,_step20,_loop4,_this$_forcedLocalDtl7,_iterator21,_step21,_loop5;return _regeneratorRuntime2().wrap(function _callee83$(_context88){while(1)switch(_context88.prev=_context88.next){case 0:this.assertRecvDirection();results=[];_iterator19=_createForOfIteratorHelper(optionsList);try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){options=_step19.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);mid=kind;this._remoteSdp.receive({mid:mid,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context88.next=8;return this._pc.setRemoteDescription(offer);case 8:_context88.next=10;return this._pc.createAnswer();case 10:answer=_context88.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator20=_createForOfIteratorHelper(optionsList);_context88.prev=13;_loop4=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop4(){var options,kind,rtpParameters,mid,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop4$(_context86){while(1)switch(_context86.prev=_context86.next){case 0:options=_step20.value;kind=options.kind,rtpParameters=options.rtpParameters;mid=kind;answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===mid;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context86.stop();}},_loop4);});_iterator20.s();case 16:if((_step20=_iterator20.n()).done){_context88.next=20;break;}return _context88.delegateYield(_loop4(),"t0",18);case 18:_context88.next=16;break;case 20:_context88.next=25;break;case 22:_context88.prev=22;_context88.t1=_context88["catch"](13);_iterator20.e(_context88.t1);case 25:_context88.prev=25;_iterator20.f();return _context88.finish(25);case 28:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context88.next=32;break;}_context88.next=32;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl7=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl7!==void 0?_this$_forcedLocalDtl7:'client',localSdpObject:localSdpObject});case 32:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context88.next=35;return this._pc.setLocalDescription(answer);case 35:_iterator21=_createForOfIteratorHelper(optionsList);_context88.prev=36;_loop5=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop5(){var _options$streamId;var options,kind,trackId,rtpParameters,mid,localId,streamId,stream,track;return _regeneratorRuntime2().wrap(function _loop5$(_context87){while(1)switch(_context87.prev=_context87.next){case 0:options=_step21.value;kind=options.kind,trackId=options.trackId,rtpParameters=options.rtpParameters;mid=kind;localId=trackId;streamId=(_options$streamId=options.streamId)!==null&&_options$streamId!==void 0?_options$streamId:rtpParameters.rtcp.cname;stream=_this43._pc.getRemoteStreams().find(function(s){return s.id===streamId;});track=stream.getTrackById(localId);if(track){_context87.next=9;break;}throw new Error('remote track not found');case 9:// Insert into the map.
_this43._mapRecvLocalIdInfo.set(localId,{mid:mid,rtpParameters:rtpParameters});results.push({localId:localId,track:track});case 11:case"end":return _context87.stop();}},_loop5);});_iterator21.s();case 39:if((_step21=_iterator21.n()).done){_context88.next=43;break;}return _context88.delegateYield(_loop5(),"t2",41);case 41:_context88.next=39;break;case 43:_context88.next=48;break;case 45:_context88.prev=45;_context88.t3=_context88["catch"](36);_iterator21.e(_context88.t3);case 48:_context88.prev=48;_iterator21.f();return _context88.finish(48);case 51:return _context88.abrupt("return",results);case 52:case"end":return _context88.stop();}},_callee83,this,[[13,22,25,28],[36,45,48,51]]);}));function receive(_x62){return _receive2.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee84(localIds){var _iterator22,_step22,_this$_mapRecvLocalId,localId,_ref52,mid,rtpParameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee84$(_context89){while(1)switch(_context89.prev=_context89.next){case 0:this.assertRecvDirection();_iterator22=_createForOfIteratorHelper(localIds);try{for(_iterator22.s();!(_step22=_iterator22.n()).done;){localId=_step22.value;logger.debug('stopReceiving() [localId:%s]',localId);_ref52=(_this$_mapRecvLocalId=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId!==void 0?_this$_mapRecvLocalId:{},mid=_ref52.mid,rtpParameters=_ref52.rtpParameters;// Remove from the map.
this._mapRecvLocalIdInfo["delete"](localId);this._remoteSdp.planBStopReceiving({mid:mid,offerRtpParameters:rtpParameters});}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context89.next=7;return this._pc.setRemoteDescription(offer);case 7:_context89.next=9;return this._pc.createAnswer();case 9:answer=_context89.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context89.next=13;return this._pc.setLocalDescription(answer);case 13:case"end":return _context89.stop();}},_callee84,this);}));function stopReceiving(_x63){return _stopReceiving2.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee85(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee85$(_context90){while(1)switch(_context90.prev=_context90.next){case 0:case"end":return _context90.stop();}},_callee85);}));function pauseReceiving(_x64){return _pauseReceiving2.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee86(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee86$(_context91){while(1)switch(_context91.prev=_context91.next){case 0:case"end":return _context91.stop();}},_callee86);}));function resumeReceiving(_x65){return _resumeReceiving2.apply(this,arguments);}return resumeReceiving;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"getReceiverStats",value:function(){var _getReceiverStats2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee87(localId){return _regeneratorRuntime2().wrap(function _callee87$(_context92){while(1)switch(_context92.prev=_context92.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context92.stop();}},_callee87);}));function getReceiverStats(_x66){return _getReceiverStats2.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee88(_ref53){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl8,localSdpObject;return _regeneratorRuntime2().wrap(function _callee88$(_context93){while(1)switch(_context93.prev=_context93.next){case 0:sctpStreamParameters=_ref53.sctpStreamParameters,label=_ref53.label,protocol=_ref53.protocol;this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context93.next=23;break;}this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:true});offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context93.next=12;return this._pc.setRemoteDescription(offer);case 12:_context93.next=14;return this._pc.createAnswer();case 14:answer=_context93.sent;if(this._transportReady){_context93.next=19;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context93.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl8=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl8!==void 0?_this$_forcedLocalDtl8:'client',localSdpObject:localSdpObject});case 19:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context93.next=22;return this._pc.setLocalDescription(answer);case 22:this._hasDataChannelMediaSection=true;case 23:return _context93.abrupt("return",{dataChannel:dataChannel});case 24:case"end":return _context93.stop();}},_callee88,this);}));function receiveDataChannel(_x67){return _receiveDataChannel2.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport2=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee89(_ref54){var _this44=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee89$(_context94){while(1)switch(_context94.prev=_context94.next){case 0:localDtlsRole=_ref54.localDtlsRole,localSdpObject=_ref54.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context94.next=7;return new Promise(function(resolve,reject){_this44.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context94.stop();}},_callee89,this);}));function setupTransport(_x68){return _setupTransport2.apply(this,arguments);}return setupTransport;}()},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Chrome55();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Chrome55=Chrome55;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Chrome67.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Chrome67Js(__unused_webpack_module,exports,__nested_webpack_require_235761__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Chrome67=void 0;var sdpTransform=__importStar(__nested_webpack_require_235761__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_235761__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_235761__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_235761__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_235761__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpPlanBUtils=__importStar(__nested_webpack_require_235761__(/*! ./sdp/planBUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));var HandlerInterface_1=__nested_webpack_require_235761__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_235761__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var logger=new Logger_1.Logger('Chrome67');var NAME='Chrome67';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Chrome67=/*#__PURE__*/function(_HandlerInterface_1$H3){function Chrome67(){var _this45;_classCallCheck2(this,Chrome67);_this45=_callSuper(this,Chrome67);// Local stream for sending.
_this45._sendStream=new MediaStream();// Map of RTCRtpSender indexed by localId.
_this45._mapSendLocalIdRtpSender=new Map();// Next sending localId.
_this45._nextSendLocalId=0;// Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
// Value is an Object with mid, rtpParameters and rtpReceiver.
_this45._mapRecvLocalIdInfo=new Map();// Whether a DataChannel m=application section has been created.
_this45._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this45._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this45._transportReady=false;return _this45;}_inherits(Chrome67,_HandlerInterface_1$H3);return _createClass2(Chrome67,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee90(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee90$(_context95){while(1)switch(_context95.prev=_context95.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'});_context95.prev=2;_context95.next=5;return pc.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:true});case 5:offer=_context95.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context95.abrupt("return",nativeRtpCapabilities);case 12:_context95.prev=12;_context95.t0=_context95["catch"](2);try{pc.close();}catch(error2){}throw _context95.t0;case 16:case"end":return _context95.stop();}},_callee90,null,[[2,12]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities3.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee91(){return _regeneratorRuntime2().wrap(function _callee91$(_context96){while(1)switch(_context96.prev=_context96.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context96.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context96.stop();}},_callee91);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities3.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref55){var _this46=this;var direction=_ref55.direction,iceParameters=_ref55.iceParameters,iceCandidates=_ref55.iceCandidates,dtlsParameters=_ref55.dtlsParameters,sctpParameters=_ref55.sctpParameters,iceServers=_ref55.iceServers,iceTransportPolicy=_ref55.iceTransportPolicy,additionalSettings=_ref55.additionalSettings,proprietaryConstraints=_ref55.proprietaryConstraints,extendedRtpCapabilities=_ref55.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,planB:true});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this46.emit('@icegatheringstatechange',_this46._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this46.emit('@connectionstatechange',_this46._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this46._pc.iceConnectionState){case'checking':{_this46.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this46.emit('@connectionstatechange','connected');break;}case'failed':{_this46.emit('@connectionstatechange','failed');break;}case'disconnected':{_this46.emit('@connectionstatechange','disconnected');break;}case'closed':{_this46.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee92(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee92$(_context97){while(1)switch(_context97.prev=_context97.next){case 0:logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 4:case"end":return _context97.stop();}},_callee92,this);}));function updateIceServers(_x69){return _updateIceServers4.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee93(iceParameters){var offer,answer,_offer3,_answer3;return _regeneratorRuntime2().wrap(function _callee93$(_context98){while(1)switch(_context98.prev=_context98.next){case 0:logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context98.next=4;break;}return _context98.abrupt("return");case 4:if(!(this._direction==='send')){_context98.next=17;break;}_context98.next=7;return this._pc.createOffer({iceRestart:true});case 7:offer=_context98.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context98.next=11;return this._pc.setLocalDescription(offer);case 11:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context98.next=15;return this._pc.setRemoteDescription(answer);case 15:_context98.next=27;break;case 17:_offer3={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer3);_context98.next=21;return this._pc.setRemoteDescription(_offer3);case 21:_context98.next=23;return this._pc.createAnswer();case 23:_answer3=_context98.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer3);_context98.next=27;return this._pc.setLocalDescription(_answer3);case 27:case"end":return _context98.stop();}},_callee93,this);}));function restartIce(_x70){return _restartIce4.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee94(){return _regeneratorRuntime2().wrap(function _callee94$(_context99){while(1)switch(_context99.prev=_context99.next){case 0:return _context99.abrupt("return",this._pc.getStats());case 1:case"end":return _context99.stop();}},_callee94,this);}));function getTransportStats(){return _getTransportStats3.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee95(_ref56){var track,encodings,codecOptions,codec,offer,localSdpObject,offerMediaObject,sendingRtpParameters,sendingRemoteRtpParameters,_this$_forcedLocalDtl9,idx,_iterator23,_step23,encoding,answer,localId,rtpSender;return _regeneratorRuntime2().wrap(function _callee95$(_context100){while(1)switch(_context100.prev=_context100.next){case 0:track=_ref56.track,encodings=_ref56.encodings,codecOptions=_ref56.codecOptions,codec=_ref56.codec;this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(codec){logger.warn('send() | codec selection is not available in %s handler',this.name);}this._sendStream.addTrack(track);this._pc.addTrack(track,this._sendStream);_context100.next=8;return this._pc.createOffer();case 8:offer=_context100.sent;localSdpObject=sdpTransform.parse(offer.sdp);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);if(this._transportReady){_context100.next=17;break;}_context100.next=17;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl9=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl9!==void 0?_this$_forcedLocalDtl9:'client',localSdpObject:localSdpObject});case 17:if(track.kind==='video'&&encodings&&encodings.length>1){logger.debug('send() | enabling simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='video';});sdpPlanBUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,track:track,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context100.next=21;return this._pc.setLocalDescription(offer);case 21:localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type===track.kind;});// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:offerMediaObject,track:track});// Complete encodings with given values.
if(encodings){for(idx=0;idx<sendingRtpParameters.encodings.length;++idx){if(encodings[idx]){Object.assign(sendingRtpParameters.encodings[idx],encodings[idx]);}}}// If VP8 and there is effective simulcast, add scalabilityMode to each
// encoding.
if(sendingRtpParameters.encodings.length>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'){_iterator23=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator23.s();!(_step23=_iterator23.n()).done;){encoding=_step23.value;encoding.scalabilityMode='L1T3';}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context100.next=32;return this._pc.setRemoteDescription(answer);case 32:localId=String(this._nextSendLocalId);this._nextSendLocalId++;rtpSender=this._pc.getSenders().find(function(s){return s.track===track;});// Insert into the map.
this._mapSendLocalIdRtpSender.set(localId,rtpSender);return _context100.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:rtpSender});case 37:case"end":return _context100.stop();}},_callee95,this);}));function send(_x71){return _send3.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee96(localId){var rtpSender,offer,answer;return _regeneratorRuntime2().wrap(function _callee96$(_context101){while(1)switch(_context101.prev=_context101.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context101.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:this._pc.removeTrack(rtpSender);if(rtpSender.track){this._sendStream.removeTrack(rtpSender.track);}this._mapSendLocalIdRtpSender["delete"](localId);_context101.next=10;return this._pc.createOffer();case 10:offer=_context101.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context101.prev=12;_context101.next=15;return this._pc.setLocalDescription(offer);case 15:_context101.next=23;break;case 17:_context101.prev=17;_context101.t0=_context101["catch"](12);if(!(this._sendStream.getTracks().length===0)){_context101.next=22;break;}logger.warn('stopSending() | ignoring expected error due no sending tracks: %s',_context101.t0.toString());return _context101.abrupt("return");case 22:throw _context101.t0;case 23:if(!(this._pc.signalingState==='stable')){_context101.next=25;break;}return _context101.abrupt("return");case 25:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context101.next=29;return this._pc.setRemoteDescription(answer);case 29:case"end":return _context101.stop();}},_callee96,this,[[12,17]]);}));function stopSending(_x72){return _stopSending3.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee97(localId){return _regeneratorRuntime2().wrap(function _callee97$(_context102){while(1)switch(_context102.prev=_context102.next){case 0:case"end":return _context102.stop();}},_callee97);}));function pauseSending(_x73){return _pauseSending3.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee98(localId){return _regeneratorRuntime2().wrap(function _callee98$(_context103){while(1)switch(_context103.prev=_context103.next){case 0:case"end":return _context103.stop();}},_callee98);}));function resumeSending(_x74){return _resumeSending3.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee99(localId,track){var rtpSender,oldTrack;return _regeneratorRuntime2().wrap(function _callee99$(_context104){while(1)switch(_context104.prev=_context104.next){case 0:this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context104.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:oldTrack=rtpSender.track;_context104.next=8;return rtpSender.replaceTrack(track);case 8:// Remove the old track from the local stream.
if(oldTrack){this._sendStream.removeTrack(oldTrack);}// Add the new track to the local stream.
if(track){this._sendStream.addTrack(track);}case 10:case"end":return _context104.stop();}},_callee99,this);}));function replaceTrack(_x75,_x76){return _replaceTrack4.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee100(localId,spatialLayer){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee100$(_context105){while(1)switch(_context105.prev=_context105.next){case 0:this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context105.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context105.next=9;return rtpSender.setParameters(parameters);case 9:case"end":return _context105.stop();}},_callee100,this);}));function setMaxSpatialLayer(_x77,_x78){return _setMaxSpatialLayer4.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee101(localId,params){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee101$(_context106){while(1)switch(_context106.prev=_context106.next){case 0:this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context106.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context106.next=9;return rtpSender.setParameters(parameters);case 9:case"end":return _context106.stop();}},_callee101,this);}));function setRtpEncodingParameters(_x79,_x80){return _setRtpEncodingParameters4.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee102(localId){var rtpSender;return _regeneratorRuntime2().wrap(function _callee102$(_context107){while(1)switch(_context107.prev=_context107.next){case 0:this.assertSendDirection();rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context107.next=4;break;}throw new Error('associated RTCRtpSender not found');case 4:return _context107.abrupt("return",rtpSender.getStats());case 5:case"end":return _context107.stop();}},_callee102,this);}));function getSenderStats(_x81){return _getSenderStats3.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee103(_ref57){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl10,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee103$(_context108){while(1)switch(_context108.prev=_context108.next){case 0:ordered=_ref57.ordered,maxPacketLifeTime=_ref57.maxPacketLifeTime,maxRetransmits=_ref57.maxRetransmits,label=_ref57.label,protocol=_ref57.protocol;this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context108.next=24;break;}_context108.next=9;return this._pc.createOffer();case 9:offer=_context108.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context108.next=15;break;}_context108.next=15;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl10=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl10!==void 0?_this$_forcedLocalDtl10:'client',localSdpObject:localSdpObject});case 15:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context108.next=18;return this._pc.setLocalDescription(offer);case 18:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context108.next=23;return this._pc.setRemoteDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context108.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 26:case"end":return _context108.stop();}},_callee103,this);}));function sendDataChannel(_x82){return _sendDataChannel3.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee104(optionsList){var _this47=this;var results,_iterator24,_step24,options,trackId,kind,rtpParameters,streamId,mid,offer,answer,localSdpObject,_iterator25,_step25,_loop6,_this$_forcedLocalDtl11,_iterator26,_step26,_loop7;return _regeneratorRuntime2().wrap(function _callee104$(_context111){while(1)switch(_context111.prev=_context111.next){case 0:this.assertRecvDirection();results=[];_iterator24=_createForOfIteratorHelper(optionsList);try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){options=_step24.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);mid=kind;this._remoteSdp.receive({mid:mid,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context111.next=8;return this._pc.setRemoteDescription(offer);case 8:_context111.next=10;return this._pc.createAnswer();case 10:answer=_context111.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator25=_createForOfIteratorHelper(optionsList);_context111.prev=13;_loop6=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop6(){var options,kind,rtpParameters,mid,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop6$(_context109){while(1)switch(_context109.prev=_context109.next){case 0:options=_step25.value;kind=options.kind,rtpParameters=options.rtpParameters;mid=kind;answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===mid;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context109.stop();}},_loop6);});_iterator25.s();case 16:if((_step25=_iterator25.n()).done){_context111.next=20;break;}return _context111.delegateYield(_loop6(),"t0",18);case 18:_context111.next=16;break;case 20:_context111.next=25;break;case 22:_context111.prev=22;_context111.t1=_context111["catch"](13);_iterator25.e(_context111.t1);case 25:_context111.prev=25;_iterator25.f();return _context111.finish(25);case 28:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context111.next=32;break;}_context111.next=32;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl11=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl11!==void 0?_this$_forcedLocalDtl11:'client',localSdpObject:localSdpObject});case 32:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context111.next=35;return this._pc.setLocalDescription(answer);case 35:_iterator26=_createForOfIteratorHelper(optionsList);_context111.prev=36;_loop7=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop7(){var options,kind,trackId,rtpParameters,localId,mid,rtpReceiver;return _regeneratorRuntime2().wrap(function _loop7$(_context110){while(1)switch(_context110.prev=_context110.next){case 0:options=_step26.value;kind=options.kind,trackId=options.trackId,rtpParameters=options.rtpParameters;localId=trackId;mid=kind;rtpReceiver=_this47._pc.getReceivers().find(function(r){return r.track&&r.track.id===localId;});if(rtpReceiver){_context110.next=7;break;}throw new Error('new RTCRtpReceiver not');case 7:// Insert into the map.
_this47._mapRecvLocalIdInfo.set(localId,{mid:mid,rtpParameters:rtpParameters,rtpReceiver:rtpReceiver});results.push({localId:localId,track:rtpReceiver.track,rtpReceiver:rtpReceiver});case 9:case"end":return _context110.stop();}},_loop7);});_iterator26.s();case 39:if((_step26=_iterator26.n()).done){_context111.next=43;break;}return _context111.delegateYield(_loop7(),"t2",41);case 41:_context111.next=39;break;case 43:_context111.next=48;break;case 45:_context111.prev=45;_context111.t3=_context111["catch"](36);_iterator26.e(_context111.t3);case 48:_context111.prev=48;_iterator26.f();return _context111.finish(48);case 51:return _context111.abrupt("return",results);case 52:case"end":return _context111.stop();}},_callee104,this,[[13,22,25,28],[36,45,48,51]]);}));function receive(_x83){return _receive3.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee105(localIds){var _iterator27,_step27,_this$_mapRecvLocalId2,localId,_ref58,mid,rtpParameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee105$(_context112){while(1)switch(_context112.prev=_context112.next){case 0:this.assertRecvDirection();_iterator27=_createForOfIteratorHelper(localIds);try{for(_iterator27.s();!(_step27=_iterator27.n()).done;){localId=_step27.value;logger.debug('stopReceiving() [localId:%s]',localId);_ref58=(_this$_mapRecvLocalId2=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId2!==void 0?_this$_mapRecvLocalId2:{},mid=_ref58.mid,rtpParameters=_ref58.rtpParameters;// Remove from the map.
this._mapRecvLocalIdInfo["delete"](localId);this._remoteSdp.planBStopReceiving({mid:mid,offerRtpParameters:rtpParameters});}}catch(err){_iterator27.e(err);}finally{_iterator27.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context112.next=7;return this._pc.setRemoteDescription(offer);case 7:_context112.next=9;return this._pc.createAnswer();case 9:answer=_context112.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context112.next=13;return this._pc.setLocalDescription(answer);case 13:case"end":return _context112.stop();}},_callee105,this);}));function stopReceiving(_x84){return _stopReceiving3.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee106(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee106$(_context113){while(1)switch(_context113.prev=_context113.next){case 0:case"end":return _context113.stop();}},_callee106);}));function pauseReceiving(_x85){return _pauseReceiving3.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee107(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee107$(_context114){while(1)switch(_context114.prev=_context114.next){case 0:case"end":return _context114.stop();}},_callee107);}));function resumeReceiving(_x86){return _resumeReceiving3.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee108(localId){var _this$_mapRecvLocalId3;var _ref59,rtpReceiver;return _regeneratorRuntime2().wrap(function _callee108$(_context115){while(1)switch(_context115.prev=_context115.next){case 0:this.assertRecvDirection();_ref59=(_this$_mapRecvLocalId3=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId3!==void 0?_this$_mapRecvLocalId3:{},rtpReceiver=_ref59.rtpReceiver;if(rtpReceiver){_context115.next=4;break;}throw new Error('associated RTCRtpReceiver not found');case 4:return _context115.abrupt("return",rtpReceiver.getStats());case 5:case"end":return _context115.stop();}},_callee108,this);}));function getReceiverStats(_x87){return _getReceiverStats3.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee109(_ref60){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl12,localSdpObject;return _regeneratorRuntime2().wrap(function _callee109$(_context116){while(1)switch(_context116.prev=_context116.next){case 0:sctpStreamParameters=_ref60.sctpStreamParameters,label=_ref60.label,protocol=_ref60.protocol;this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context116.next=23;break;}this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:true});offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context116.next=12;return this._pc.setRemoteDescription(offer);case 12:_context116.next=14;return this._pc.createAnswer();case 14:answer=_context116.sent;if(this._transportReady){_context116.next=19;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context116.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl12=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl12!==void 0?_this$_forcedLocalDtl12:'client',localSdpObject:localSdpObject});case 19:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context116.next=22;return this._pc.setLocalDescription(answer);case 22:this._hasDataChannelMediaSection=true;case 23:return _context116.abrupt("return",{dataChannel:dataChannel});case 24:case"end":return _context116.stop();}},_callee109,this);}));function receiveDataChannel(_x88){return _receiveDataChannel3.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport3=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee110(_ref61){var _this48=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee110$(_context117){while(1)switch(_context117.prev=_context117.next){case 0:localDtlsRole=_ref61.localDtlsRole,localSdpObject=_ref61.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context117.next=7;return new Promise(function(resolve,reject){_this48.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context117.stop();}},_callee110,this);}));function setupTransport(_x89){return _setupTransport3.apply(this,arguments);}return setupTransport;}()},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Chrome67();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Chrome67=Chrome67;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Chrome70.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Chrome70Js(__unused_webpack_module,exports,__nested_webpack_require_271377__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Chrome70=void 0;var sdpTransform=__importStar(__nested_webpack_require_271377__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_271377__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_271377__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_271377__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_271377__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_271377__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var HandlerInterface_1=__nested_webpack_require_271377__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_271377__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_271377__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Chrome70');var NAME='Chrome70';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Chrome70=/*#__PURE__*/function(_HandlerInterface_1$H4){function Chrome70(){var _this49;_classCallCheck2(this,Chrome70);_this49=_callSuper(this,Chrome70);// Map of RTCTransceivers indexed by MID.
_this49._mapMidTransceiver=new Map();// Local stream for sending.
_this49._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this49._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this49._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this49._transportReady=false;return _this49;}_inherits(Chrome70,_HandlerInterface_1$H4);return _createClass2(Chrome70,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee111(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee111$(_context118){while(1)switch(_context118.prev=_context118.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'});_context118.prev=2;pc.addTransceiver('audio');pc.addTransceiver('video');_context118.next=7;return pc.createOffer();case 7:offer=_context118.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context118.abrupt("return",nativeRtpCapabilities);case 14:_context118.prev=14;_context118.t0=_context118["catch"](2);try{pc.close();}catch(error2){}throw _context118.t0;case 18:case"end":return _context118.stop();}},_callee111,null,[[2,14]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities4.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee112(){return _regeneratorRuntime2().wrap(function _callee112$(_context119){while(1)switch(_context119.prev=_context119.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context119.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context119.stop();}},_callee112);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities4.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref62){var _this50=this;var direction=_ref62.direction,iceParameters=_ref62.iceParameters,iceCandidates=_ref62.iceCandidates,dtlsParameters=_ref62.dtlsParameters,sctpParameters=_ref62.sctpParameters,iceServers=_ref62.iceServers,iceTransportPolicy=_ref62.iceTransportPolicy,additionalSettings=_ref62.additionalSettings,proprietaryConstraints=_ref62.proprietaryConstraints,extendedRtpCapabilities=_ref62.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this50.emit('@icegatheringstatechange',_this50._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this50.emit('@connectionstatechange',_this50._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this50._pc.iceConnectionState){case'checking':{_this50.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this50.emit('@connectionstatechange','connected');break;}case'failed':{_this50.emit('@connectionstatechange','failed');break;}case'disconnected':{_this50.emit('@connectionstatechange','disconnected');break;}case'closed':{_this50.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee113(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee113$(_context120){while(1)switch(_context120.prev=_context120.next){case 0:logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 4:case"end":return _context120.stop();}},_callee113,this);}));function updateIceServers(_x90){return _updateIceServers5.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee114(iceParameters){var offer,answer,_offer4,_answer4;return _regeneratorRuntime2().wrap(function _callee114$(_context121){while(1)switch(_context121.prev=_context121.next){case 0:logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context121.next=4;break;}return _context121.abrupt("return");case 4:if(!(this._direction==='send')){_context121.next=17;break;}_context121.next=7;return this._pc.createOffer({iceRestart:true});case 7:offer=_context121.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context121.next=11;return this._pc.setLocalDescription(offer);case 11:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context121.next=15;return this._pc.setRemoteDescription(answer);case 15:_context121.next=27;break;case 17:_offer4={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer4);_context121.next=21;return this._pc.setRemoteDescription(_offer4);case 21:_context121.next=23;return this._pc.createAnswer();case 23:_answer4=_context121.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer4);_context121.next=27;return this._pc.setLocalDescription(_answer4);case 27:case"end":return _context121.stop();}},_callee114,this);}));function restartIce(_x91){return _restartIce5.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee115(){return _regeneratorRuntime2().wrap(function _callee115$(_context122){while(1)switch(_context122.prev=_context122.next){case 0:return _context122.abrupt("return",this._pc.getStats());case 1:case"end":return _context122.stop();}},_callee115,this);}));function getTransportStats(){return _getTransportStats4.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee116(_ref63){var track,encodings,codecOptions,codec,sendingRtpParameters,sendingRemoteRtpParameters,mediaSectionIdx,transceiver,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl13,hackVp9Svc,layers,parameters,idx,_parameters$encodings,encoding,desiredEncoding,localId,_idx,_iterator28,_step28,_encoding,answer;return _regeneratorRuntime2().wrap(function _callee116$(_context123){while(1)switch(_context123.prev=_context123.next){case 0:track=_ref63.track,encodings=_ref63.encodings,codecOptions=_ref63.codecOptions,codec=_ref63.codec;this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);mediaSectionIdx=this._remoteSdp.getNextMediaSectionIdx();transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream]});_context123.next=11;return this._pc.createOffer();case 11:offer=_context123.sent;localSdpObject=sdpTransform.parse(offer.sdp);if(this._transportReady){_context123.next=16;break;}_context123.next=16;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl13=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl13!==void 0?_this$_forcedLocalDtl13:'client',localSdpObject:localSdpObject});case 16:if(encodings&&encodings.length>1){logger.debug('send() | enabling legacy simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];sdpUnifiedPlanUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}// Special case for VP9 with SVC.
hackVp9Svc=false;layers=(0,scalabilityModes_1.parse)((encodings!==null&&encodings!==void 0?encodings:[{}])[0].scalabilityMode);if(encodings&&encodings.length===1&&layers.spatialLayers>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp9'){logger.debug('send() | enabling legacy simulcast for VP9 SVC');hackVp9Svc=true;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];sdpUnifiedPlanUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,numStreams:layers.spatialLayers});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context123.next=23;return this._pc.setLocalDescription(offer);case 23:if(!encodings){_context123.next=38;break;}logger.debug('send() | applying given encodings');parameters=transceiver.sender.getParameters();idx=0;case 27:if(!(idx<((_parameters$encodings=parameters.encodings)!==null&&_parameters$encodings!==void 0?_parameters$encodings:[]).length)){_context123.next=36;break;}encoding=parameters.encodings[idx];desiredEncoding=encodings[idx];// Should not happen but just in case.
if(desiredEncoding){_context123.next=32;break;}return _context123.abrupt("break",36);case 32:parameters.encodings[idx]=Object.assign(encoding,desiredEncoding);case 33:++idx;_context123.next=27;break;case 36:_context123.next=38;return transceiver.sender.setParameters(parameters);case 38:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});// Complete encodings with given values.
if(encodings){for(_idx=0;_idx<sendingRtpParameters.encodings.length;++_idx){if(encodings[_idx]){Object.assign(sendingRtpParameters.encodings[_idx],encodings[_idx]);}}}// Hack for VP9 SVC.
if(hackVp9Svc){sendingRtpParameters.encodings=[sendingRtpParameters.encodings[0]];}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator28=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator28.s();!(_step28=_iterator28.n()).done;){_encoding=_step28.value;_encoding.scalabilityMode='L1T3';}}catch(err){_iterator28.e(err);}finally{_iterator28.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,reuseMid:mediaSectionIdx.reuseMid,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context123.next=52;return this._pc.setRemoteDescription(answer);case 52:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context123.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 54:case"end":return _context123.stop();}},_callee116,this);}));function send(_x92){return _send4.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee117(localId){var transceiver,mediaSectionClosed,offer,answer;return _regeneratorRuntime2().wrap(function _callee117$(_context124){while(1)switch(_context124.prev=_context124.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context124.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:void transceiver.sender.replaceTrack(null);this._pc.removeTrack(transceiver.sender);mediaSectionClosed=this._remoteSdp.closeMediaSection(transceiver.mid);if(mediaSectionClosed){try{transceiver.stop();}catch(error){}}_context124.next=11;return this._pc.createOffer();case 11:offer=_context124.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context124.next=15;return this._pc.setLocalDescription(offer);case 15:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context124.next=19;return this._pc.setRemoteDescription(answer);case 19:this._mapMidTransceiver["delete"](localId);case 20:case"end":return _context124.stop();}},_callee117,this);}));function stopSending(_x93){return _stopSending4.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee118(localId){return _regeneratorRuntime2().wrap(function _callee118$(_context125){while(1)switch(_context125.prev=_context125.next){case 0:case"end":return _context125.stop();}},_callee118);}));function pauseSending(_x94){return _pauseSending4.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee119(localId){return _regeneratorRuntime2().wrap(function _callee119$(_context126){while(1)switch(_context126.prev=_context126.next){case 0:case"end":return _context126.stop();}},_callee119);}));function resumeSending(_x95){return _resumeSending4.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee120(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee120$(_context127){while(1)switch(_context127.prev=_context127.next){case 0:this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context127.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:_context127.next=7;return transceiver.sender.replaceTrack(track);case 7:case"end":return _context127.stop();}},_callee120,this);}));function replaceTrack(_x96,_x97){return _replaceTrack5.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee121(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee121$(_context128){while(1)switch(_context128.prev=_context128.next){case 0:this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context128.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context128.next=9;return transceiver.sender.setParameters(parameters);case 9:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context128.next=12;return this._pc.createOffer();case 12:offer=_context128.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context128.next=16;return this._pc.setLocalDescription(offer);case 16:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context128.next=20;return this._pc.setRemoteDescription(answer);case 20:case"end":return _context128.stop();}},_callee121,this);}));function setMaxSpatialLayer(_x98,_x99){return _setMaxSpatialLayer5.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee122(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee122$(_context129){while(1)switch(_context129.prev=_context129.next){case 0:this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context129.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context129.next=9;return transceiver.sender.setParameters(parameters);case 9:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context129.next=12;return this._pc.createOffer();case 12:offer=_context129.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context129.next=16;return this._pc.setLocalDescription(offer);case 16:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context129.next=20;return this._pc.setRemoteDescription(answer);case 20:case"end":return _context129.stop();}},_callee122,this);}));function setRtpEncodingParameters(_x100,_x101){return _setRtpEncodingParameters5.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee123(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee123$(_context130){while(1)switch(_context130.prev=_context130.next){case 0:this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context130.next=4;break;}throw new Error('associated RTCRtpTransceiver not found');case 4:return _context130.abrupt("return",transceiver.sender.getStats());case 5:case"end":return _context130.stop();}},_callee123,this);}));function getSenderStats(_x102){return _getSenderStats4.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee124(_ref64){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl14,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee124$(_context131){while(1)switch(_context131.prev=_context131.next){case 0:ordered=_ref64.ordered,maxPacketLifeTime=_ref64.maxPacketLifeTime,maxRetransmits=_ref64.maxRetransmits,label=_ref64.label,protocol=_ref64.protocol;this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context131.next=24;break;}_context131.next=9;return this._pc.createOffer();case 9:offer=_context131.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context131.next=15;break;}_context131.next=15;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl14=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl14!==void 0?_this$_forcedLocalDtl14:'client',localSdpObject:localSdpObject});case 15:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context131.next=18;return this._pc.setLocalDescription(offer);case 18:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context131.next=23;return this._pc.setRemoteDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context131.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 26:case"end":return _context131.stop();}},_callee124,this);}));function sendDataChannel(_x103){return _sendDataChannel4.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee125(optionsList){var _this51=this;var results,mapLocalId,_iterator29,_step29,_rtpParameters$mid2,options,trackId,kind,rtpParameters,streamId,localId,offer,answer,localSdpObject,_iterator30,_step30,_loop8,_this$_forcedLocalDtl15,_iterator31,_step31,_loop9;return _regeneratorRuntime2().wrap(function _callee125$(_context134){while(1)switch(_context134.prev=_context134.next){case 0:this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator29=_createForOfIteratorHelper(optionsList);try{for(_iterator29.s();!(_step29=_iterator29.n()).done;){options=_step29.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid2=rtpParameters.mid)!==null&&_rtpParameters$mid2!==void 0?_rtpParameters$mid2:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator29.e(err);}finally{_iterator29.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context134.next=9;return this._pc.setRemoteDescription(offer);case 9:_context134.next=11;return this._pc.createAnswer();case 11:answer=_context134.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator30=_createForOfIteratorHelper(optionsList);_context134.prev=14;_loop8=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop8(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop8$(_context132){while(1)switch(_context132.prev=_context132.next){case 0:options=_step30.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context132.stop();}},_loop8);});_iterator30.s();case 17:if((_step30=_iterator30.n()).done){_context134.next=21;break;}return _context134.delegateYield(_loop8(),"t0",19);case 19:_context134.next=17;break;case 21:_context134.next=26;break;case 23:_context134.prev=23;_context134.t1=_context134["catch"](14);_iterator30.e(_context134.t1);case 26:_context134.prev=26;_iterator30.f();return _context134.finish(26);case 29:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context134.next=33;break;}_context134.next=33;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl15=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl15!==void 0?_this$_forcedLocalDtl15:'client',localSdpObject:localSdpObject});case 33:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context134.next=36;return this._pc.setLocalDescription(answer);case 36:_iterator31=_createForOfIteratorHelper(optionsList);_context134.prev=37;_loop9=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop9(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop9$(_context133){while(1)switch(_context133.prev=_context133.next){case 0:options=_step31.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this51._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context133.next=6;break;}throw new Error('new RTCRtpTransceiver not found');case 6:// Store in the map.
_this51._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 8:case"end":return _context133.stop();}},_loop9);});_iterator31.s();case 40:if((_step31=_iterator31.n()).done){_context134.next=44;break;}return _context134.delegateYield(_loop9(),"t2",42);case 42:_context134.next=40;break;case 44:_context134.next=49;break;case 46:_context134.prev=46;_context134.t3=_context134["catch"](37);_iterator31.e(_context134.t3);case 49:_context134.prev=49;_iterator31.f();return _context134.finish(49);case 52:return _context134.abrupt("return",results);case 53:case"end":return _context134.stop();}},_callee125,this,[[14,23,26,29],[37,46,49,52]]);}));function receive(_x104){return _receive4.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee126(localIds){var _iterator32,_step32,localId,transceiver,offer,answer,_iterator33,_step33,_localId3;return _regeneratorRuntime2().wrap(function _callee126$(_context135){while(1)switch(_context135.prev=_context135.next){case 0:this.assertRecvDirection();_iterator32=_createForOfIteratorHelper(localIds);_context135.prev=2;_iterator32.s();case 4:if((_step32=_iterator32.n()).done){_context135.next=13;break;}localId=_step32.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context135.next=10;break;}throw new Error('associated RTCRtpTransceiver not found');case 10:this._remoteSdp.closeMediaSection(transceiver.mid);case 11:_context135.next=4;break;case 13:_context135.next=18;break;case 15:_context135.prev=15;_context135.t0=_context135["catch"](2);_iterator32.e(_context135.t0);case 18:_context135.prev=18;_iterator32.f();return _context135.finish(18);case 21:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context135.next=25;return this._pc.setRemoteDescription(offer);case 25:_context135.next=27;return this._pc.createAnswer();case 27:answer=_context135.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context135.next=31;return this._pc.setLocalDescription(answer);case 31:_iterator33=_createForOfIteratorHelper(localIds);try{for(_iterator33.s();!(_step33=_iterator33.n()).done;){_localId3=_step33.value;this._mapMidTransceiver["delete"](_localId3);}}catch(err){_iterator33.e(err);}finally{_iterator33.f();}case 33:case"end":return _context135.stop();}},_callee126,this,[[2,15,18,21]]);}));function stopReceiving(_x105){return _stopReceiving4.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee127(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee127$(_context136){while(1)switch(_context136.prev=_context136.next){case 0:case"end":return _context136.stop();}},_callee127);}));function pauseReceiving(_x106){return _pauseReceiving4.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee128(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee128$(_context137){while(1)switch(_context137.prev=_context137.next){case 0:case"end":return _context137.stop();}},_callee128);}));function resumeReceiving(_x107){return _resumeReceiving4.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee129(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee129$(_context138){while(1)switch(_context138.prev=_context138.next){case 0:this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context138.next=4;break;}throw new Error('associated RTCRtpTransceiver not found');case 4:return _context138.abrupt("return",transceiver.receiver.getStats());case 5:case"end":return _context138.stop();}},_callee129,this);}));function getReceiverStats(_x108){return _getReceiverStats4.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee130(_ref65){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl16,localSdpObject;return _regeneratorRuntime2().wrap(function _callee130$(_context139){while(1)switch(_context139.prev=_context139.next){case 0:sctpStreamParameters=_ref65.sctpStreamParameters,label=_ref65.label,protocol=_ref65.protocol;this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context139.next=23;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context139.next=12;return this._pc.setRemoteDescription(offer);case 12:_context139.next=14;return this._pc.createAnswer();case 14:answer=_context139.sent;if(this._transportReady){_context139.next=19;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context139.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl16=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl16!==void 0?_this$_forcedLocalDtl16:'client',localSdpObject:localSdpObject});case 19:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context139.next=22;return this._pc.setLocalDescription(answer);case 22:this._hasDataChannelMediaSection=true;case 23:return _context139.abrupt("return",{dataChannel:dataChannel});case 24:case"end":return _context139.stop();}},_callee130,this);}));function receiveDataChannel(_x109){return _receiveDataChannel4.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport4=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee131(_ref66){var _this52=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee131$(_context140){while(1)switch(_context140.prev=_context140.next){case 0:localDtlsRole=_ref66.localDtlsRole,localSdpObject=_ref66.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context140.next=7;return new Promise(function(resolve,reject){_this52.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context140.stop();}},_callee131,this);}));function setupTransport(_x110){return _setupTransport4.apply(this,arguments);}return setupTransport;}()},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Chrome70();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Chrome70=Chrome70;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Chrome74.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Chrome74Js(__unused_webpack_module,exports,__nested_webpack_require_309551__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Chrome74=void 0;var sdpTransform=__importStar(__nested_webpack_require_309551__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_309551__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_309551__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_309551__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_309551__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_309551__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var ortcUtils=__importStar(__nested_webpack_require_309551__(/*! ./ortc/utils */"./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));var errors_1=__nested_webpack_require_309551__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var HandlerInterface_1=__nested_webpack_require_309551__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_309551__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_309551__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Chrome74');var NAME='Chrome74';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Chrome74=/*#__PURE__*/function(_HandlerInterface_1$H5){function Chrome74(){var _this53;_classCallCheck2(this,Chrome74);_this53=_callSuper(this,Chrome74);// Closed flag.
_this53._closed=false;// Map of RTCTransceivers indexed by MID.
_this53._mapMidTransceiver=new Map();// Local stream for sending.
_this53._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this53._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this53._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this53._transportReady=false;return _this53;}_inherits(Chrome74,_HandlerInterface_1$H5);return _createClass2(Chrome74,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee132(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee132$(_context141){while(1)switch(_context141.prev=_context141.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'});_context141.prev=2;pc.addTransceiver('audio');pc.addTransceiver('video');_context141.next=7;return pc.createOffer();case 7:offer=_context141.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});// libwebrtc supports NACK for OPUS but doesn't announce it.
ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);return _context141.abrupt("return",nativeRtpCapabilities);case 15:_context141.prev=15;_context141.t0=_context141["catch"](2);try{pc.close();}catch(error2){}throw _context141.t0;case 19:case"end":return _context141.stop();}},_callee132,null,[[2,15]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities5.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee133(){return _regeneratorRuntime2().wrap(function _callee133$(_context142){while(1)switch(_context142.prev=_context142.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context142.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context142.stop();}},_callee133);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities5.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref67){var _this54=this;var direction=_ref67.direction,iceParameters=_ref67.iceParameters,iceCandidates=_ref67.iceCandidates,dtlsParameters=_ref67.dtlsParameters,sctpParameters=_ref67.sctpParameters,iceServers=_ref67.iceServers,iceTransportPolicy=_ref67.iceTransportPolicy,additionalSettings=_ref67.additionalSettings,proprietaryConstraints=_ref67.proprietaryConstraints,extendedRtpCapabilities=_ref67.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this54.emit('@icegatheringstatechange',_this54._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this54.emit('@connectionstatechange',_this54._pc.connectionState);});}else{logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');this._pc.addEventListener('iceconnectionstatechange',function(){switch(_this54._pc.iceConnectionState){case'checking':{_this54.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this54.emit('@connectionstatechange','connected');break;}case'failed':{_this54.emit('@connectionstatechange','failed');break;}case'disconnected':{_this54.emit('@connectionstatechange','disconnected');break;}case'closed':{_this54.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee134(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee134$(_context143){while(1)switch(_context143.prev=_context143.next){case 0:this.assertNotClosed();logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 5:case"end":return _context143.stop();}},_callee134,this);}));function updateIceServers(_x111){return _updateIceServers6.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee135(iceParameters){var offer,answer,_offer5,_answer5;return _regeneratorRuntime2().wrap(function _callee135$(_context144){while(1)switch(_context144.prev=_context144.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context144.next=5;break;}return _context144.abrupt("return");case 5:if(!(this._direction==='send')){_context144.next=18;break;}_context144.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context144.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context144.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context144.next=16;return this._pc.setRemoteDescription(answer);case 16:_context144.next=28;break;case 18:_offer5={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer5);_context144.next=22;return this._pc.setRemoteDescription(_offer5);case 22:_context144.next=24;return this._pc.createAnswer();case 24:_answer5=_context144.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer5);_context144.next=28;return this._pc.setLocalDescription(_answer5);case 28:case"end":return _context144.stop();}},_callee135,this);}));function restartIce(_x112){return _restartIce6.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee136(){return _regeneratorRuntime2().wrap(function _callee136$(_context145){while(1)switch(_context145.prev=_context145.next){case 0:this.assertNotClosed();return _context145.abrupt("return",this._pc.getStats());case 2:case"end":return _context145.stop();}},_callee136,this);}));function getTransportStats(){return _getTransportStats5.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee137(_ref68){var track,encodings,codecOptions,codec,sendingRtpParameters,sendingRemoteRtpParameters,mediaSectionIdx,transceiver,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl17,hackVp9Svc,layers,localId,newEncodings,_iterator34,_step34,encoding,answer;return _regeneratorRuntime2().wrap(function _callee137$(_context146){while(1)switch(_context146.prev=_context146.next){case 0:track=_ref68.track,encodings=_ref68.encodings,codecOptions=_ref68.codecOptions,codec=_ref68.codec;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(encodings&&encodings.length>1){encodings.forEach(function(encoding,idx){encoding.rid="r".concat(idx);});}sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);mediaSectionIdx=this._remoteSdp.getNextMediaSectionIdx();transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream],sendEncodings:encodings});_context146.next=13;return this._pc.createOffer();case 13:offer=_context146.sent;localSdpObject=sdpTransform.parse(offer.sdp);if(this._transportReady){_context146.next=18;break;}_context146.next=18;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl17=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl17!==void 0?_this$_forcedLocalDtl17:'client',localSdpObject:localSdpObject});case 18:// Special case for VP9 with SVC.
hackVp9Svc=false;layers=(0,scalabilityModes_1.parse)((encodings!==null&&encodings!==void 0?encodings:[{}])[0].scalabilityMode);if(encodings&&encodings.length===1&&layers.spatialLayers>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp9'){logger.debug('send() | enabling legacy simulcast for VP9 SVC');hackVp9Svc=true;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];sdpUnifiedPlanUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,numStreams:layers.spatialLayers});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context146.next=24;return this._pc.setLocalDescription(offer);case 24:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings by parsing the SDP offer if no encodings are given.
if(!encodings){sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});}// Set RTP encodings by parsing the SDP offer and complete them with given
// one if just a single encoding has been given.
else if(encodings.length===1){newEncodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});Object.assign(newEncodings[0],encodings[0]);// Hack for VP9 SVC.
if(hackVp9Svc){newEncodings=[newEncodings[0]];}sendingRtpParameters.encodings=newEncodings;}// Otherwise if more than 1 encoding are given use them verbatim.
else{sendingRtpParameters.encodings=encodings;}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator34=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator34.s();!(_step34=_iterator34.n()).done;){encoding=_step34.value;if(encoding.scalabilityMode){encoding.scalabilityMode="L1T".concat(layers.temporalLayers);}else{encoding.scalabilityMode='L1T3';}}}catch(err){_iterator34.e(err);}finally{_iterator34.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,reuseMid:mediaSectionIdx.reuseMid,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions,extmapAllowMixed:true});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context146.next=36;return this._pc.setRemoteDescription(answer);case 36:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context146.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 38:case"end":return _context146.stop();}},_callee137,this);}));function send(_x113){return _send5.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee138(localId){var transceiver,mediaSectionClosed,offer,answer;return _regeneratorRuntime2().wrap(function _callee138$(_context147){while(1)switch(_context147.prev=_context147.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);if(!this._closed){_context147.next=4;break;}return _context147.abrupt("return");case 4:transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context147.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:void transceiver.sender.replaceTrack(null);this._pc.removeTrack(transceiver.sender);mediaSectionClosed=this._remoteSdp.closeMediaSection(transceiver.mid);if(mediaSectionClosed){try{transceiver.stop();}catch(error){}}_context147.next=13;return this._pc.createOffer();case 13:offer=_context147.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context147.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context147.next=21;return this._pc.setRemoteDescription(answer);case 21:this._mapMidTransceiver["delete"](localId);case 22:case"end":return _context147.stop();}},_callee138,this);}));function stopSending(_x114){return _stopSending5.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee139(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee139$(_context148){while(1)switch(_context148.prev=_context148.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context148.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context148.next=10;return this._pc.createOffer();case 10:offer=_context148.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context148.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context148.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context148.stop();}},_callee139,this);}));function pauseSending(_x115){return _pauseSending5.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee140(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee140$(_context149){while(1)switch(_context149.prev=_context149.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);this._remoteSdp.resumeSendingMediaSection(localId);if(transceiver){_context149.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:transceiver.direction='sendonly';_context149.next=10;return this._pc.createOffer();case 10:offer=_context149.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context149.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context149.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context149.stop();}},_callee140,this);}));function resumeSending(_x116){return _resumeSending5.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee141(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee141$(_context150){while(1)switch(_context150.prev=_context150.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context150.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context150.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context150.stop();}},_callee141,this);}));function replaceTrack(_x117,_x118){return _replaceTrack6.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee142(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee142$(_context151){while(1)switch(_context151.prev=_context151.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context151.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context151.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context151.next=13;return this._pc.createOffer();case 13:offer=_context151.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context151.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context151.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context151.stop();}},_callee142,this);}));function setMaxSpatialLayer(_x119,_x120){return _setMaxSpatialLayer6.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee143(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee143$(_context152){while(1)switch(_context152.prev=_context152.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context152.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context152.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context152.next=13;return this._pc.createOffer();case 13:offer=_context152.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context152.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context152.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context152.stop();}},_callee143,this);}));function setRtpEncodingParameters(_x121,_x122){return _setRtpEncodingParameters6.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee144(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee144$(_context153){while(1)switch(_context153.prev=_context153.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context153.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context153.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context153.stop();}},_callee144,this);}));function getSenderStats(_x123){return _getSenderStats5.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee145(_ref69){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl18,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee145$(_context154){while(1)switch(_context154.prev=_context154.next){case 0:ordered=_ref69.ordered,maxPacketLifeTime=_ref69.maxPacketLifeTime,maxRetransmits=_ref69.maxRetransmits,label=_ref69.label,protocol=_ref69.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context154.next=25;break;}_context154.next=10;return this._pc.createOffer();case 10:offer=_context154.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context154.next=16;break;}_context154.next=16;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl18=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl18!==void 0?_this$_forcedLocalDtl18:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context154.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context154.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context154.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context154.stop();}},_callee145,this);}));function sendDataChannel(_x124){return _sendDataChannel5.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee146(optionsList){var _this55=this;var results,mapLocalId,_iterator35,_step35,_rtpParameters$mid3,options,trackId,kind,rtpParameters,streamId,localId,offer,answer,localSdpObject,_iterator36,_step36,_loop10,_this$_forcedLocalDtl19,_iterator37,_step37,_loop11;return _regeneratorRuntime2().wrap(function _callee146$(_context157){while(1)switch(_context157.prev=_context157.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator35=_createForOfIteratorHelper(optionsList);try{for(_iterator35.s();!(_step35=_iterator35.n()).done;){options=_step35.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid3=rtpParameters.mid)!==null&&_rtpParameters$mid3!==void 0?_rtpParameters$mid3:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator35.e(err);}finally{_iterator35.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context157.next=10;return this._pc.setRemoteDescription(offer);case 10:_context157.next=12;return this._pc.createAnswer();case 12:answer=_context157.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator36=_createForOfIteratorHelper(optionsList);_context157.prev=15;_loop10=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop10(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop10$(_context155){while(1)switch(_context155.prev=_context155.next){case 0:options=_step36.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context155.stop();}},_loop10);});_iterator36.s();case 18:if((_step36=_iterator36.n()).done){_context157.next=22;break;}return _context157.delegateYield(_loop10(),"t0",20);case 20:_context157.next=18;break;case 22:_context157.next=27;break;case 24:_context157.prev=24;_context157.t1=_context157["catch"](15);_iterator36.e(_context157.t1);case 27:_context157.prev=27;_iterator36.f();return _context157.finish(27);case 30:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context157.next=34;break;}_context157.next=34;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl19=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl19!==void 0?_this$_forcedLocalDtl19:'client',localSdpObject:localSdpObject});case 34:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context157.next=37;return this._pc.setLocalDescription(answer);case 37:_iterator37=_createForOfIteratorHelper(optionsList);_context157.prev=38;_loop11=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop11(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop11$(_context156){while(1)switch(_context156.prev=_context156.next){case 0:options=_step37.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this55._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context156.next=8;break;}throw new Error('new RTCRtpTransceiver not found');case 8:// Store in the map.
_this55._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 10:case"end":return _context156.stop();}},_loop11);});_iterator37.s();case 41:if((_step37=_iterator37.n()).done){_context157.next=45;break;}return _context157.delegateYield(_loop11(),"t2",43);case 43:_context157.next=41;break;case 45:_context157.next=50;break;case 47:_context157.prev=47;_context157.t3=_context157["catch"](38);_iterator37.e(_context157.t3);case 50:_context157.prev=50;_iterator37.f();return _context157.finish(50);case 53:return _context157.abrupt("return",results);case 54:case"end":return _context157.stop();}},_callee146,this,[[15,24,27,30],[38,47,50,53]]);}));function receive(_x125){return _receive5.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee147(localIds){var _iterator38,_step38,localId,transceiver,offer,answer,_iterator39,_step39,_localId4;return _regeneratorRuntime2().wrap(function _callee147$(_context158){while(1)switch(_context158.prev=_context158.next){case 0:this.assertRecvDirection();if(!this._closed){_context158.next=3;break;}return _context158.abrupt("return");case 3:_iterator38=_createForOfIteratorHelper(localIds);_context158.prev=4;_iterator38.s();case 6:if((_step38=_iterator38.n()).done){_context158.next=15;break;}localId=_step38.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context158.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context158.next=6;break;case 15:_context158.next=20;break;case 17:_context158.prev=17;_context158.t0=_context158["catch"](4);_iterator38.e(_context158.t0);case 20:_context158.prev=20;_iterator38.f();return _context158.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context158.next=27;return this._pc.setRemoteDescription(offer);case 27:_context158.next=29;return this._pc.createAnswer();case 29:answer=_context158.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context158.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator39=_createForOfIteratorHelper(localIds);try{for(_iterator39.s();!(_step39=_iterator39.n()).done;){_localId4=_step39.value;this._mapMidTransceiver["delete"](_localId4);}}catch(err){_iterator39.e(err);}finally{_iterator39.f();}case 35:case"end":return _context158.stop();}},_callee147,this,[[4,17,20,23]]);}));function stopReceiving(_x126){return _stopReceiving5.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee148(localIds){var _iterator40,_step40,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee148$(_context159){while(1)switch(_context159.prev=_context159.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator40=_createForOfIteratorHelper(localIds);_context159.prev=3;_iterator40.s();case 5:if((_step40=_iterator40.n()).done){_context159.next=15;break;}localId=_step40.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context159.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context159.next=5;break;case 15:_context159.next=20;break;case 17:_context159.prev=17;_context159.t0=_context159["catch"](3);_iterator40.e(_context159.t0);case 20:_context159.prev=20;_iterator40.f();return _context159.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context159.next=27;return this._pc.setRemoteDescription(offer);case 27:_context159.next=29;return this._pc.createAnswer();case 29:answer=_context159.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context159.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context159.stop();}},_callee148,this,[[3,17,20,23]]);}));function pauseReceiving(_x127){return _pauseReceiving5.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee149(localIds){var _iterator41,_step41,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee149$(_context160){while(1)switch(_context160.prev=_context160.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator41=_createForOfIteratorHelper(localIds);_context160.prev=3;_iterator41.s();case 5:if((_step41=_iterator41.n()).done){_context160.next=15;break;}localId=_step41.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context160.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context160.next=5;break;case 15:_context160.next=20;break;case 17:_context160.prev=17;_context160.t0=_context160["catch"](3);_iterator41.e(_context160.t0);case 20:_context160.prev=20;_iterator41.f();return _context160.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context160.next=27;return this._pc.setRemoteDescription(offer);case 27:_context160.next=29;return this._pc.createAnswer();case 29:answer=_context160.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context160.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context160.stop();}},_callee149,this,[[3,17,20,23]]);}));function resumeReceiving(_x128){return _resumeReceiving5.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee150(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee150$(_context161){while(1)switch(_context161.prev=_context161.next){case 0:this.assertNotClosed();this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context161.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context161.abrupt("return",transceiver.receiver.getStats());case 6:case"end":return _context161.stop();}},_callee150,this);}));function getReceiverStats(_x129){return _getReceiverStats5.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee151(_ref70){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl20,localSdpObject;return _regeneratorRuntime2().wrap(function _callee151$(_context162){while(1)switch(_context162.prev=_context162.next){case 0:sctpStreamParameters=_ref70.sctpStreamParameters,label=_ref70.label,protocol=_ref70.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context162.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context162.next=13;return this._pc.setRemoteDescription(offer);case 13:_context162.next=15;return this._pc.createAnswer();case 15:answer=_context162.sent;if(this._transportReady){_context162.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context162.next=20;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl20=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl20!==void 0?_this$_forcedLocalDtl20:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context162.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context162.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context162.stop();}},_callee151,this);}));function receiveDataChannel(_x130){return _receiveDataChannel5.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport5=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee152(_ref71){var _this56=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee152$(_context163){while(1)switch(_context163.prev=_context163.next){case 0:localDtlsRole=_ref71.localDtlsRole,localSdpObject=_ref71.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context163.next=7;return new Promise(function(resolve,reject){_this56.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context163.stop();}},_callee152,this);}));function setupTransport(_x131){return _setupTransport5.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Chrome74();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Chrome74=Chrome74;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Edge11.js":(/*!**************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \**************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Edge11Js(__unused_webpack_module,exports,__nested_webpack_require_352043__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Edge11=void 0;var Logger_1=__nested_webpack_require_352043__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var errors_1=__nested_webpack_require_352043__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_352043__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_352043__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var edgeUtils=__importStar(__nested_webpack_require_352043__(/*! ./ortc/edgeUtils */"./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"));var HandlerInterface_1=__nested_webpack_require_352043__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var logger=new Logger_1.Logger('Edge11');var NAME='Edge11';var Edge11=/*#__PURE__*/function(_HandlerInterface_1$H6){function Edge11(){var _this57;_classCallCheck2(this,Edge11);_this57=_callSuper(this,Edge11);// Map of RTCRtpSenders indexed by id.
_this57._rtpSenders=new Map();// Map of RTCRtpReceivers indexed by id.
_this57._rtpReceivers=new Map();// Next localId for sending tracks.
_this57._nextSendLocalId=0;// Got transport local and remote parameters.
_this57._transportReady=false;return _this57;}_inherits(Edge11,_HandlerInterface_1$H6);return _createClass2(Edge11,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Close the ICE gatherer.
// NOTE: Not yet implemented by Edge.
try{this._iceGatherer.close();}catch(error){}// Close the ICE transport.
try{this._iceTransport.stop();}catch(error){}// Close the DTLS transport.
try{this._dtlsTransport.stop();}catch(error){}// Close RTCRtpSenders.
var _iterator42=_createForOfIteratorHelper(this._rtpSenders.values()),_step42;try{for(_iterator42.s();!(_step42=_iterator42.n()).done;){var rtpSender=_step42.value;try{rtpSender.stop();}catch(error){}}// Close RTCRtpReceivers.
}catch(err){_iterator42.e(err);}finally{_iterator42.f();}var _iterator43=_createForOfIteratorHelper(this._rtpReceivers.values()),_step43;try{for(_iterator43.s();!(_step43=_iterator43.n()).done;){var rtpReceiver=_step43.value;try{rtpReceiver.stop();}catch(error){}}}catch(err){_iterator43.e(err);}finally{_iterator43.f();}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee153(){return _regeneratorRuntime2().wrap(function _callee153$(_context164){while(1)switch(_context164.prev=_context164.next){case 0:logger.debug('getNativeRtpCapabilities()');return _context164.abrupt("return",edgeUtils.getCapabilities());case 2:case"end":return _context164.stop();}},_callee153);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities6.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee154(){return _regeneratorRuntime2().wrap(function _callee154$(_context165){while(1)switch(_context165.prev=_context165.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context165.abrupt("return",{numStreams:{OS:0,MIS:0}});case 2:case"end":return _context165.stop();}},_callee154);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities6.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref72){var direction=_ref72.direction,iceParameters=_ref72.iceParameters,iceCandidates=_ref72.iceCandidates,dtlsParameters=_ref72.dtlsParameters,sctpParameters=_ref72.sctpParameters,iceServers=_ref72.iceServers,iceTransportPolicy=_ref72.iceTransportPolicy,additionalSettings=_ref72.additionalSettings,proprietaryConstraints=_ref72.proprietaryConstraints,extendedRtpCapabilities=_ref72.extendedRtpCapabilities;logger.debug('run()');this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._remoteIceParameters=iceParameters;this._remoteIceCandidates=iceCandidates;this._remoteDtlsParameters=dtlsParameters;this._cname="CNAME-".concat(utils.generateRandomNumber());this.setIceGatherer({iceServers:iceServers,iceTransportPolicy:iceTransportPolicy});this.setIceTransport();this.setDtlsTransport();}// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"updateIceServers",value:function(){var _updateIceServers7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee155(iceServers){return _regeneratorRuntime2().wrap(function _callee155$(_context166){while(1)switch(_context166.prev=_context166.next){case 0:throw new errors_1.UnsupportedError('not supported');case 1:case"end":return _context166.stop();}},_callee155);}));function updateIceServers(_x132){return _updateIceServers7.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee156(iceParameters){var _iterator44,_step44,candidate;return _regeneratorRuntime2().wrap(function _callee156$(_context167){while(1)switch(_context167.prev=_context167.next){case 0:logger.debug('restartIce()');this._remoteIceParameters=iceParameters;if(this._transportReady){_context167.next=4;break;}return _context167.abrupt("return");case 4:logger.debug('restartIce() | calling iceTransport.start()');this._iceTransport.start(this._iceGatherer,iceParameters,'controlling');_iterator44=_createForOfIteratorHelper(this._remoteIceCandidates);try{for(_iterator44.s();!(_step44=_iterator44.n()).done;){candidate=_step44.value;this._iceTransport.addRemoteCandidate(candidate);}}catch(err){_iterator44.e(err);}finally{_iterator44.f();}this._iceTransport.addRemoteCandidate({});case 9:case"end":return _context167.stop();}},_callee156,this);}));function restartIce(_x133){return _restartIce7.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee157(){return _regeneratorRuntime2().wrap(function _callee157$(_context168){while(1)switch(_context168.prev=_context168.next){case 0:return _context168.abrupt("return",this._iceTransport.getStats());case 1:case"end":return _context168.stop();}},_callee157,this);}));function getTransportStats(){return _getTransportStats6.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee158(// eslint-disable-next-line @typescript-eslint/no-unused-vars
_ref73){var track,encodings,codecOptions,codec,rtpSender,rtpParameters,useRtx,_iterator45,_step45,encoding,edgeRtpParameters,localId;return _regeneratorRuntime2().wrap(function _callee158$(_context169){while(1)switch(_context169.prev=_context169.next){case 0:track=_ref73.track,encodings=_ref73.encodings,codecOptions=_ref73.codecOptions,codec=_ref73.codec;logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(this._transportReady){_context169.next=5;break;}_context169.next=5;return this.setupTransport({localDtlsRole:'server'});case 5:logger.debug('send() | calling new RTCRtpSender()');rtpSender=new RTCRtpSender(track,this._dtlsTransport);rtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);rtpParameters.codecs=ortc.reduceCodecs(rtpParameters.codecs,codec);useRtx=rtpParameters.codecs.some(function(_codec){return /.+\/rtx$/i.test(_codec.mimeType);});if(!encodings){encodings=[{}];}_iterator45=_createForOfIteratorHelper(encodings);try{for(_iterator45.s();!(_step45=_iterator45.n()).done;){encoding=_step45.value;encoding.ssrc=utils.generateRandomNumber();if(useRtx){encoding.rtx={ssrc:utils.generateRandomNumber()};}}}catch(err){_iterator45.e(err);}finally{_iterator45.f();}rtpParameters.encodings=encodings;// Fill RTCRtpParameters.rtcp.
rtpParameters.rtcp={cname:this._cname,reducedSize:true,mux:true};// NOTE: Convert our standard RTCRtpParameters into those that Edge
// expects.
edgeRtpParameters=edgeUtils.mangleRtpParameters(rtpParameters);logger.debug('send() | calling rtpSender.send() [params:%o]',edgeRtpParameters);_context169.next=19;return rtpSender.send(edgeRtpParameters);case 19:localId=String(this._nextSendLocalId);this._nextSendLocalId++;// Store it.
this._rtpSenders.set(localId,rtpSender);return _context169.abrupt("return",{localId:localId,rtpParameters:rtpParameters,rtpSender:rtpSender});case 23:case"end":return _context169.stop();}},_callee158,this);}));function send(_x134){return _send6.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee159(localId){var rtpSender;return _regeneratorRuntime2().wrap(function _callee159$(_context170){while(1)switch(_context170.prev=_context170.next){case 0:logger.debug('stopSending() [localId:%s]',localId);rtpSender=this._rtpSenders.get(localId);if(rtpSender){_context170.next=4;break;}throw new Error('RTCRtpSender not found');case 4:this._rtpSenders["delete"](localId);_context170.prev=5;logger.debug('stopSending() | calling rtpSender.stop()');rtpSender.stop();_context170.next=14;break;case 10:_context170.prev=10;_context170.t0=_context170["catch"](5);logger.warn('stopSending() | rtpSender.stop() failed:%o',_context170.t0);throw _context170.t0;case 14:case"end":return _context170.stop();}},_callee159,this,[[5,10]]);}));function stopSending(_x135){return _stopSending6.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee160(localId){return _regeneratorRuntime2().wrap(function _callee160$(_context171){while(1)switch(_context171.prev=_context171.next){case 0:case"end":return _context171.stop();}},_callee160);}));function pauseSending(_x136){return _pauseSending6.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee161(localId){return _regeneratorRuntime2().wrap(function _callee161$(_context172){while(1)switch(_context172.prev=_context172.next){case 0:case"end":return _context172.stop();}},_callee161);}));function resumeSending(_x137){return _resumeSending6.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee162(localId,track){var rtpSender;return _regeneratorRuntime2().wrap(function _callee162$(_context173){while(1)switch(_context173.prev=_context173.next){case 0:if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}rtpSender=this._rtpSenders.get(localId);if(rtpSender){_context173.next=4;break;}throw new Error('RTCRtpSender not found');case 4:rtpSender.setTrack(track);case 5:case"end":return _context173.stop();}},_callee162,this);}));function replaceTrack(_x138,_x139){return _replaceTrack7.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee163(localId,spatialLayer){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee163$(_context174){while(1)switch(_context174.prev=_context174.next){case 0:logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);rtpSender=this._rtpSenders.get(localId);if(rtpSender){_context174.next=4;break;}throw new Error('RTCRtpSender not found');case 4:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context174.next=8;return rtpSender.setParameters(parameters);case 8:case"end":return _context174.stop();}},_callee163,this);}));function setMaxSpatialLayer(_x140,_x141){return _setMaxSpatialLayer7.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee164(localId,params){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee164$(_context175){while(1)switch(_context175.prev=_context175.next){case 0:logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);rtpSender=this._rtpSenders.get(localId);if(rtpSender){_context175.next=4;break;}throw new Error('RTCRtpSender not found');case 4:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context175.next=8;return rtpSender.setParameters(parameters);case 8:case"end":return _context175.stop();}},_callee164,this);}));function setRtpEncodingParameters(_x142,_x143){return _setRtpEncodingParameters7.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee165(localId){var rtpSender;return _regeneratorRuntime2().wrap(function _callee165$(_context176){while(1)switch(_context176.prev=_context176.next){case 0:rtpSender=this._rtpSenders.get(localId);if(rtpSender){_context176.next=3;break;}throw new Error('RTCRtpSender not found');case 3:return _context176.abrupt("return",rtpSender.getStats());case 4:case"end":return _context176.stop();}},_callee165,this);}));function getSenderStats(_x144){return _getSenderStats6.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee166(// eslint-disable-next-line @typescript-eslint/no-unused-vars
options){return _regeneratorRuntime2().wrap(function _callee166$(_context177){while(1)switch(_context177.prev=_context177.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context177.stop();}},_callee166);}));function sendDataChannel(_x145){return _sendDataChannel6.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee167(optionsList){var results,_iterator46,_step46,options,trackId,kind,_iterator47,_step47,_options,_trackId,_kind2,rtpParameters,rtpReceiver,edgeRtpParameters,localId;return _regeneratorRuntime2().wrap(function _callee167$(_context178){while(1)switch(_context178.prev=_context178.next){case 0:results=[];_iterator46=_createForOfIteratorHelper(optionsList);try{for(_iterator46.s();!(_step46=_iterator46.n()).done;){options=_step46.value;trackId=options.trackId,kind=options.kind;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);}}catch(err){_iterator46.e(err);}finally{_iterator46.f();}if(this._transportReady){_context178.next=6;break;}_context178.next=6;return this.setupTransport({localDtlsRole:'server'});case 6:_iterator47=_createForOfIteratorHelper(optionsList);_context178.prev=7;_iterator47.s();case 9:if((_step47=_iterator47.n()).done){_context178.next=24;break;}_options=_step47.value;_trackId=_options.trackId,_kind2=_options.kind,rtpParameters=_options.rtpParameters;logger.debug('receive() | calling new RTCRtpReceiver()');rtpReceiver=new RTCRtpReceiver(this._dtlsTransport,_kind2);rtpReceiver.addEventListener('error',function(event){logger.error('rtpReceiver "error" event [event:%o]',event);});// NOTE: Convert our standard RTCRtpParameters into those that Edge
// expects.
edgeRtpParameters=edgeUtils.mangleRtpParameters(rtpParameters);logger.debug('receive() | calling rtpReceiver.receive() [params:%o]',edgeRtpParameters);_context178.next=19;return rtpReceiver.receive(edgeRtpParameters);case 19:localId=_trackId;// Store it.
this._rtpReceivers.set(localId,rtpReceiver);results.push({localId:localId,track:rtpReceiver.track,rtpReceiver:rtpReceiver});case 22:_context178.next=9;break;case 24:_context178.next=29;break;case 26:_context178.prev=26;_context178.t0=_context178["catch"](7);_iterator47.e(_context178.t0);case 29:_context178.prev=29;_iterator47.f();return _context178.finish(29);case 32:return _context178.abrupt("return",results);case 33:case"end":return _context178.stop();}},_callee167,this,[[7,26,29,32]]);}));function receive(_x146){return _receive6.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee168(localIds){var _iterator48,_step48,localId,rtpReceiver;return _regeneratorRuntime2().wrap(function _callee168$(_context179){while(1)switch(_context179.prev=_context179.next){case 0:_iterator48=_createForOfIteratorHelper(localIds);_context179.prev=1;_iterator48.s();case 3:if((_step48=_iterator48.n()).done){_context179.next=13;break;}localId=_step48.value;logger.debug('stopReceiving() [localId:%s]',localId);rtpReceiver=this._rtpReceivers.get(localId);if(rtpReceiver){_context179.next=9;break;}throw new Error('RTCRtpReceiver not found');case 9:this._rtpReceivers["delete"](localId);try{logger.debug('stopReceiving() | calling rtpReceiver.stop()');rtpReceiver.stop();}catch(error){logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o',error);}case 11:_context179.next=3;break;case 13:_context179.next=18;break;case 15:_context179.prev=15;_context179.t0=_context179["catch"](1);_iterator48.e(_context179.t0);case 18:_context179.prev=18;_iterator48.f();return _context179.finish(18);case 21:case"end":return _context179.stop();}},_callee168,this,[[1,15,18,21]]);}));function stopReceiving(_x147){return _stopReceiving6.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee169(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee169$(_context180){while(1)switch(_context180.prev=_context180.next){case 0:case"end":return _context180.stop();}},_callee169);}));function pauseReceiving(_x148){return _pauseReceiving6.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee170(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee170$(_context181){while(1)switch(_context181.prev=_context181.next){case 0:case"end":return _context181.stop();}},_callee170);}));function resumeReceiving(_x149){return _resumeReceiving6.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee171(localId){var rtpReceiver;return _regeneratorRuntime2().wrap(function _callee171$(_context182){while(1)switch(_context182.prev=_context182.next){case 0:rtpReceiver=this._rtpReceivers.get(localId);if(rtpReceiver){_context182.next=3;break;}throw new Error('RTCRtpReceiver not found');case 3:return _context182.abrupt("return",rtpReceiver.getStats());case 4:case"end":return _context182.stop();}},_callee171,this);}));function getReceiverStats(_x150){return _getReceiverStats6.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee172(// eslint-disable-next-line @typescript-eslint/no-unused-vars
options){return _regeneratorRuntime2().wrap(function _callee172$(_context183){while(1)switch(_context183.prev=_context183.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context183.stop();}},_callee172);}));function receiveDataChannel(_x151){return _receiveDataChannel6.apply(this,arguments);}return receiveDataChannel;}()},{key:"setIceGatherer",value:function setIceGatherer(_ref74){var iceServers=_ref74.iceServers,iceTransportPolicy=_ref74.iceTransportPolicy;// @ts-expect-error --- On purpose
var iceGatherer=new RTCIceGatherer({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],gatherPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all'});iceGatherer.addEventListener('error',function(event){logger.error('iceGatherer "error" event [event:%o]',event);});// NOTE: Not yet implemented by Edge, which starts gathering automatically.
try{iceGatherer.gather();}catch(error){logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s',error.toString());}this._iceGatherer=iceGatherer;}},{key:"setIceTransport",value:function setIceTransport(){var _this58=this;var iceTransport=new RTCIceTransport(this._iceGatherer);// NOTE: Not yet implemented by Edge.
iceTransport.addEventListener('statechange',function(){switch(iceTransport.state){case'checking':{_this58.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this58.emit('@connectionstatechange','connected');break;}case'failed':{_this58.emit('@connectionstatechange','failed');break;}case'disconnected':{_this58.emit('@connectionstatechange','disconnected');break;}case'closed':{_this58.emit('@connectionstatechange','closed');break;}}});// NOTE: Not standard, but implemented by Edge.
iceTransport.addEventListener('icestatechange',function(){switch(iceTransport.state){case'checking':{_this58.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this58.emit('@connectionstatechange','connected');break;}case'failed':{_this58.emit('@connectionstatechange','failed');break;}case'disconnected':{_this58.emit('@connectionstatechange','disconnected');break;}case'closed':{_this58.emit('@connectionstatechange','closed');break;}}});iceTransport.addEventListener('candidatepairchange',function(event){logger.debug('iceTransport "candidatepairchange" event [pair:%o]',event.pair);});this._iceTransport=iceTransport;}},{key:"setDtlsTransport",value:function setDtlsTransport(){var _this59=this;var dtlsTransport=new RTCDtlsTransport(this._iceTransport);// NOTE: Not yet implemented by Edge.
dtlsTransport.addEventListener('statechange',function(){logger.debug('dtlsTransport "statechange" event [state:%s]',dtlsTransport.state);});// NOTE: Not standard, but implemented by Edge.
dtlsTransport.addEventListener('dtlsstatechange',function(){logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]',dtlsTransport.state);if(dtlsTransport.state==='closed'){_this59.emit('@connectionstatechange','closed');}});dtlsTransport.addEventListener('error',function(event){logger.error('dtlsTransport "error" event [event:%o]',event);});this._dtlsTransport=dtlsTransport;}},{key:"setupTransport",value:function(){var _setupTransport6=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee173(_ref75){var _this60=this;var localDtlsRole,dtlsParameters,_iterator49,_step49,candidate;return _regeneratorRuntime2().wrap(function _callee173$(_context184){while(1)switch(_context184.prev=_context184.next){case 0:localDtlsRole=_ref75.localDtlsRole;logger.debug('setupTransport()');// Get our local DTLS parameters.
dtlsParameters=this._dtlsTransport.getLocalParameters();dtlsParameters.role=localDtlsRole;// Need to tell the remote transport about our parameters.
_context184.next=6;return new Promise(function(resolve,reject){_this60.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 6:// Start the RTCIceTransport.
this._iceTransport.start(this._iceGatherer,this._remoteIceParameters,'controlling');// Add remote ICE candidates.
_iterator49=_createForOfIteratorHelper(this._remoteIceCandidates);try{for(_iterator49.s();!(_step49=_iterator49.n()).done;){candidate=_step49.value;this._iceTransport.addRemoteCandidate(candidate);}// Also signal a 'complete' candidate as per spec.
// NOTE: It should be {complete: true} but Edge prefers {}.
// NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
// won't enter the 'completed' state.
}catch(err){_iterator49.e(err);}finally{_iterator49.f();}this._iceTransport.addRemoteCandidate({});// NOTE: Edge does not like SHA less than 256.
this._remoteDtlsParameters.fingerprints=this._remoteDtlsParameters.fingerprints.filter(function(fingerprint){return fingerprint.algorithm==='sha-256'||fingerprint.algorithm==='sha-384'||fingerprint.algorithm==='sha-512';});// Start the RTCDtlsTransport.
this._dtlsTransport.start(this._remoteDtlsParameters);this._transportReady=true;case 13:case"end":return _context184.stop();}},_callee173,this);}));function setupTransport(_x152){return _setupTransport6.apply(this,arguments);}return setupTransport;}()}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Edge11();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Edge11=Edge11;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Firefox120.js":(/*!******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox120.js ***!
  \******************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Firefox120Js(__unused_webpack_module,exports,__nested_webpack_require_378665__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Firefox120=void 0;var sdpTransform=__importStar(__nested_webpack_require_378665__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_378665__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var errors_1=__nested_webpack_require_378665__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_378665__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_378665__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_378665__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_378665__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var HandlerInterface_1=__nested_webpack_require_378665__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_378665__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_378665__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Firefox120');var NAME='Firefox120';var SCTP_NUM_STREAMS={OS:16,MIS:2048};var Firefox120=/*#__PURE__*/function(_HandlerInterface_1$H7){function Firefox120(){var _this61;_classCallCheck2(this,Firefox120);_this61=_callSuper(this,Firefox120);// Closed flag.
_this61._closed=false;// Map of RTCTransceivers indexed by MID.
_this61._mapMidTransceiver=new Map();// Local stream for sending.
_this61._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this61._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this61._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this61._transportReady=false;return _this61;}_inherits(Firefox120,_HandlerInterface_1$H7);return _createClass2(Firefox120,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee174(){var pc,canvas,fakeStream,fakeVideoTrack,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee174$(_context185){while(1)switch(_context185.prev=_context185.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'});// NOTE: We need to add a real video track to get the RID extension mapping,
// otherwiser Firefox doesn't include it in the SDP.
canvas=document.createElement('canvas');// NOTE: Otherwise Firefox fails in next line.
canvas.getContext('2d');fakeStream=canvas.captureStream();fakeVideoTrack=fakeStream.getVideoTracks()[0];_context185.prev=6;pc.addTransceiver('audio',{direction:'sendrecv'});pc.addTransceiver(fakeVideoTrack,{direction:'sendrecv',sendEncodings:[{rid:'r0',maxBitrate:100000},{rid:'r1',maxBitrate:500000}]});_context185.next=11;return pc.createOffer();case 11:offer=_context185.sent;try{canvas.remove();}catch(error){}try{fakeVideoTrack.stop();}catch(error){}try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context185.abrupt("return",nativeRtpCapabilities);case 20:_context185.prev=20;_context185.t0=_context185["catch"](6);try{canvas.remove();}catch(error2){}try{fakeVideoTrack.stop();}catch(error2){}try{pc.close();}catch(error2){}throw _context185.t0;case 26:case"end":return _context185.stop();}},_callee174,null,[[6,20]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities7.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee175(){return _regeneratorRuntime2().wrap(function _callee175$(_context186){while(1)switch(_context186.prev=_context186.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context186.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context186.stop();}},_callee175);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities7.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref76){var _this62=this;var direction=_ref76.direction,iceParameters=_ref76.iceParameters,iceCandidates=_ref76.iceCandidates,dtlsParameters=_ref76.dtlsParameters,sctpParameters=_ref76.sctpParameters,iceServers=_ref76.iceServers,iceTransportPolicy=_ref76.iceTransportPolicy,additionalSettings=_ref76.additionalSettings,proprietaryConstraints=_ref76.proprietaryConstraints,extendedRtpCapabilities=_ref76.extendedRtpCapabilities;this.assertNotClosed();logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this62.emit('@icegatheringstatechange',_this62._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this62.emit('@connectionstatechange',_this62._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this62._pc.iceConnectionState){case'checking':{_this62.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this62.emit('@connectionstatechange','connected');break;}case'failed':{_this62.emit('@connectionstatechange','failed');break;}case'disconnected':{_this62.emit('@connectionstatechange','disconnected');break;}case'closed':{_this62.emit('@connectionstatechange','closed');break;}}});}}// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"updateIceServers",value:function(){var _updateIceServers8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee176(iceServers){return _regeneratorRuntime2().wrap(function _callee176$(_context187){while(1)switch(_context187.prev=_context187.next){case 0:this.assertNotClosed();// NOTE: Firefox does not implement pc.setConfiguration().
throw new errors_1.UnsupportedError('not supported');case 2:case"end":return _context187.stop();}},_callee176,this);}));function updateIceServers(_x153){return _updateIceServers8.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee177(iceParameters){var offer,answer,_offer6,_answer6;return _regeneratorRuntime2().wrap(function _callee177$(_context188){while(1)switch(_context188.prev=_context188.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context188.next=5;break;}return _context188.abrupt("return");case 5:if(!(this._direction==='send')){_context188.next=18;break;}_context188.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context188.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context188.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context188.next=16;return this._pc.setRemoteDescription(answer);case 16:_context188.next=28;break;case 18:_offer6={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer6);_context188.next=22;return this._pc.setRemoteDescription(_offer6);case 22:_context188.next=24;return this._pc.createAnswer();case 24:_answer6=_context188.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer6);_context188.next=28;return this._pc.setLocalDescription(_answer6);case 28:case"end":return _context188.stop();}},_callee177,this);}));function restartIce(_x154){return _restartIce8.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee178(){return _regeneratorRuntime2().wrap(function _callee178$(_context189){while(1)switch(_context189.prev=_context189.next){case 0:this.assertNotClosed();return _context189.abrupt("return",this._pc.getStats());case 2:case"end":return _context189.stop();}},_callee178,this);}));function getTransportStats(){return _getTransportStats7.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee179(_ref77){var track,encodings,codecOptions,codec,onRtpSender,sendingRtpParameters,sendingRemoteRtpParameters,transceiver,offer,localSdpObject,layers,localId,offerMediaObject,newEncodings,_iterator50,_step50,encoding,answer;return _regeneratorRuntime2().wrap(function _callee179$(_context190){while(1)switch(_context190.prev=_context190.next){case 0:track=_ref77.track,encodings=_ref77.encodings,codecOptions=_ref77.codecOptions,codec=_ref77.codec,onRtpSender=_ref77.onRtpSender;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(encodings&&encodings.length>1){encodings.forEach(function(encoding,idx){encoding.rid="r".concat(idx);});}sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);// NOTE: Firefox fails sometimes to properly anticipate the closed media
// section that it should use, so don't reuse closed media sections.
//   https://github.com/versatica/mediasoup-client/issues/104
//
// const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream],sendEncodings:encodings});if(onRtpSender){onRtpSender(transceiver.sender);}_context190.next=13;return this._pc.createOffer();case 13:offer=_context190.sent;localSdpObject=sdpTransform.parse(offer.sdp);// In Firefox use DTLS role client even if we are the "offerer" since
// Firefox does not respect ICE-Lite.
if(this._transportReady){_context190.next=18;break;}_context190.next=18;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 18:layers=(0,scalabilityModes_1.parse)((encodings!==null&&encodings!==void 0?encodings:[{}])[0].scalabilityMode);logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context190.next=22;return this._pc.setLocalDescription(offer);case 22:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[localSdpObject.media.length-1];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings by parsing the SDP offer if no encodings are given.
if(!encodings){sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});}// Set RTP encodings by parsing the SDP offer and complete them with given
// one if just a single encoding has been given.
else if(encodings.length===1){newEncodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});Object.assign(newEncodings[0],encodings[0]);sendingRtpParameters.encodings=newEncodings;}// Otherwise if more than 1 encoding are given use them verbatim.
else{sendingRtpParameters.encodings=encodings;}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator50=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator50.s();!(_step50=_iterator50.n()).done;){encoding=_step50.value;if(encoding.scalabilityMode){encoding.scalabilityMode="L1T".concat(layers.temporalLayers);}else{encoding.scalabilityMode='L1T3';}}}catch(err){_iterator50.e(err);}finally{_iterator50.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions,extmapAllowMixed:true});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context190.next=34;return this._pc.setRemoteDescription(answer);case 34:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context190.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 36:case"end":return _context190.stop();}},_callee179,this);}));function send(_x155){return _send7.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee180(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee180$(_context191){while(1)switch(_context191.prev=_context191.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);if(!this._closed){_context191.next=4;break;}return _context191.abrupt("return");case 4:transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context191.next=7;break;}throw new Error('associated transceiver not found');case 7:void transceiver.sender.replaceTrack(null);// NOTE: Cannot use stop() the transceiver due to the the note above in
// send() method.
// try
// {
// 	transceiver.stop();
// }
// catch (error)
// {}
this._pc.removeTrack(transceiver.sender);// NOTE: Cannot use closeMediaSection() due to the the note above in send()
// method.
// this._remoteSdp!.closeMediaSection(transceiver.mid);
this._remoteSdp.disableMediaSection(transceiver.mid);_context191.next=12;return this._pc.createOffer();case 12:offer=_context191.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context191.next=16;return this._pc.setLocalDescription(offer);case 16:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context191.next=20;return this._pc.setRemoteDescription(answer);case 20:this._mapMidTransceiver["delete"](localId);case 21:case"end":return _context191.stop();}},_callee180,this);}));function stopSending(_x156){return _stopSending7.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee181(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee181$(_context192){while(1)switch(_context192.prev=_context192.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context192.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context192.next=10;return this._pc.createOffer();case 10:offer=_context192.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context192.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context192.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context192.stop();}},_callee181,this);}));function pauseSending(_x157){return _pauseSending7.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee182(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee182$(_context193){while(1)switch(_context193.prev=_context193.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context193.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='sendonly';this._remoteSdp.resumeSendingMediaSection(localId);_context193.next=10;return this._pc.createOffer();case 10:offer=_context193.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context193.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context193.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context193.stop();}},_callee182,this);}));function resumeSending(_x158){return _resumeSending7.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee183(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee183$(_context194){while(1)switch(_context194.prev=_context194.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context194.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context194.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context194.stop();}},_callee183,this);}));function replaceTrack(_x159,_x160){return _replaceTrack8.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee184(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee184$(_context195){while(1)switch(_context195.prev=_context195.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context195.next=6;break;}throw new Error('associated transceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context195.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context195.next=13;return this._pc.createOffer();case 13:offer=_context195.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context195.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context195.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context195.stop();}},_callee184,this);}));function setMaxSpatialLayer(_x161,_x162){return _setMaxSpatialLayer8.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee185(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee185$(_context196){while(1)switch(_context196.prev=_context196.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context196.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context196.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context196.next=13;return this._pc.createOffer();case 13:offer=_context196.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context196.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context196.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context196.stop();}},_callee185,this);}));function setRtpEncodingParameters(_x163,_x164){return _setRtpEncodingParameters8.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee186(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee186$(_context197){while(1)switch(_context197.prev=_context197.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context197.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context197.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context197.stop();}},_callee186,this);}));function getSenderStats(_x165){return _getSenderStats7.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee187(_ref78){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee187$(_context198){while(1)switch(_context198.prev=_context198.next){case 0:ordered=_ref78.ordered,maxPacketLifeTime=_ref78.maxPacketLifeTime,maxRetransmits=_ref78.maxRetransmits,label=_ref78.label,protocol=_ref78.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context198.next=25;break;}_context198.next=10;return this._pc.createOffer();case 10:offer=_context198.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context198.next=16;break;}_context198.next=16;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context198.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context198.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context198.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context198.stop();}},_callee187,this);}));function sendDataChannel(_x166){return _sendDataChannel7.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee188(optionsList){var _this63=this;var results,mapLocalId,_iterator51,_step51,_rtpParameters$mid4,options,trackId,kind,rtpParameters,streamId,localId,offer,_iterator52,_step52,_loop12,answer,localSdpObject,_iterator53,_step53,_loop13,_iterator54,_step54,_loop14;return _regeneratorRuntime2().wrap(function _callee188$(_context202){while(1)switch(_context202.prev=_context202.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator51=_createForOfIteratorHelper(optionsList);try{for(_iterator51.s();!(_step51=_iterator51.n()).done;){options=_step51.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid4=rtpParameters.mid)!==null&&_rtpParameters$mid4!==void 0?_rtpParameters$mid4:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator51.e(err);}finally{_iterator51.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context202.next=10;return this._pc.setRemoteDescription(offer);case 10:_iterator52=_createForOfIteratorHelper(optionsList);_context202.prev=11;_loop12=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop12(){var options,trackId,onRtpReceiver,_localId5,transceiver;return _regeneratorRuntime2().wrap(function _loop12$(_context199){while(1)switch(_context199.prev=_context199.next){case 0:options=_step52.value;trackId=options.trackId,onRtpReceiver=options.onRtpReceiver;if(!onRtpReceiver){_context199.next=8;break;}_localId5=mapLocalId.get(trackId);transceiver=_this63._pc.getTransceivers().find(function(t){return t.mid===_localId5;});if(transceiver){_context199.next=7;break;}throw new Error('transceiver not found');case 7:onRtpReceiver(transceiver.receiver);case 8:case"end":return _context199.stop();}},_loop12);});_iterator52.s();case 14:if((_step52=_iterator52.n()).done){_context202.next=18;break;}return _context202.delegateYield(_loop12(),"t0",16);case 16:_context202.next=14;break;case 18:_context202.next=23;break;case 20:_context202.prev=20;_context202.t1=_context202["catch"](11);_iterator52.e(_context202.t1);case 23:_context202.prev=23;_iterator52.f();return _context202.finish(23);case 26:_context202.next=28;return this._pc.createAnswer();case 28:answer=_context202.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator53=_createForOfIteratorHelper(optionsList);_context202.prev=31;_loop13=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop13(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop13$(_context200){while(1)switch(_context200.prev=_context200.next){case 0:options=_step53.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};case 6:case"end":return _context200.stop();}},_loop13);});_iterator53.s();case 34:if((_step53=_iterator53.n()).done){_context202.next=38;break;}return _context202.delegateYield(_loop13(),"t2",36);case 36:_context202.next=34;break;case 38:_context202.next=43;break;case 40:_context202.prev=40;_context202.t3=_context202["catch"](31);_iterator53.e(_context202.t3);case 43:_context202.prev=43;_iterator53.f();return _context202.finish(43);case 46:if(this._transportReady){_context202.next=49;break;}_context202.next=49;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 49:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context202.next=52;return this._pc.setLocalDescription(answer);case 52:_iterator54=_createForOfIteratorHelper(optionsList);_context202.prev=53;_loop14=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop14(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop14$(_context201){while(1)switch(_context201.prev=_context201.next){case 0:options=_step54.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this63._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context201.next=6;break;}throw new Error('new RTCRtpTransceiver not found');case 6:// Store in the map.
_this63._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 8:case"end":return _context201.stop();}},_loop14);});_iterator54.s();case 56:if((_step54=_iterator54.n()).done){_context202.next=60;break;}return _context202.delegateYield(_loop14(),"t4",58);case 58:_context202.next=56;break;case 60:_context202.next=65;break;case 62:_context202.prev=62;_context202.t5=_context202["catch"](53);_iterator54.e(_context202.t5);case 65:_context202.prev=65;_iterator54.f();return _context202.finish(65);case 68:return _context202.abrupt("return",results);case 69:case"end":return _context202.stop();}},_callee188,this,[[11,20,23,26],[31,40,43,46],[53,62,65,68]]);}));function receive(_x167){return _receive7.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee189(localIds){var _iterator55,_step55,localId,transceiver,offer,answer,_iterator56,_step56,_localId6;return _regeneratorRuntime2().wrap(function _callee189$(_context203){while(1)switch(_context203.prev=_context203.next){case 0:this.assertRecvDirection();if(!this._closed){_context203.next=3;break;}return _context203.abrupt("return");case 3:_iterator55=_createForOfIteratorHelper(localIds);_context203.prev=4;_iterator55.s();case 6:if((_step55=_iterator55.n()).done){_context203.next=15;break;}localId=_step55.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context203.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context203.next=6;break;case 15:_context203.next=20;break;case 17:_context203.prev=17;_context203.t0=_context203["catch"](4);_iterator55.e(_context203.t0);case 20:_context203.prev=20;_iterator55.f();return _context203.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context203.next=27;return this._pc.setRemoteDescription(offer);case 27:_context203.next=29;return this._pc.createAnswer();case 29:answer=_context203.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context203.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator56=_createForOfIteratorHelper(localIds);try{for(_iterator56.s();!(_step56=_iterator56.n()).done;){_localId6=_step56.value;this._mapMidTransceiver["delete"](_localId6);}}catch(err){_iterator56.e(err);}finally{_iterator56.f();}case 35:case"end":return _context203.stop();}},_callee189,this,[[4,17,20,23]]);}));function stopReceiving(_x168){return _stopReceiving7.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee190(localIds){var _iterator57,_step57,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee190$(_context204){while(1)switch(_context204.prev=_context204.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator57=_createForOfIteratorHelper(localIds);_context204.prev=3;_iterator57.s();case 5:if((_step57=_iterator57.n()).done){_context204.next=15;break;}localId=_step57.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context204.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context204.next=5;break;case 15:_context204.next=20;break;case 17:_context204.prev=17;_context204.t0=_context204["catch"](3);_iterator57.e(_context204.t0);case 20:_context204.prev=20;_iterator57.f();return _context204.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context204.next=27;return this._pc.setRemoteDescription(offer);case 27:_context204.next=29;return this._pc.createAnswer();case 29:answer=_context204.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context204.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context204.stop();}},_callee190,this,[[3,17,20,23]]);}));function pauseReceiving(_x169){return _pauseReceiving7.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee191(localIds){var _iterator58,_step58,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee191$(_context205){while(1)switch(_context205.prev=_context205.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator58=_createForOfIteratorHelper(localIds);_context205.prev=3;_iterator58.s();case 5:if((_step58=_iterator58.n()).done){_context205.next=15;break;}localId=_step58.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context205.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context205.next=5;break;case 15:_context205.next=20;break;case 17:_context205.prev=17;_context205.t0=_context205["catch"](3);_iterator58.e(_context205.t0);case 20:_context205.prev=20;_iterator58.f();return _context205.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context205.next=27;return this._pc.setRemoteDescription(offer);case 27:_context205.next=29;return this._pc.createAnswer();case 29:answer=_context205.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context205.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context205.stop();}},_callee191,this,[[3,17,20,23]]);}));function resumeReceiving(_x170){return _resumeReceiving7.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee192(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee192$(_context206){while(1)switch(_context206.prev=_context206.next){case 0:this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context206.next=4;break;}throw new Error('associated RTCRtpTransceiver not found');case 4:return _context206.abrupt("return",transceiver.receiver.getStats());case 5:case"end":return _context206.stop();}},_callee192,this);}));function getReceiverStats(_x171){return _getReceiverStats7.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee193(_ref79){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,localSdpObject;return _regeneratorRuntime2().wrap(function _callee193$(_context207){while(1)switch(_context207.prev=_context207.next){case 0:sctpStreamParameters=_ref79.sctpStreamParameters,label=_ref79.label,protocol=_ref79.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context207.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context207.next=13;return this._pc.setRemoteDescription(offer);case 13:_context207.next=15;return this._pc.createAnswer();case 15:answer=_context207.sent;if(this._transportReady){_context207.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context207.next=20;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context207.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context207.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context207.stop();}},_callee193,this);}));function receiveDataChannel(_x172){return _receiveDataChannel7.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport7=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee194(_ref80){var _this64=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee194$(_context208){while(1)switch(_context208.prev=_context208.next){case 0:localDtlsRole=_ref80.localDtlsRole,localSdpObject=_ref80.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context208.next=7;return new Promise(function(resolve,reject){_this64.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context208.stop();}},_callee194,this);}));function setupTransport(_x173){return _setupTransport7.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Firefox120();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Firefox120=Firefox120;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Firefox60.js":(/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \*****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Firefox60Js(__unused_webpack_module,exports,__nested_webpack_require_421971__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Firefox60=void 0;var sdpTransform=__importStar(__nested_webpack_require_421971__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_421971__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var errors_1=__nested_webpack_require_421971__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_421971__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_421971__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_421971__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_421971__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var HandlerInterface_1=__nested_webpack_require_421971__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_421971__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_421971__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Firefox60');var NAME='Firefox60';var SCTP_NUM_STREAMS={OS:16,MIS:2048};var Firefox60=/*#__PURE__*/function(_HandlerInterface_1$H8){function Firefox60(){var _this65;_classCallCheck2(this,Firefox60);_this65=_callSuper(this,Firefox60);// Closed flag.
_this65._closed=false;// Map of RTCTransceivers indexed by MID.
_this65._mapMidTransceiver=new Map();// Local stream for sending.
_this65._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this65._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this65._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this65._transportReady=false;return _this65;}_inherits(Firefox60,_HandlerInterface_1$H8);return _createClass2(Firefox60,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee195(){var pc,canvas,fakeStream,fakeVideoTrack,videoTransceiver,parameters,encodings,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee195$(_context209){while(1)switch(_context209.prev=_context209.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'});// NOTE: We need to add a real video track to get the RID extension mapping.
canvas=document.createElement('canvas');// NOTE: Otherwise Firefox fails in next line.
canvas.getContext('2d');fakeStream=canvas.captureStream();fakeVideoTrack=fakeStream.getVideoTracks()[0];_context209.prev=6;pc.addTransceiver('audio',{direction:'sendrecv'});videoTransceiver=pc.addTransceiver(fakeVideoTrack,{direction:'sendrecv'});parameters=videoTransceiver.sender.getParameters();encodings=[{rid:'r0',maxBitrate:100000},{rid:'r1',maxBitrate:500000}];parameters.encodings=encodings;_context209.next=14;return videoTransceiver.sender.setParameters(parameters);case 14:_context209.next=16;return pc.createOffer();case 16:offer=_context209.sent;try{canvas.remove();}catch(error){}try{fakeVideoTrack.stop();}catch(error){}try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context209.abrupt("return",nativeRtpCapabilities);case 25:_context209.prev=25;_context209.t0=_context209["catch"](6);try{canvas.remove();}catch(error2){}try{fakeVideoTrack.stop();}catch(error2){}try{pc.close();}catch(error2){}throw _context209.t0;case 31:case"end":return _context209.stop();}},_callee195,null,[[6,25]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities8.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee196(){return _regeneratorRuntime2().wrap(function _callee196$(_context210){while(1)switch(_context210.prev=_context210.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context210.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context210.stop();}},_callee196);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities8.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref81){var _this66=this;var direction=_ref81.direction,iceParameters=_ref81.iceParameters,iceCandidates=_ref81.iceCandidates,dtlsParameters=_ref81.dtlsParameters,sctpParameters=_ref81.sctpParameters,iceServers=_ref81.iceServers,iceTransportPolicy=_ref81.iceTransportPolicy,additionalSettings=_ref81.additionalSettings,proprietaryConstraints=_ref81.proprietaryConstraints,extendedRtpCapabilities=_ref81.extendedRtpCapabilities;this.assertNotClosed();logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this66.emit('@icegatheringstatechange',_this66._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this66.emit('@connectionstatechange',_this66._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this66._pc.iceConnectionState){case'checking':{_this66.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this66.emit('@connectionstatechange','connected');break;}case'failed':{_this66.emit('@connectionstatechange','failed');break;}case'disconnected':{_this66.emit('@connectionstatechange','disconnected');break;}case'closed':{_this66.emit('@connectionstatechange','closed');break;}}});}}// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"updateIceServers",value:function(){var _updateIceServers9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee197(iceServers){return _regeneratorRuntime2().wrap(function _callee197$(_context211){while(1)switch(_context211.prev=_context211.next){case 0:this.assertNotClosed();// NOTE: Firefox does not implement pc.setConfiguration().
throw new errors_1.UnsupportedError('not supported');case 2:case"end":return _context211.stop();}},_callee197,this);}));function updateIceServers(_x174){return _updateIceServers9.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee198(iceParameters){var offer,answer,_offer7,_answer7;return _regeneratorRuntime2().wrap(function _callee198$(_context212){while(1)switch(_context212.prev=_context212.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context212.next=5;break;}return _context212.abrupt("return");case 5:if(!(this._direction==='send')){_context212.next=18;break;}_context212.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context212.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context212.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context212.next=16;return this._pc.setRemoteDescription(answer);case 16:_context212.next=28;break;case 18:_offer7={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer7);_context212.next=22;return this._pc.setRemoteDescription(_offer7);case 22:_context212.next=24;return this._pc.createAnswer();case 24:_answer7=_context212.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer7);_context212.next=28;return this._pc.setLocalDescription(_answer7);case 28:case"end":return _context212.stop();}},_callee198,this);}));function restartIce(_x175){return _restartIce9.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee199(){return _regeneratorRuntime2().wrap(function _callee199$(_context213){while(1)switch(_context213.prev=_context213.next){case 0:this.assertNotClosed();return _context213.abrupt("return",this._pc.getStats());case 2:case"end":return _context213.stop();}},_callee199,this);}));function getTransportStats(){return _getTransportStats8.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee200(_ref82){var _encodings;var track,encodings,codecOptions,codec,sendingRtpParameters,sendingRemoteRtpParameters,transceiver,parameters,offer,localSdpObject,layers,localId,offerMediaObject,newEncodings,_iterator59,_step59,encoding,answer;return _regeneratorRuntime2().wrap(function _callee200$(_context214){while(1)switch(_context214.prev=_context214.next){case 0:track=_ref82.track,encodings=_ref82.encodings,codecOptions=_ref82.codecOptions,codec=_ref82.codec;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(encodings){encodings=utils.clone(encodings);encodings.forEach(function(encoding,idx){encoding.rid="r".concat(idx);});// Clone the encodings and reverse them because Firefox likes them
// from high to low.
encodings.reverse();}sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);// NOTE: Firefox fails sometimes to properly anticipate the closed media
// section that it should use, so don't reuse closed media sections.
//   https://github.com/versatica/mediasoup-client/issues/104
//
// const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream]});// NOTE: This is not spec compliants. Encodings should be given in addTransceiver
// second argument, but Firefox does not support it.
if(!encodings){_context214.next=15;break;}parameters=transceiver.sender.getParameters();parameters.encodings=encodings;_context214.next=15;return transceiver.sender.setParameters(parameters);case 15:_context214.next=17;return this._pc.createOffer();case 17:offer=_context214.sent;localSdpObject=sdpTransform.parse(offer.sdp);// In Firefox use DTLS role client even if we are the "offerer" since
// Firefox does not respect ICE-Lite.
if(this._transportReady){_context214.next=22;break;}_context214.next=22;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 22:layers=(0,scalabilityModes_1.parse)(((_encodings=encodings)!==null&&_encodings!==void 0?_encodings:[{}])[0].scalabilityMode);logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context214.next=26;return this._pc.setLocalDescription(offer);case 26:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[localSdpObject.media.length-1];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings by parsing the SDP offer if no encodings are given.
if(!encodings){sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});}// Set RTP encodings by parsing the SDP offer and complete them with given
// one if just a single encoding has been given.
else if(encodings.length===1){newEncodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});Object.assign(newEncodings[0],encodings[0]);sendingRtpParameters.encodings=newEncodings;}// Otherwise if more than 1 encoding are given use them verbatim (but
// reverse them back since we reversed them above to satisfy Firefox).
else{sendingRtpParameters.encodings=encodings.reverse();}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator59=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator59.s();!(_step59=_iterator59.n()).done;){encoding=_step59.value;if(encoding.scalabilityMode){encoding.scalabilityMode="L1T".concat(layers.temporalLayers);}else{encoding.scalabilityMode='L1T3';}}}catch(err){_iterator59.e(err);}finally{_iterator59.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions,extmapAllowMixed:true});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context214.next=38;return this._pc.setRemoteDescription(answer);case 38:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context214.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 40:case"end":return _context214.stop();}},_callee200,this);}));function send(_x176){return _send8.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee201(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee201$(_context215){while(1)switch(_context215.prev=_context215.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);if(!this._closed){_context215.next=4;break;}return _context215.abrupt("return");case 4:transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context215.next=7;break;}throw new Error('associated transceiver not found');case 7:void transceiver.sender.replaceTrack(null);// NOTE: Cannot use stop() the transceiver due to the the note above in
// send() method.
// try
// {
// 	transceiver.stop();
// }
// catch (error)
// {}
this._pc.removeTrack(transceiver.sender);// NOTE: Cannot use closeMediaSection() due to the the note above in send()
// method.
// this._remoteSdp!.closeMediaSection(transceiver.mid);
this._remoteSdp.disableMediaSection(transceiver.mid);_context215.next=12;return this._pc.createOffer();case 12:offer=_context215.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context215.next=16;return this._pc.setLocalDescription(offer);case 16:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context215.next=20;return this._pc.setRemoteDescription(answer);case 20:this._mapMidTransceiver["delete"](localId);case 21:case"end":return _context215.stop();}},_callee201,this);}));function stopSending(_x177){return _stopSending8.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee202(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee202$(_context216){while(1)switch(_context216.prev=_context216.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context216.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context216.next=10;return this._pc.createOffer();case 10:offer=_context216.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context216.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context216.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context216.stop();}},_callee202,this);}));function pauseSending(_x178){return _pauseSending8.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee203(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee203$(_context217){while(1)switch(_context217.prev=_context217.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context217.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='sendonly';this._remoteSdp.resumeSendingMediaSection(localId);_context217.next=10;return this._pc.createOffer();case 10:offer=_context217.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context217.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context217.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context217.stop();}},_callee203,this);}));function resumeSending(_x179){return _resumeSending8.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee204(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee204$(_context218){while(1)switch(_context218.prev=_context218.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context218.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context218.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context218.stop();}},_callee204,this);}));function replaceTrack(_x180,_x181){return _replaceTrack9.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee205(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee205$(_context219){while(1)switch(_context219.prev=_context219.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context219.next=6;break;}throw new Error('associated transceiver not found');case 6:parameters=transceiver.sender.getParameters();// NOTE: We require encodings given from low to high, however Firefox
// requires them in reverse order, so do magic here.
spatialLayer=parameters.encodings.length-1-spatialLayer;parameters.encodings.forEach(function(encoding,idx){if(idx>=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context219.next=11;return transceiver.sender.setParameters(parameters);case 11:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context219.next=14;return this._pc.createOffer();case 14:offer=_context219.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context219.next=18;return this._pc.setLocalDescription(offer);case 18:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context219.next=22;return this._pc.setRemoteDescription(answer);case 22:case"end":return _context219.stop();}},_callee205,this);}));function setMaxSpatialLayer(_x182,_x183){return _setMaxSpatialLayer9.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee206(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee206$(_context220){while(1)switch(_context220.prev=_context220.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context220.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context220.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context220.next=13;return this._pc.createOffer();case 13:offer=_context220.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context220.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context220.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context220.stop();}},_callee206,this);}));function setRtpEncodingParameters(_x184,_x185){return _setRtpEncodingParameters9.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee207(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee207$(_context221){while(1)switch(_context221.prev=_context221.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context221.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context221.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context221.stop();}},_callee207,this);}));function getSenderStats(_x186){return _getSenderStats8.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee208(_ref83){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee208$(_context222){while(1)switch(_context222.prev=_context222.next){case 0:ordered=_ref83.ordered,maxPacketLifeTime=_ref83.maxPacketLifeTime,maxRetransmits=_ref83.maxRetransmits,label=_ref83.label,protocol=_ref83.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context222.next=25;break;}_context222.next=10;return this._pc.createOffer();case 10:offer=_context222.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context222.next=16;break;}_context222.next=16;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context222.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context222.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context222.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context222.stop();}},_callee208,this);}));function sendDataChannel(_x187){return _sendDataChannel8.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee209(optionsList){var _this67=this;var results,mapLocalId,_iterator60,_step60,_rtpParameters$mid5,options,trackId,kind,rtpParameters,streamId,localId,offer,answer,localSdpObject,_iterator61,_step61,_loop15,_iterator62,_step62,_loop16;return _regeneratorRuntime2().wrap(function _callee209$(_context225){while(1)switch(_context225.prev=_context225.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator60=_createForOfIteratorHelper(optionsList);try{for(_iterator60.s();!(_step60=_iterator60.n()).done;){options=_step60.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid5=rtpParameters.mid)!==null&&_rtpParameters$mid5!==void 0?_rtpParameters$mid5:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator60.e(err);}finally{_iterator60.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context225.next=10;return this._pc.setRemoteDescription(offer);case 10:_context225.next=12;return this._pc.createAnswer();case 12:answer=_context225.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator61=_createForOfIteratorHelper(optionsList);_context225.prev=15;_loop15=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop15(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop15$(_context223){while(1)switch(_context223.prev=_context223.next){case 0:options=_step61.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};case 6:case"end":return _context223.stop();}},_loop15);});_iterator61.s();case 18:if((_step61=_iterator61.n()).done){_context225.next=22;break;}return _context225.delegateYield(_loop15(),"t0",20);case 20:_context225.next=18;break;case 22:_context225.next=27;break;case 24:_context225.prev=24;_context225.t1=_context225["catch"](15);_iterator61.e(_context225.t1);case 27:_context225.prev=27;_iterator61.f();return _context225.finish(27);case 30:if(this._transportReady){_context225.next=33;break;}_context225.next=33;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 33:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context225.next=36;return this._pc.setLocalDescription(answer);case 36:_iterator62=_createForOfIteratorHelper(optionsList);_context225.prev=37;_loop16=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop16(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop16$(_context224){while(1)switch(_context224.prev=_context224.next){case 0:options=_step62.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this67._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context224.next=6;break;}throw new Error('new RTCRtpTransceiver not found');case 6:// Store in the map.
_this67._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 8:case"end":return _context224.stop();}},_loop16);});_iterator62.s();case 40:if((_step62=_iterator62.n()).done){_context225.next=44;break;}return _context225.delegateYield(_loop16(),"t2",42);case 42:_context225.next=40;break;case 44:_context225.next=49;break;case 46:_context225.prev=46;_context225.t3=_context225["catch"](37);_iterator62.e(_context225.t3);case 49:_context225.prev=49;_iterator62.f();return _context225.finish(49);case 52:return _context225.abrupt("return",results);case 53:case"end":return _context225.stop();}},_callee209,this,[[15,24,27,30],[37,46,49,52]]);}));function receive(_x188){return _receive8.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee210(localIds){var _iterator63,_step63,localId,transceiver,offer,answer,_iterator64,_step64,_localId7;return _regeneratorRuntime2().wrap(function _callee210$(_context226){while(1)switch(_context226.prev=_context226.next){case 0:this.assertRecvDirection();if(!this._closed){_context226.next=3;break;}return _context226.abrupt("return");case 3:_iterator63=_createForOfIteratorHelper(localIds);_context226.prev=4;_iterator63.s();case 6:if((_step63=_iterator63.n()).done){_context226.next=15;break;}localId=_step63.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context226.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context226.next=6;break;case 15:_context226.next=20;break;case 17:_context226.prev=17;_context226.t0=_context226["catch"](4);_iterator63.e(_context226.t0);case 20:_context226.prev=20;_iterator63.f();return _context226.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context226.next=27;return this._pc.setRemoteDescription(offer);case 27:_context226.next=29;return this._pc.createAnswer();case 29:answer=_context226.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context226.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator64=_createForOfIteratorHelper(localIds);try{for(_iterator64.s();!(_step64=_iterator64.n()).done;){_localId7=_step64.value;this._mapMidTransceiver["delete"](_localId7);}}catch(err){_iterator64.e(err);}finally{_iterator64.f();}case 35:case"end":return _context226.stop();}},_callee210,this,[[4,17,20,23]]);}));function stopReceiving(_x189){return _stopReceiving8.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee211(localIds){var _iterator65,_step65,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee211$(_context227){while(1)switch(_context227.prev=_context227.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator65=_createForOfIteratorHelper(localIds);_context227.prev=3;_iterator65.s();case 5:if((_step65=_iterator65.n()).done){_context227.next=15;break;}localId=_step65.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context227.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context227.next=5;break;case 15:_context227.next=20;break;case 17:_context227.prev=17;_context227.t0=_context227["catch"](3);_iterator65.e(_context227.t0);case 20:_context227.prev=20;_iterator65.f();return _context227.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context227.next=27;return this._pc.setRemoteDescription(offer);case 27:_context227.next=29;return this._pc.createAnswer();case 29:answer=_context227.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context227.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context227.stop();}},_callee211,this,[[3,17,20,23]]);}));function pauseReceiving(_x190){return _pauseReceiving8.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee212(localIds){var _iterator66,_step66,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee212$(_context228){while(1)switch(_context228.prev=_context228.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator66=_createForOfIteratorHelper(localIds);_context228.prev=3;_iterator66.s();case 5:if((_step66=_iterator66.n()).done){_context228.next=15;break;}localId=_step66.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context228.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context228.next=5;break;case 15:_context228.next=20;break;case 17:_context228.prev=17;_context228.t0=_context228["catch"](3);_iterator66.e(_context228.t0);case 20:_context228.prev=20;_iterator66.f();return _context228.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context228.next=27;return this._pc.setRemoteDescription(offer);case 27:_context228.next=29;return this._pc.createAnswer();case 29:answer=_context228.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context228.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context228.stop();}},_callee212,this,[[3,17,20,23]]);}));function resumeReceiving(_x191){return _resumeReceiving8.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee213(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee213$(_context229){while(1)switch(_context229.prev=_context229.next){case 0:this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context229.next=4;break;}throw new Error('associated RTCRtpTransceiver not found');case 4:return _context229.abrupt("return",transceiver.receiver.getStats());case 5:case"end":return _context229.stop();}},_callee213,this);}));function getReceiverStats(_x192){return _getReceiverStats8.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee214(_ref84){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,localSdpObject;return _regeneratorRuntime2().wrap(function _callee214$(_context230){while(1)switch(_context230.prev=_context230.next){case 0:sctpStreamParameters=_ref84.sctpStreamParameters,label=_ref84.label,protocol=_ref84.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context230.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context230.next=13;return this._pc.setRemoteDescription(offer);case 13:_context230.next=15;return this._pc.createAnswer();case 15:answer=_context230.sent;if(this._transportReady){_context230.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context230.next=20;return this.setupTransport({localDtlsRole:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context230.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context230.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context230.stop();}},_callee214,this);}));function receiveDataChannel(_x193){return _receiveDataChannel8.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport8=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee215(_ref85){var _this68=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee215$(_context231){while(1)switch(_context231.prev=_context231.next){case 0:localDtlsRole=_ref85.localDtlsRole,localSdpObject=_ref85.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context231.next=7;return new Promise(function(resolve,reject){_this68.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context231.stop();}},_callee215,this);}));function setupTransport(_x194){return _setupTransport8.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Firefox60();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Firefox60=Firefox60;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":(/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \************************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_HandlerInterfaceJs(__unused_webpack_module,exports,__nested_webpack_require_464930__){Object.defineProperty(exports,"__esModule",{value:true});exports.HandlerInterface=void 0;var enhancedEvents_1=__nested_webpack_require_464930__(/*! ../enhancedEvents */"./node_modules/mediasoup-client/lib/enhancedEvents.js");var HandlerInterface=/*#__PURE__*/function(_enhancedEvents_1$Enh6){function HandlerInterface(){_classCallCheck2(this,HandlerInterface);return _callSuper(this,HandlerInterface);}_inherits(HandlerInterface,_enhancedEvents_1$Enh6);return _createClass2(HandlerInterface);}(enhancedEvents_1.EnhancedEventEmitter);exports.HandlerInterface=HandlerInterface;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/ReactNative.js":(/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*******************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_ReactNativeJs(__unused_webpack_module,exports,__nested_webpack_require_465908__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.ReactNative=void 0;var sdpTransform=__importStar(__nested_webpack_require_465908__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_465908__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var errors_1=__nested_webpack_require_465908__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var utils=__importStar(__nested_webpack_require_465908__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_465908__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_465908__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpPlanBUtils=__importStar(__nested_webpack_require_465908__(/*! ./sdp/planBUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));var HandlerInterface_1=__nested_webpack_require_465908__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_465908__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var logger=new Logger_1.Logger('ReactNative');var NAME='ReactNative';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var ReactNative=/*#__PURE__*/function(_HandlerInterface_1$H9){function ReactNative(){var _this69;_classCallCheck2(this,ReactNative);_this69=_callSuper(this,ReactNative);// Local stream for sending.
_this69._sendStream=new MediaStream();// Map of sending MediaStreamTracks indexed by localId.
_this69._mapSendLocalIdTrack=new Map();// Next sending localId.
_this69._nextSendLocalId=0;// Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
// Value is an Object with mid, rtpParameters and rtpReceiver.
_this69._mapRecvLocalIdInfo=new Map();// Whether a DataChannel m=application section has been created.
_this69._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this69._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this69._transportReady=false;return _this69;}_inherits(ReactNative,_HandlerInterface_1$H9);return _createClass2(ReactNative,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Free/dispose native MediaStream but DO NOT free/dispose native
// MediaStreamTracks (that is parent's business).
// @ts-expect-error --- Proprietary API in react-native-webrtc.
this._sendStream.release(/* releaseTracks */false);// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee216(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee216$(_context232){while(1)switch(_context232.prev=_context232.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'});_context232.prev=2;_context232.next=5;return pc.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:true});case 5:offer=_context232.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context232.abrupt("return",nativeRtpCapabilities);case 12:_context232.prev=12;_context232.t0=_context232["catch"](2);try{pc.close();}catch(error2){}throw _context232.t0;case 16:case"end":return _context232.stop();}},_callee216,null,[[2,12]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities9.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee217(){return _regeneratorRuntime2().wrap(function _callee217$(_context233){while(1)switch(_context233.prev=_context233.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context233.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context233.stop();}},_callee217);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities9.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref86){var _this70=this;var direction=_ref86.direction,iceParameters=_ref86.iceParameters,iceCandidates=_ref86.iceCandidates,dtlsParameters=_ref86.dtlsParameters,sctpParameters=_ref86.sctpParameters,iceServers=_ref86.iceServers,iceTransportPolicy=_ref86.iceTransportPolicy,additionalSettings=_ref86.additionalSettings,proprietaryConstraints=_ref86.proprietaryConstraints,extendedRtpCapabilities=_ref86.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,planB:true});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this70.emit('@icegatheringstatechange',_this70._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this70.emit('@connectionstatechange',_this70._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this70._pc.iceConnectionState){case'checking':{_this70.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this70.emit('@connectionstatechange','connected');break;}case'failed':{_this70.emit('@connectionstatechange','failed');break;}case'disconnected':{_this70.emit('@connectionstatechange','disconnected');break;}case'closed':{_this70.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee218(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee218$(_context234){while(1)switch(_context234.prev=_context234.next){case 0:logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 4:case"end":return _context234.stop();}},_callee218,this);}));function updateIceServers(_x195){return _updateIceServers10.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee219(iceParameters){var offer,answer,_offer8,_answer8;return _regeneratorRuntime2().wrap(function _callee219$(_context235){while(1)switch(_context235.prev=_context235.next){case 0:logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context235.next=4;break;}return _context235.abrupt("return");case 4:if(!(this._direction==='send')){_context235.next=17;break;}_context235.next=7;return this._pc.createOffer({iceRestart:true});case 7:offer=_context235.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context235.next=11;return this._pc.setLocalDescription(offer);case 11:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context235.next=15;return this._pc.setRemoteDescription(answer);case 15:_context235.next=27;break;case 17:_offer8={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer8);_context235.next=21;return this._pc.setRemoteDescription(_offer8);case 21:_context235.next=23;return this._pc.createAnswer();case 23:_answer8=_context235.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer8);_context235.next=27;return this._pc.setLocalDescription(_answer8);case 27:case"end":return _context235.stop();}},_callee219,this);}));function restartIce(_x196){return _restartIce10.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee220(){return _regeneratorRuntime2().wrap(function _callee220$(_context236){while(1)switch(_context236.prev=_context236.next){case 0:return _context236.abrupt("return",this._pc.getStats());case 1:case"end":return _context236.stop();}},_callee220,this);}));function getTransportStats(){return _getTransportStats9.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee221(_ref87){var track,encodings,codecOptions,codec,offer,localSdpObject,offerMediaObject,sendingRtpParameters,sendingRemoteRtpParameters,_this$_forcedLocalDtl21,idx,_iterator67,_step67,encoding,answer,localId;return _regeneratorRuntime2().wrap(function _callee221$(_context237){while(1)switch(_context237.prev=_context237.next){case 0:track=_ref87.track,encodings=_ref87.encodings,codecOptions=_ref87.codecOptions,codec=_ref87.codec;this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(codec){logger.warn('send() | codec selection is not available in %s handler',this.name);}this._sendStream.addTrack(track);this._pc.addStream(this._sendStream);_context237.next=8;return this._pc.createOffer();case 8:offer=_context237.sent;localSdpObject=sdpTransform.parse(offer.sdp);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);if(this._transportReady){_context237.next=17;break;}_context237.next=17;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl21=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl21!==void 0?_this$_forcedLocalDtl21:'client',localSdpObject:localSdpObject});case 17:if(track.kind==='video'&&encodings&&encodings.length>1){logger.debug('send() | enabling simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='video';});sdpPlanBUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,track:track,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context237.next=21;return this._pc.setLocalDescription(offer);case 21:localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type===track.kind;});// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:offerMediaObject,track:track});// Complete encodings with given values.
if(encodings){for(idx=0;idx<sendingRtpParameters.encodings.length;++idx){if(encodings[idx]){Object.assign(sendingRtpParameters.encodings[idx],encodings[idx]);}}}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator67=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator67.s();!(_step67=_iterator67.n()).done;){encoding=_step67.value;encoding.scalabilityMode='L1T3';}}catch(err){_iterator67.e(err);}finally{_iterator67.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context237.next=32;return this._pc.setRemoteDescription(answer);case 32:localId=String(this._nextSendLocalId);this._nextSendLocalId++;// Insert into the map.
this._mapSendLocalIdTrack.set(localId,track);return _context237.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters});case 36:case"end":return _context237.stop();}},_callee221,this);}));function send(_x197){return _send9.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee222(localId){var track,offer,answer;return _regeneratorRuntime2().wrap(function _callee222$(_context238){while(1)switch(_context238.prev=_context238.next){case 0:this.assertSendDirection();logger.debug('stopSending() [localId:%s]',localId);track=this._mapSendLocalIdTrack.get(localId);if(track){_context238.next=5;break;}throw new Error('track not found');case 5:this._mapSendLocalIdTrack["delete"](localId);this._sendStream.removeTrack(track);this._pc.addStream(this._sendStream);_context238.next=10;return this._pc.createOffer();case 10:offer=_context238.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context238.prev=12;_context238.next=15;return this._pc.setLocalDescription(offer);case 15:_context238.next=23;break;case 17:_context238.prev=17;_context238.t0=_context238["catch"](12);if(!(this._sendStream.getTracks().length===0)){_context238.next=22;break;}logger.warn('stopSending() | ignoring expected error due no sending tracks: %s',_context238.t0.toString());return _context238.abrupt("return");case 22:throw _context238.t0;case 23:if(!(this._pc.signalingState==='stable')){_context238.next=25;break;}return _context238.abrupt("return");case 25:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context238.next=29;return this._pc.setRemoteDescription(answer);case 29:case"end":return _context238.stop();}},_callee222,this,[[12,17]]);}));function stopSending(_x198){return _stopSending9.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee223(localId){return _regeneratorRuntime2().wrap(function _callee223$(_context239){while(1)switch(_context239.prev=_context239.next){case 0:case"end":return _context239.stop();}},_callee223);}));function pauseSending(_x199){return _pauseSending9.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee224(localId){return _regeneratorRuntime2().wrap(function _callee224$(_context240){while(1)switch(_context240.prev=_context240.next){case 0:case"end":return _context240.stop();}},_callee224);}));function resumeSending(_x200){return _resumeSending9.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee225(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localId,// eslint-disable-next-line @typescript-eslint/no-unused-vars
track){return _regeneratorRuntime2().wrap(function _callee225$(_context241){while(1)switch(_context241.prev=_context241.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context241.stop();}},_callee225);}));function replaceTrack(_x201,_x202){return _replaceTrack10.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee226(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localId,// eslint-disable-next-line @typescript-eslint/no-unused-vars
spatialLayer){return _regeneratorRuntime2().wrap(function _callee226$(_context242){while(1)switch(_context242.prev=_context242.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context242.stop();}},_callee226);}));function setMaxSpatialLayer(_x203,_x204){return _setMaxSpatialLayer10.apply(this,arguments);}return setMaxSpatialLayer;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee227(localId,params){return _regeneratorRuntime2().wrap(function _callee227$(_context243){while(1)switch(_context243.prev=_context243.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context243.stop();}},_callee227);}));function setRtpEncodingParameters(_x205,_x206){return _setRtpEncodingParameters10.apply(this,arguments);}return setRtpEncodingParameters;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"getSenderStats",value:function(){var _getSenderStats9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee228(localId){return _regeneratorRuntime2().wrap(function _callee228$(_context244){while(1)switch(_context244.prev=_context244.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context244.stop();}},_callee228);}));function getSenderStats(_x207){return _getSenderStats9.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee229(_ref88){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl22,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee229$(_context245){while(1)switch(_context245.prev=_context245.next){case 0:ordered=_ref88.ordered,maxPacketLifeTime=_ref88.maxPacketLifeTime,maxRetransmits=_ref88.maxRetransmits,label=_ref88.label,protocol=_ref88.protocol;this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context245.next=24;break;}_context245.next=9;return this._pc.createOffer();case 9:offer=_context245.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context245.next=15;break;}_context245.next=15;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl22=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl22!==void 0?_this$_forcedLocalDtl22:'client',localSdpObject:localSdpObject});case 15:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context245.next=18;return this._pc.setLocalDescription(offer);case 18:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context245.next=23;return this._pc.setRemoteDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context245.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 26:case"end":return _context245.stop();}},_callee229,this);}));function sendDataChannel(_x208){return _sendDataChannel9.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee230(optionsList){var _this71=this;var results,mapStreamId,_iterator68,_step68,_options$streamId2,options,trackId,kind,rtpParameters,mid,streamId,offer,answer,localSdpObject,_iterator69,_step69,_loop17,_this$_forcedLocalDtl23,_iterator70,_step70,_loop18;return _regeneratorRuntime2().wrap(function _callee230$(_context248){while(1)switch(_context248.prev=_context248.next){case 0:this.assertRecvDirection();results=[];mapStreamId=new Map();_iterator68=_createForOfIteratorHelper(optionsList);try{for(_iterator68.s();!(_step68=_iterator68.n()).done;){options=_step68.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);mid=kind;streamId=(_options$streamId2=options.streamId)!==null&&_options$streamId2!==void 0?_options$streamId2:rtpParameters.rtcp.cname;// NOTE: In React-Native we cannot reuse the same remote MediaStream for new
// remote tracks. This is because react-native-webrtc does not react on new
// tracks generated within already existing streams, so force the streamId
// to be different. See:
// https://github.com/react-native-webrtc/react-native-webrtc/issues/401
logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');streamId+="-hack-".concat(utils.generateRandomNumber());mapStreamId.set(trackId,streamId);this._remoteSdp.receive({mid:mid,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId,trackId:trackId});}}catch(err){_iterator68.e(err);}finally{_iterator68.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context248.next=9;return this._pc.setRemoteDescription(offer);case 9:_context248.next=11;return this._pc.createAnswer();case 11:answer=_context248.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator69=_createForOfIteratorHelper(optionsList);_context248.prev=14;_loop17=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop17(){var options,kind,rtpParameters,mid,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop17$(_context246){while(1)switch(_context246.prev=_context246.next){case 0:options=_step69.value;kind=options.kind,rtpParameters=options.rtpParameters;mid=kind;answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===mid;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context246.stop();}},_loop17);});_iterator69.s();case 17:if((_step69=_iterator69.n()).done){_context248.next=21;break;}return _context248.delegateYield(_loop17(),"t0",19);case 19:_context248.next=17;break;case 21:_context248.next=26;break;case 23:_context248.prev=23;_context248.t1=_context248["catch"](14);_iterator69.e(_context248.t1);case 26:_context248.prev=26;_iterator69.f();return _context248.finish(26);case 29:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context248.next=33;break;}_context248.next=33;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl23=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl23!==void 0?_this$_forcedLocalDtl23:'client',localSdpObject:localSdpObject});case 33:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context248.next=36;return this._pc.setLocalDescription(answer);case 36:_iterator70=_createForOfIteratorHelper(optionsList);_context248.prev=37;_loop18=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop18(){var options,kind,trackId,rtpParameters,localId,mid,streamId,stream,track;return _regeneratorRuntime2().wrap(function _loop18$(_context247){while(1)switch(_context247.prev=_context247.next){case 0:options=_step70.value;kind=options.kind,trackId=options.trackId,rtpParameters=options.rtpParameters;localId=trackId;mid=kind;streamId=mapStreamId.get(trackId);stream=_this71._pc.getRemoteStreams().find(function(s){return s.id===streamId;});track=stream.getTrackById(localId);if(track){_context247.next=9;break;}throw new Error('remote track not found');case 9:// Insert into the map.
_this71._mapRecvLocalIdInfo.set(localId,{mid:mid,rtpParameters:rtpParameters});results.push({localId:localId,track:track});case 11:case"end":return _context247.stop();}},_loop18);});_iterator70.s();case 40:if((_step70=_iterator70.n()).done){_context248.next=44;break;}return _context248.delegateYield(_loop18(),"t2",42);case 42:_context248.next=40;break;case 44:_context248.next=49;break;case 46:_context248.prev=46;_context248.t3=_context248["catch"](37);_iterator70.e(_context248.t3);case 49:_context248.prev=49;_iterator70.f();return _context248.finish(49);case 52:return _context248.abrupt("return",results);case 53:case"end":return _context248.stop();}},_callee230,this,[[14,23,26,29],[37,46,49,52]]);}));function receive(_x209){return _receive9.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee231(localIds){var _iterator71,_step71,_this$_mapRecvLocalId4,localId,_ref89,mid,rtpParameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee231$(_context249){while(1)switch(_context249.prev=_context249.next){case 0:this.assertRecvDirection();_iterator71=_createForOfIteratorHelper(localIds);try{for(_iterator71.s();!(_step71=_iterator71.n()).done;){localId=_step71.value;logger.debug('stopReceiving() [localId:%s]',localId);_ref89=(_this$_mapRecvLocalId4=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId4!==void 0?_this$_mapRecvLocalId4:{},mid=_ref89.mid,rtpParameters=_ref89.rtpParameters;// Remove from the map.
this._mapRecvLocalIdInfo["delete"](localId);this._remoteSdp.planBStopReceiving({mid:mid,offerRtpParameters:rtpParameters});}}catch(err){_iterator71.e(err);}finally{_iterator71.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context249.next=7;return this._pc.setRemoteDescription(offer);case 7:_context249.next=9;return this._pc.createAnswer();case 9:answer=_context249.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context249.next=13;return this._pc.setLocalDescription(answer);case 13:case"end":return _context249.stop();}},_callee231,this);}));function stopReceiving(_x210){return _stopReceiving9.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee232(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee232$(_context250){while(1)switch(_context250.prev=_context250.next){case 0:case"end":return _context250.stop();}},_callee232);}));function pauseReceiving(_x211){return _pauseReceiving9.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee233(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee233$(_context251){while(1)switch(_context251.prev=_context251.next){case 0:case"end":return _context251.stop();}},_callee233);}));function resumeReceiving(_x212){return _resumeReceiving9.apply(this,arguments);}return resumeReceiving;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"getReceiverStats",value:function(){var _getReceiverStats9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee234(localId){return _regeneratorRuntime2().wrap(function _callee234$(_context252){while(1)switch(_context252.prev=_context252.next){case 0:throw new errors_1.UnsupportedError('not implemented');case 1:case"end":return _context252.stop();}},_callee234);}));function getReceiverStats(_x213){return _getReceiverStats9.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee235(_ref90){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl24,localSdpObject;return _regeneratorRuntime2().wrap(function _callee235$(_context253){while(1)switch(_context253.prev=_context253.next){case 0:sctpStreamParameters=_ref90.sctpStreamParameters,label=_ref90.label,protocol=_ref90.protocol;this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmitTime:maxPacketLifeTime,// NOTE: Old spec.
maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context253.next=23;break;}this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:true});offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context253.next=12;return this._pc.setRemoteDescription(offer);case 12:_context253.next=14;return this._pc.createAnswer();case 14:answer=_context253.sent;if(this._transportReady){_context253.next=19;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context253.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl24=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl24!==void 0?_this$_forcedLocalDtl24:'client',localSdpObject:localSdpObject});case 19:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context253.next=22;return this._pc.setLocalDescription(answer);case 22:this._hasDataChannelMediaSection=true;case 23:return _context253.abrupt("return",{dataChannel:dataChannel});case 24:case"end":return _context253.stop();}},_callee235,this);}));function receiveDataChannel(_x214){return _receiveDataChannel9.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport9=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee236(_ref91){var _this72=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee236$(_context254){while(1)switch(_context254.prev=_context254.next){case 0:localDtlsRole=_ref91.localDtlsRole,localSdpObject=_ref91.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context254.next=7;return new Promise(function(resolve,reject){_this72.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context254.stop();}},_callee236,this);}));function setupTransport(_x215){return _setupTransport9.apply(this,arguments);}return setupTransport;}()},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new ReactNative();};}}]);}(HandlerInterface_1.HandlerInterface);exports.ReactNative=ReactNative;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js":(/*!******************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js ***!
  \******************************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_ReactNativeUnifiedPlanJs(__unused_webpack_module,exports,__nested_webpack_require_500962__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.ReactNativeUnifiedPlan=void 0;var sdpTransform=__importStar(__nested_webpack_require_500962__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_500962__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_500962__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_500962__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_500962__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_500962__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var ortcUtils=__importStar(__nested_webpack_require_500962__(/*! ./ortc/utils */"./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));var errors_1=__nested_webpack_require_500962__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var HandlerInterface_1=__nested_webpack_require_500962__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_500962__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_500962__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('ReactNativeUnifiedPlan');var NAME='ReactNativeUnifiedPlan';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var ReactNativeUnifiedPlan=/*#__PURE__*/function(_HandlerInterface_1$H10){function ReactNativeUnifiedPlan(){var _this73;_classCallCheck2(this,ReactNativeUnifiedPlan);_this73=_callSuper(this,ReactNativeUnifiedPlan);// Closed flag.
_this73._closed=false;// Map of RTCTransceivers indexed by MID.
_this73._mapMidTransceiver=new Map();// Local stream for sending.
_this73._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this73._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this73._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this73._transportReady=false;return _this73;}_inherits(ReactNativeUnifiedPlan,_HandlerInterface_1$H10);return _createClass2(ReactNativeUnifiedPlan,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Free/dispose native MediaStream but DO NOT free/dispose native
// MediaStreamTracks (that is parent's business).
// @ts-expect-error --- Proprietary API in react-native-webrtc.
this._sendStream.release(/* releaseTracks */false);// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee237(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee237$(_context255){while(1)switch(_context255.prev=_context255.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'});_context255.prev=2;pc.addTransceiver('audio');pc.addTransceiver('video');_context255.next=7;return pc.createOffer();case 7:offer=_context255.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});// libwebrtc supports NACK for OPUS but doesn't announce it.
ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);return _context255.abrupt("return",nativeRtpCapabilities);case 15:_context255.prev=15;_context255.t0=_context255["catch"](2);try{pc.close();}catch(error2){}throw _context255.t0;case 19:case"end":return _context255.stop();}},_callee237,null,[[2,15]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities10.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee238(){return _regeneratorRuntime2().wrap(function _callee238$(_context256){while(1)switch(_context256.prev=_context256.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context256.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context256.stop();}},_callee238);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities10.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref92){var _this74=this;var direction=_ref92.direction,iceParameters=_ref92.iceParameters,iceCandidates=_ref92.iceCandidates,dtlsParameters=_ref92.dtlsParameters,sctpParameters=_ref92.sctpParameters,iceServers=_ref92.iceServers,iceTransportPolicy=_ref92.iceTransportPolicy,additionalSettings=_ref92.additionalSettings,proprietaryConstraints=_ref92.proprietaryConstraints,extendedRtpCapabilities=_ref92.extendedRtpCapabilities;this.assertNotClosed();logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'unified-plan'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this74.emit('@icegatheringstatechange',_this74._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this74.emit('@connectionstatechange',_this74._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this74._pc.iceConnectionState){case'checking':{_this74.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this74.emit('@connectionstatechange','connected');break;}case'failed':{_this74.emit('@connectionstatechange','failed');break;}case'disconnected':{_this74.emit('@connectionstatechange','disconnected');break;}case'closed':{_this74.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee239(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee239$(_context257){while(1)switch(_context257.prev=_context257.next){case 0:this.assertNotClosed();logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 5:case"end":return _context257.stop();}},_callee239,this);}));function updateIceServers(_x216){return _updateIceServers11.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee240(iceParameters){var offer,answer,_offer9,_answer9;return _regeneratorRuntime2().wrap(function _callee240$(_context258){while(1)switch(_context258.prev=_context258.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context258.next=5;break;}return _context258.abrupt("return");case 5:if(!(this._direction==='send')){_context258.next=18;break;}_context258.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context258.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context258.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context258.next=16;return this._pc.setRemoteDescription(answer);case 16:_context258.next=28;break;case 18:_offer9={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer9);_context258.next=22;return this._pc.setRemoteDescription(_offer9);case 22:_context258.next=24;return this._pc.createAnswer();case 24:_answer9=_context258.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer9);_context258.next=28;return this._pc.setLocalDescription(_answer9);case 28:case"end":return _context258.stop();}},_callee240,this);}));function restartIce(_x217){return _restartIce11.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee241(){return _regeneratorRuntime2().wrap(function _callee241$(_context259){while(1)switch(_context259.prev=_context259.next){case 0:this.assertNotClosed();return _context259.abrupt("return",this._pc.getStats());case 2:case"end":return _context259.stop();}},_callee241,this);}));function getTransportStats(){return _getTransportStats10.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee242(_ref93){var _transceiver$mid;var track,encodings,codecOptions,codec,onRtpSender,sendingRtpParameters,sendingRemoteRtpParameters,mediaSectionIdx,transceiver,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl25,hackVp9Svc,layers,localId,newEncodings,_iterator72,_step72,encoding,answer;return _regeneratorRuntime2().wrap(function _callee242$(_context260){while(1)switch(_context260.prev=_context260.next){case 0:track=_ref93.track,encodings=_ref93.encodings,codecOptions=_ref93.codecOptions,codec=_ref93.codec,onRtpSender=_ref93.onRtpSender;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(encodings&&encodings.length>1){encodings.forEach(function(encoding,idx){encoding.rid="r".concat(idx);});}sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);mediaSectionIdx=this._remoteSdp.getNextMediaSectionIdx();transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream],sendEncodings:encodings});if(onRtpSender){onRtpSender(transceiver.sender);}_context260.next=14;return this._pc.createOffer();case 14:offer=_context260.sent;localSdpObject=sdpTransform.parse(offer.sdp);if(this._transportReady){_context260.next=19;break;}_context260.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl25=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl25!==void 0?_this$_forcedLocalDtl25:'client',localSdpObject:localSdpObject});case 19:// Special case for VP9 with SVC.
hackVp9Svc=false;layers=(0,scalabilityModes_1.parse)((encodings!==null&&encodings!==void 0?encodings:[{}])[0].scalabilityMode);if(encodings&&encodings.length===1&&layers.spatialLayers>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp9'){logger.debug('send() | enabling legacy simulcast for VP9 SVC');hackVp9Svc=true;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];sdpUnifiedPlanUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,numStreams:layers.spatialLayers});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context260.next=25;return this._pc.setLocalDescription(offer);case 25:// We can now get the transceiver.mid.
// NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
// because transceiver.mid is not available until setRemoteDescription()
// is called, so this is best effort.
// Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
// NOTE: So let's fill MID in sendingRtpParameters later.
// NOTE: This is fixed in react-native-webrtc 111.0.3.
localId=(_transceiver$mid=transceiver.mid)!==null&&_transceiver$mid!==void 0?_transceiver$mid:undefined;if(!localId){logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');}// Set MID.
// NOTE: As per above, it could be unset yet.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings by parsing the SDP offer if no encodings are given.
if(!encodings){sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});}// Set RTP encodings by parsing the SDP offer and complete them with given
// one if just a single encoding has been given.
else if(encodings.length===1){newEncodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});Object.assign(newEncodings[0],encodings[0]);// Hack for VP9 SVC.
if(hackVp9Svc){newEncodings=[newEncodings[0]];}sendingRtpParameters.encodings=newEncodings;}// Otherwise if more than 1 encoding are given use them verbatim.
else{sendingRtpParameters.encodings=encodings;}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator72=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator72.s();!(_step72=_iterator72.n()).done;){encoding=_step72.value;if(encoding.scalabilityMode){encoding.scalabilityMode="L1T".concat(layers.temporalLayers);}else{encoding.scalabilityMode='L1T3';}}}catch(err){_iterator72.e(err);}finally{_iterator72.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,reuseMid:mediaSectionIdx.reuseMid,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions,extmapAllowMixed:true});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context260.next=38;return this._pc.setRemoteDescription(answer);case 38:// Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
// we can read generated MID (if not done above) and fill sendingRtpParameters.
// NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
// needed starting from that version.
if(!localId){localId=transceiver.mid;sendingRtpParameters.mid=localId;}// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context260.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 41:case"end":return _context260.stop();}},_callee242,this);}));function send(_x218){return _send10.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee243(localId){var transceiver,mediaSectionClosed,offer,answer;return _regeneratorRuntime2().wrap(function _callee243$(_context261){while(1)switch(_context261.prev=_context261.next){case 0:this.assertSendDirection();if(!this._closed){_context261.next=3;break;}return _context261.abrupt("return");case 3:logger.debug('stopSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context261.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:void transceiver.sender.replaceTrack(null);this._pc.removeTrack(transceiver.sender);mediaSectionClosed=this._remoteSdp.closeMediaSection(transceiver.mid);if(mediaSectionClosed){try{transceiver.stop();}catch(error){}}_context261.next=13;return this._pc.createOffer();case 13:offer=_context261.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context261.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context261.next=21;return this._pc.setRemoteDescription(answer);case 21:this._mapMidTransceiver["delete"](localId);case 22:case"end":return _context261.stop();}},_callee243,this);}));function stopSending(_x219){return _stopSending10.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee244(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee244$(_context262){while(1)switch(_context262.prev=_context262.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context262.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context262.next=10;return this._pc.createOffer();case 10:offer=_context262.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context262.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context262.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context262.stop();}},_callee244,this);}));function pauseSending(_x220){return _pauseSending10.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee245(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee245$(_context263){while(1)switch(_context263.prev=_context263.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);this._remoteSdp.resumeSendingMediaSection(localId);if(transceiver){_context263.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:transceiver.direction='sendonly';_context263.next=10;return this._pc.createOffer();case 10:offer=_context263.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context263.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context263.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context263.stop();}},_callee245,this);}));function resumeSending(_x221){return _resumeSending10.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee246(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee246$(_context264){while(1)switch(_context264.prev=_context264.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context264.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context264.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context264.stop();}},_callee246,this);}));function replaceTrack(_x222,_x223){return _replaceTrack11.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee247(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee247$(_context265){while(1)switch(_context265.prev=_context265.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context265.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context265.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context265.next=13;return this._pc.createOffer();case 13:offer=_context265.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context265.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context265.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context265.stop();}},_callee247,this);}));function setMaxSpatialLayer(_x224,_x225){return _setMaxSpatialLayer11.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee248(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee248$(_context266){while(1)switch(_context266.prev=_context266.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context266.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context266.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context266.next=13;return this._pc.createOffer();case 13:offer=_context266.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context266.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context266.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context266.stop();}},_callee248,this);}));function setRtpEncodingParameters(_x226,_x227){return _setRtpEncodingParameters11.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee249(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee249$(_context267){while(1)switch(_context267.prev=_context267.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context267.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context267.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context267.stop();}},_callee249,this);}));function getSenderStats(_x228){return _getSenderStats10.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee250(_ref94){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl26,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee250$(_context268){while(1)switch(_context268.prev=_context268.next){case 0:ordered=_ref94.ordered,maxPacketLifeTime=_ref94.maxPacketLifeTime,maxRetransmits=_ref94.maxRetransmits,label=_ref94.label,protocol=_ref94.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context268.next=25;break;}_context268.next=10;return this._pc.createOffer();case 10:offer=_context268.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context268.next=16;break;}_context268.next=16;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl26=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl26!==void 0?_this$_forcedLocalDtl26:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context268.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context268.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context268.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context268.stop();}},_callee250,this);}));function sendDataChannel(_x229){return _sendDataChannel10.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee251(optionsList){var _this75=this;var results,mapLocalId,_iterator73,_step73,_rtpParameters$mid6,options,trackId,kind,rtpParameters,streamId,localId,offer,_iterator74,_step74,_loop19,answer,localSdpObject,_iterator75,_step75,_loop20,_this$_forcedLocalDtl27,_iterator76,_step76,_loop21;return _regeneratorRuntime2().wrap(function _callee251$(_context272){while(1)switch(_context272.prev=_context272.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator73=_createForOfIteratorHelper(optionsList);try{for(_iterator73.s();!(_step73=_iterator73.n()).done;){options=_step73.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid6=rtpParameters.mid)!==null&&_rtpParameters$mid6!==void 0?_rtpParameters$mid6:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator73.e(err);}finally{_iterator73.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context272.next=10;return this._pc.setRemoteDescription(offer);case 10:_iterator74=_createForOfIteratorHelper(optionsList);_context272.prev=11;_loop19=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop19(){var options,trackId,onRtpReceiver,_localId8,transceiver;return _regeneratorRuntime2().wrap(function _loop19$(_context269){while(1)switch(_context269.prev=_context269.next){case 0:options=_step74.value;trackId=options.trackId,onRtpReceiver=options.onRtpReceiver;if(!onRtpReceiver){_context269.next=8;break;}_localId8=mapLocalId.get(trackId);transceiver=_this75._pc.getTransceivers().find(function(t){return t.mid===_localId8;});if(transceiver){_context269.next=7;break;}throw new Error('transceiver not found');case 7:onRtpReceiver(transceiver.receiver);case 8:case"end":return _context269.stop();}},_loop19);});_iterator74.s();case 14:if((_step74=_iterator74.n()).done){_context272.next=18;break;}return _context272.delegateYield(_loop19(),"t0",16);case 16:_context272.next=14;break;case 18:_context272.next=23;break;case 20:_context272.prev=20;_context272.t1=_context272["catch"](11);_iterator74.e(_context272.t1);case 23:_context272.prev=23;_iterator74.f();return _context272.finish(23);case 26:_context272.next=28;return this._pc.createAnswer();case 28:answer=_context272.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator75=_createForOfIteratorHelper(optionsList);_context272.prev=31;_loop20=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop20(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop20$(_context270){while(1)switch(_context270.prev=_context270.next){case 0:options=_step75.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context270.stop();}},_loop20);});_iterator75.s();case 34:if((_step75=_iterator75.n()).done){_context272.next=38;break;}return _context272.delegateYield(_loop20(),"t2",36);case 36:_context272.next=34;break;case 38:_context272.next=43;break;case 40:_context272.prev=40;_context272.t3=_context272["catch"](31);_iterator75.e(_context272.t3);case 43:_context272.prev=43;_iterator75.f();return _context272.finish(43);case 46:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context272.next=50;break;}_context272.next=50;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl27=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl27!==void 0?_this$_forcedLocalDtl27:'client',localSdpObject:localSdpObject});case 50:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context272.next=53;return this._pc.setLocalDescription(answer);case 53:_iterator76=_createForOfIteratorHelper(optionsList);_context272.prev=54;_loop21=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop21(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop21$(_context271){while(1)switch(_context271.prev=_context271.next){case 0:options=_step76.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this75._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context271.next=8;break;}throw new Error('new RTCRtpTransceiver not found');case 8:// Store in the map.
_this75._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 10:case"end":return _context271.stop();}},_loop21);});_iterator76.s();case 57:if((_step76=_iterator76.n()).done){_context272.next=61;break;}return _context272.delegateYield(_loop21(),"t4",59);case 59:_context272.next=57;break;case 61:_context272.next=66;break;case 63:_context272.prev=63;_context272.t5=_context272["catch"](54);_iterator76.e(_context272.t5);case 66:_context272.prev=66;_iterator76.f();return _context272.finish(66);case 69:return _context272.abrupt("return",results);case 70:case"end":return _context272.stop();}},_callee251,this,[[11,20,23,26],[31,40,43,46],[54,63,66,69]]);}));function receive(_x230){return _receive10.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee252(localIds){var _iterator77,_step77,localId,transceiver,offer,answer,_iterator78,_step78,_localId9;return _regeneratorRuntime2().wrap(function _callee252$(_context273){while(1)switch(_context273.prev=_context273.next){case 0:this.assertRecvDirection();if(!this._closed){_context273.next=3;break;}return _context273.abrupt("return");case 3:_iterator77=_createForOfIteratorHelper(localIds);_context273.prev=4;_iterator77.s();case 6:if((_step77=_iterator77.n()).done){_context273.next=15;break;}localId=_step77.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context273.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context273.next=6;break;case 15:_context273.next=20;break;case 17:_context273.prev=17;_context273.t0=_context273["catch"](4);_iterator77.e(_context273.t0);case 20:_context273.prev=20;_iterator77.f();return _context273.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context273.next=27;return this._pc.setRemoteDescription(offer);case 27:_context273.next=29;return this._pc.createAnswer();case 29:answer=_context273.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context273.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator78=_createForOfIteratorHelper(localIds);try{for(_iterator78.s();!(_step78=_iterator78.n()).done;){_localId9=_step78.value;this._mapMidTransceiver["delete"](_localId9);}}catch(err){_iterator78.e(err);}finally{_iterator78.f();}case 35:case"end":return _context273.stop();}},_callee252,this,[[4,17,20,23]]);}));function stopReceiving(_x231){return _stopReceiving10.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee253(localIds){var _iterator79,_step79,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee253$(_context274){while(1)switch(_context274.prev=_context274.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator79=_createForOfIteratorHelper(localIds);_context274.prev=3;_iterator79.s();case 5:if((_step79=_iterator79.n()).done){_context274.next=15;break;}localId=_step79.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context274.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context274.next=5;break;case 15:_context274.next=20;break;case 17:_context274.prev=17;_context274.t0=_context274["catch"](3);_iterator79.e(_context274.t0);case 20:_context274.prev=20;_iterator79.f();return _context274.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context274.next=27;return this._pc.setRemoteDescription(offer);case 27:_context274.next=29;return this._pc.createAnswer();case 29:answer=_context274.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context274.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context274.stop();}},_callee253,this,[[3,17,20,23]]);}));function pauseReceiving(_x232){return _pauseReceiving10.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee254(localIds){var _iterator80,_step80,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee254$(_context275){while(1)switch(_context275.prev=_context275.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator80=_createForOfIteratorHelper(localIds);_context275.prev=3;_iterator80.s();case 5:if((_step80=_iterator80.n()).done){_context275.next=15;break;}localId=_step80.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context275.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context275.next=5;break;case 15:_context275.next=20;break;case 17:_context275.prev=17;_context275.t0=_context275["catch"](3);_iterator80.e(_context275.t0);case 20:_context275.prev=20;_iterator80.f();return _context275.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context275.next=27;return this._pc.setRemoteDescription(offer);case 27:_context275.next=29;return this._pc.createAnswer();case 29:answer=_context275.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context275.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context275.stop();}},_callee254,this,[[3,17,20,23]]);}));function resumeReceiving(_x233){return _resumeReceiving10.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee255(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee255$(_context276){while(1)switch(_context276.prev=_context276.next){case 0:this.assertNotClosed();this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context276.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context276.abrupt("return",transceiver.receiver.getStats());case 6:case"end":return _context276.stop();}},_callee255,this);}));function getReceiverStats(_x234){return _getReceiverStats10.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee256(_ref95){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl28,localSdpObject;return _regeneratorRuntime2().wrap(function _callee256$(_context277){while(1)switch(_context277.prev=_context277.next){case 0:sctpStreamParameters=_ref95.sctpStreamParameters,label=_ref95.label,protocol=_ref95.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context277.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context277.next=13;return this._pc.setRemoteDescription(offer);case 13:_context277.next=15;return this._pc.createAnswer();case 15:answer=_context277.sent;if(this._transportReady){_context277.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context277.next=20;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl28=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl28!==void 0?_this$_forcedLocalDtl28:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context277.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context277.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context277.stop();}},_callee256,this);}));function receiveDataChannel(_x235){return _receiveDataChannel10.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport10=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee257(_ref96){var _this76=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee257$(_context278){while(1)switch(_context278.prev=_context278.next){case 0:localDtlsRole=_ref96.localDtlsRole,localSdpObject=_ref96.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context278.next=7;return new Promise(function(resolve,reject){_this76.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context278.stop();}},_callee257,this);}));function setupTransport(_x236){return _setupTransport10.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new ReactNativeUnifiedPlan();};}}]);}(HandlerInterface_1.HandlerInterface);exports.ReactNativeUnifiedPlan=ReactNativeUnifiedPlan;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Safari11.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Safari11Js(__unused_webpack_module,exports,__nested_webpack_require_546174__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Safari11=void 0;var sdpTransform=__importStar(__nested_webpack_require_546174__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_546174__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_546174__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_546174__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_546174__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpPlanBUtils=__importStar(__nested_webpack_require_546174__(/*! ./sdp/planBUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));var HandlerInterface_1=__nested_webpack_require_546174__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_546174__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var logger=new Logger_1.Logger('Safari11');var NAME='Safari11';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Safari11=/*#__PURE__*/function(_HandlerInterface_1$H11){function Safari11(){var _this77;_classCallCheck2(this,Safari11);_this77=_callSuper(this,Safari11);// Local stream for sending.
_this77._sendStream=new MediaStream();// Map of RTCRtpSender indexed by localId.
_this77._mapSendLocalIdRtpSender=new Map();// Next sending localId.
_this77._nextSendLocalId=0;// Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
// Value is an Object with mid, rtpParameters and rtpReceiver.
_this77._mapRecvLocalIdInfo=new Map();// Whether a DataChannel m=application section has been created.
_this77._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this77._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this77._transportReady=false;return _this77;}_inherits(Safari11,_HandlerInterface_1$H11);return _createClass2(Safari11,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee258(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee258$(_context279){while(1)switch(_context279.prev=_context279.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require',sdpSemantics:'plan-b'});_context279.prev=2;_context279.next=5;return pc.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:true});case 5:offer=_context279.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});return _context279.abrupt("return",nativeRtpCapabilities);case 12:_context279.prev=12;_context279.t0=_context279["catch"](2);try{pc.close();}catch(error2){}throw _context279.t0;case 16:case"end":return _context279.stop();}},_callee258,null,[[2,12]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities11.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee259(){return _regeneratorRuntime2().wrap(function _callee259$(_context280){while(1)switch(_context280.prev=_context280.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context280.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context280.stop();}},_callee259);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities11.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref97){var _this78=this;var direction=_ref97.direction,iceParameters=_ref97.iceParameters,iceCandidates=_ref97.iceCandidates,dtlsParameters=_ref97.dtlsParameters,sctpParameters=_ref97.sctpParameters,iceServers=_ref97.iceServers,iceTransportPolicy=_ref97.iceTransportPolicy,additionalSettings=_ref97.additionalSettings,proprietaryConstraints=_ref97.proprietaryConstraints,extendedRtpCapabilities=_ref97.extendedRtpCapabilities;logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters,planB:true});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this78.emit('@icegatheringstatechange',_this78._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this78.emit('@connectionstatechange',_this78._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this78._pc.iceConnectionState){case'checking':{_this78.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this78.emit('@connectionstatechange','connected');break;}case'failed':{_this78.emit('@connectionstatechange','failed');break;}case'disconnected':{_this78.emit('@connectionstatechange','disconnected');break;}case'closed':{_this78.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee260(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee260$(_context281){while(1)switch(_context281.prev=_context281.next){case 0:logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 4:case"end":return _context281.stop();}},_callee260,this);}));function updateIceServers(_x237){return _updateIceServers12.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee261(iceParameters){var offer,answer,_offer10,_answer10;return _regeneratorRuntime2().wrap(function _callee261$(_context282){while(1)switch(_context282.prev=_context282.next){case 0:logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context282.next=4;break;}return _context282.abrupt("return");case 4:if(!(this._direction==='send')){_context282.next=17;break;}_context282.next=7;return this._pc.createOffer({iceRestart:true});case 7:offer=_context282.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context282.next=11;return this._pc.setLocalDescription(offer);case 11:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context282.next=15;return this._pc.setRemoteDescription(answer);case 15:_context282.next=27;break;case 17:_offer10={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer10);_context282.next=21;return this._pc.setRemoteDescription(_offer10);case 21:_context282.next=23;return this._pc.createAnswer();case 23:_answer10=_context282.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer10);_context282.next=27;return this._pc.setLocalDescription(_answer10);case 27:case"end":return _context282.stop();}},_callee261,this);}));function restartIce(_x238){return _restartIce12.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee262(){return _regeneratorRuntime2().wrap(function _callee262$(_context283){while(1)switch(_context283.prev=_context283.next){case 0:return _context283.abrupt("return",this._pc.getStats());case 1:case"end":return _context283.stop();}},_callee262,this);}));function getTransportStats(){return _getTransportStats11.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee263(_ref98){var track,encodings,codecOptions,codec,offer,localSdpObject,offerMediaObject,sendingRtpParameters,sendingRemoteRtpParameters,_this$_forcedLocalDtl29,idx,_iterator81,_step81,encoding,answer,localId,rtpSender;return _regeneratorRuntime2().wrap(function _callee263$(_context284){while(1)switch(_context284.prev=_context284.next){case 0:track=_ref98.track,encodings=_ref98.encodings,codecOptions=_ref98.codecOptions,codec=_ref98.codec;this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);if(codec){logger.warn('send() | codec selection is not available in %s handler',this.name);}this._sendStream.addTrack(track);this._pc.addTrack(track,this._sendStream);_context284.next=8;return this._pc.createOffer();case 8:offer=_context284.sent;localSdpObject=sdpTransform.parse(offer.sdp);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);if(this._transportReady){_context284.next=17;break;}_context284.next=17;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl29=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl29!==void 0?_this$_forcedLocalDtl29:'client',localSdpObject:localSdpObject});case 17:if(track.kind==='video'&&encodings&&encodings.length>1){logger.debug('send() | enabling simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='video';});sdpPlanBUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,track:track,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context284.next=21;return this._pc.setLocalDescription(offer);case 21:localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type===track.kind;});// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:offerMediaObject,track:track});// Complete encodings with given values.
if(encodings){for(idx=0;idx<sendingRtpParameters.encodings.length;++idx){if(encodings[idx]){Object.assign(sendingRtpParameters.encodings[idx],encodings[idx]);}}}// If VP8 and there is effective simulcast, add scalabilityMode to each
// encoding.
if(sendingRtpParameters.encodings.length>1&&sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'){_iterator81=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator81.s();!(_step81=_iterator81.n()).done;){encoding=_step81.value;encoding.scalabilityMode='L1T3';}}catch(err){_iterator81.e(err);}finally{_iterator81.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context284.next=32;return this._pc.setRemoteDescription(answer);case 32:localId=String(this._nextSendLocalId);this._nextSendLocalId++;rtpSender=this._pc.getSenders().find(function(s){return s.track===track;});// Insert into the map.
this._mapSendLocalIdRtpSender.set(localId,rtpSender);return _context284.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:rtpSender});case 37:case"end":return _context284.stop();}},_callee263,this);}));function send(_x239){return _send11.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee264(localId){var rtpSender,offer,answer;return _regeneratorRuntime2().wrap(function _callee264$(_context285){while(1)switch(_context285.prev=_context285.next){case 0:this.assertSendDirection();rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context285.next=4;break;}throw new Error('associated RTCRtpSender not found');case 4:if(rtpSender.track){this._sendStream.removeTrack(rtpSender.track);}this._mapSendLocalIdRtpSender["delete"](localId);_context285.next=8;return this._pc.createOffer();case 8:offer=_context285.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context285.prev=10;_context285.next=13;return this._pc.setLocalDescription(offer);case 13:_context285.next=21;break;case 15:_context285.prev=15;_context285.t0=_context285["catch"](10);if(!(this._sendStream.getTracks().length===0)){_context285.next=20;break;}logger.warn('stopSending() | ignoring expected error due no sending tracks: %s',_context285.t0.toString());return _context285.abrupt("return");case 20:throw _context285.t0;case 21:if(!(this._pc.signalingState==='stable')){_context285.next=23;break;}return _context285.abrupt("return");case 23:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context285.next=27;return this._pc.setRemoteDescription(answer);case 27:case"end":return _context285.stop();}},_callee264,this,[[10,15]]);}));function stopSending(_x240){return _stopSending11.apply(this,arguments);}return stopSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"pauseSending",value:function(){var _pauseSending11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee265(localId){return _regeneratorRuntime2().wrap(function _callee265$(_context286){while(1)switch(_context286.prev=_context286.next){case 0:case"end":return _context286.stop();}},_callee265);}));function pauseSending(_x241){return _pauseSending11.apply(this,arguments);}return pauseSending;}()// eslint-disable-next-line @typescript-eslint/no-unused-vars
},{key:"resumeSending",value:function(){var _resumeSending11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee266(localId){return _regeneratorRuntime2().wrap(function _callee266$(_context287){while(1)switch(_context287.prev=_context287.next){case 0:case"end":return _context287.stop();}},_callee266);}));function resumeSending(_x242){return _resumeSending11.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee267(localId,track){var rtpSender,oldTrack;return _regeneratorRuntime2().wrap(function _callee267$(_context288){while(1)switch(_context288.prev=_context288.next){case 0:this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context288.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:oldTrack=rtpSender.track;_context288.next=8;return rtpSender.replaceTrack(track);case 8:// Remove the old track from the local stream.
if(oldTrack){this._sendStream.removeTrack(oldTrack);}// Add the new track to the local stream.
if(track){this._sendStream.addTrack(track);}case 10:case"end":return _context288.stop();}},_callee267,this);}));function replaceTrack(_x243,_x244){return _replaceTrack12.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee268(localId,spatialLayer){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee268$(_context289){while(1)switch(_context289.prev=_context289.next){case 0:this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context289.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context289.next=9;return rtpSender.setParameters(parameters);case 9:case"end":return _context289.stop();}},_callee268,this);}));function setMaxSpatialLayer(_x245,_x246){return _setMaxSpatialLayer12.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee269(localId,params){var rtpSender,parameters;return _regeneratorRuntime2().wrap(function _callee269$(_context290){while(1)switch(_context290.prev=_context290.next){case 0:this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context290.next=5;break;}throw new Error('associated RTCRtpSender not found');case 5:parameters=rtpSender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context290.next=9;return rtpSender.setParameters(parameters);case 9:case"end":return _context290.stop();}},_callee269,this);}));function setRtpEncodingParameters(_x247,_x248){return _setRtpEncodingParameters12.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee270(localId){var rtpSender;return _regeneratorRuntime2().wrap(function _callee270$(_context291){while(1)switch(_context291.prev=_context291.next){case 0:this.assertSendDirection();rtpSender=this._mapSendLocalIdRtpSender.get(localId);if(rtpSender){_context291.next=4;break;}throw new Error('associated RTCRtpSender not found');case 4:return _context291.abrupt("return",rtpSender.getStats());case 5:case"end":return _context291.stop();}},_callee270,this);}));function getSenderStats(_x249){return _getSenderStats11.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee271(_ref99){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl30,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee271$(_context292){while(1)switch(_context292.prev=_context292.next){case 0:ordered=_ref99.ordered,maxPacketLifeTime=_ref99.maxPacketLifeTime,maxRetransmits=_ref99.maxRetransmits,label=_ref99.label,protocol=_ref99.protocol;this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context292.next=24;break;}_context292.next=9;return this._pc.createOffer();case 9:offer=_context292.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context292.next=15;break;}_context292.next=15;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl30=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl30!==void 0?_this$_forcedLocalDtl30:'client',localSdpObject:localSdpObject});case 15:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context292.next=18;return this._pc.setLocalDescription(offer);case 18:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context292.next=23;return this._pc.setRemoteDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context292.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 26:case"end":return _context292.stop();}},_callee271,this);}));function sendDataChannel(_x250){return _sendDataChannel11.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee272(optionsList){var _this79=this;var results,_iterator82,_step82,options,trackId,kind,rtpParameters,streamId,mid,offer,answer,localSdpObject,_iterator83,_step83,_loop22,_this$_forcedLocalDtl31,_iterator84,_step84,_loop23;return _regeneratorRuntime2().wrap(function _callee272$(_context295){while(1)switch(_context295.prev=_context295.next){case 0:this.assertRecvDirection();results=[];_iterator82=_createForOfIteratorHelper(optionsList);try{for(_iterator82.s();!(_step82=_iterator82.n()).done;){options=_step82.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);mid=kind;this._remoteSdp.receive({mid:mid,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator82.e(err);}finally{_iterator82.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context295.next=8;return this._pc.setRemoteDescription(offer);case 8:_context295.next=10;return this._pc.createAnswer();case 10:answer=_context295.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator83=_createForOfIteratorHelper(optionsList);_context295.prev=13;_loop22=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop22(){var options,kind,rtpParameters,mid,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop22$(_context293){while(1)switch(_context293.prev=_context293.next){case 0:options=_step83.value;kind=options.kind,rtpParameters=options.rtpParameters;mid=kind;answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===mid;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context293.stop();}},_loop22);});_iterator83.s();case 16:if((_step83=_iterator83.n()).done){_context295.next=20;break;}return _context295.delegateYield(_loop22(),"t0",18);case 18:_context295.next=16;break;case 20:_context295.next=25;break;case 22:_context295.prev=22;_context295.t1=_context295["catch"](13);_iterator83.e(_context295.t1);case 25:_context295.prev=25;_iterator83.f();return _context295.finish(25);case 28:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context295.next=32;break;}_context295.next=32;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl31=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl31!==void 0?_this$_forcedLocalDtl31:'client',localSdpObject:localSdpObject});case 32:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context295.next=35;return this._pc.setLocalDescription(answer);case 35:_iterator84=_createForOfIteratorHelper(optionsList);_context295.prev=36;_loop23=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop23(){var options,kind,trackId,rtpParameters,mid,localId,rtpReceiver;return _regeneratorRuntime2().wrap(function _loop23$(_context294){while(1)switch(_context294.prev=_context294.next){case 0:options=_step84.value;kind=options.kind,trackId=options.trackId,rtpParameters=options.rtpParameters;mid=kind;localId=trackId;rtpReceiver=_this79._pc.getReceivers().find(function(r){return r.track&&r.track.id===localId;});if(rtpReceiver){_context294.next=7;break;}throw new Error('new RTCRtpReceiver not');case 7:// Insert into the map.
_this79._mapRecvLocalIdInfo.set(localId,{mid:mid,rtpParameters:rtpParameters,rtpReceiver:rtpReceiver});results.push({localId:localId,track:rtpReceiver.track,rtpReceiver:rtpReceiver});case 9:case"end":return _context294.stop();}},_loop23);});_iterator84.s();case 39:if((_step84=_iterator84.n()).done){_context295.next=43;break;}return _context295.delegateYield(_loop23(),"t2",41);case 41:_context295.next=39;break;case 43:_context295.next=48;break;case 45:_context295.prev=45;_context295.t3=_context295["catch"](36);_iterator84.e(_context295.t3);case 48:_context295.prev=48;_iterator84.f();return _context295.finish(48);case 51:return _context295.abrupt("return",results);case 52:case"end":return _context295.stop();}},_callee272,this,[[13,22,25,28],[36,45,48,51]]);}));function receive(_x251){return _receive11.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee273(localIds){var _iterator85,_step85,_this$_mapRecvLocalId5,localId,_ref100,mid,rtpParameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee273$(_context296){while(1)switch(_context296.prev=_context296.next){case 0:this.assertRecvDirection();_iterator85=_createForOfIteratorHelper(localIds);try{for(_iterator85.s();!(_step85=_iterator85.n()).done;){localId=_step85.value;logger.debug('stopReceiving() [localId:%s]',localId);_ref100=(_this$_mapRecvLocalId5=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId5!==void 0?_this$_mapRecvLocalId5:{},mid=_ref100.mid,rtpParameters=_ref100.rtpParameters;// Remove from the map.
this._mapRecvLocalIdInfo["delete"](localId);this._remoteSdp.planBStopReceiving({mid:mid,offerRtpParameters:rtpParameters});}}catch(err){_iterator85.e(err);}finally{_iterator85.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context296.next=7;return this._pc.setRemoteDescription(offer);case 7:_context296.next=9;return this._pc.createAnswer();case 9:answer=_context296.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context296.next=13;return this._pc.setLocalDescription(answer);case 13:case"end":return _context296.stop();}},_callee273,this);}));function stopReceiving(_x252){return _stopReceiving11.apply(this,arguments);}return stopReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee274(localId){var _this$_mapRecvLocalId6;var _ref101,rtpReceiver;return _regeneratorRuntime2().wrap(function _callee274$(_context297){while(1)switch(_context297.prev=_context297.next){case 0:this.assertRecvDirection();_ref101=(_this$_mapRecvLocalId6=this._mapRecvLocalIdInfo.get(localId))!==null&&_this$_mapRecvLocalId6!==void 0?_this$_mapRecvLocalId6:{},rtpReceiver=_ref101.rtpReceiver;if(rtpReceiver){_context297.next=4;break;}throw new Error('associated RTCRtpReceiver not found');case 4:return _context297.abrupt("return",rtpReceiver.getStats());case 5:case"end":return _context297.stop();}},_callee274,this);}));function getReceiverStats(_x253){return _getReceiverStats11.apply(this,arguments);}return getReceiverStats;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee275(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee275$(_context298){while(1)switch(_context298.prev=_context298.next){case 0:case"end":return _context298.stop();}},_callee275);}));function pauseReceiving(_x254){return _pauseReceiving11.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee276(// eslint-disable-next-line @typescript-eslint/no-unused-vars
localIds){return _regeneratorRuntime2().wrap(function _callee276$(_context299){while(1)switch(_context299.prev=_context299.next){case 0:case"end":return _context299.stop();}},_callee276);}));function resumeReceiving(_x255){return _resumeReceiving11.apply(this,arguments);}return resumeReceiving;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee277(_ref102){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl32,localSdpObject;return _regeneratorRuntime2().wrap(function _callee277$(_context300){while(1)switch(_context300.prev=_context300.next){case 0:sctpStreamParameters=_ref102.sctpStreamParameters,label=_ref102.label,protocol=_ref102.protocol;this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context300.next=23;break;}this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:true});offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context300.next=12;return this._pc.setRemoteDescription(offer);case 12:_context300.next=14;return this._pc.createAnswer();case 14:answer=_context300.sent;if(this._transportReady){_context300.next=19;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context300.next=19;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl32=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl32!==void 0?_this$_forcedLocalDtl32:'client',localSdpObject:localSdpObject});case 19:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context300.next=22;return this._pc.setLocalDescription(answer);case 22:this._hasDataChannelMediaSection=true;case 23:return _context300.abrupt("return",{dataChannel:dataChannel});case 24:case"end":return _context300.stop();}},_callee277,this);}));function receiveDataChannel(_x256){return _receiveDataChannel11.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport11=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee278(_ref103){var _this80=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee278$(_context301){while(1)switch(_context301.prev=_context301.next){case 0:localDtlsRole=_ref103.localDtlsRole,localSdpObject=_ref103.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context301.next=7;return new Promise(function(resolve,reject){_this80.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context301.stop();}},_callee278,this);}));function setupTransport(_x257){return _setupTransport11.apply(this,arguments);}return setupTransport;}()},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Safari11();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Safari11=Safari11;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/Safari12.js":(/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \****************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_Safari12Js(__unused_webpack_module,exports,__nested_webpack_require_581748__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.Safari12=void 0;var sdpTransform=__importStar(__nested_webpack_require_581748__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_581748__(/*! ../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var utils=__importStar(__nested_webpack_require_581748__(/*! ../utils */"./node_modules/mediasoup-client/lib/utils.js"));var ortc=__importStar(__nested_webpack_require_581748__(/*! ../ortc */"./node_modules/mediasoup-client/lib/ortc.js"));var sdpCommonUtils=__importStar(__nested_webpack_require_581748__(/*! ./sdp/commonUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));var sdpUnifiedPlanUtils=__importStar(__nested_webpack_require_581748__(/*! ./sdp/unifiedPlanUtils */"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));var ortcUtils=__importStar(__nested_webpack_require_581748__(/*! ./ortc/utils */"./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));var errors_1=__nested_webpack_require_581748__(/*! ../errors */"./node_modules/mediasoup-client/lib/errors.js");var HandlerInterface_1=__nested_webpack_require_581748__(/*! ./HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");var RemoteSdp_1=__nested_webpack_require_581748__(/*! ./sdp/RemoteSdp */"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");var scalabilityModes_1=__nested_webpack_require_581748__(/*! ../scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");var logger=new Logger_1.Logger('Safari12');var NAME='Safari12';var SCTP_NUM_STREAMS={OS:1024,MIS:1024};var Safari12=/*#__PURE__*/function(_HandlerInterface_1$H12){function Safari12(){var _this81;_classCallCheck2(this,Safari12);_this81=_callSuper(this,Safari12);// Closed flag.
_this81._closed=false;// Map of RTCTransceivers indexed by MID.
_this81._mapMidTransceiver=new Map();// Local stream for sending.
_this81._sendStream=new MediaStream();// Whether a DataChannel m=application section has been created.
_this81._hasDataChannelMediaSection=false;// Sending DataChannel id value counter. Incremented for each new DataChannel.
_this81._nextSendSctpStreamId=0;// Got transport local and remote parameters.
_this81._transportReady=false;return _this81;}_inherits(Safari12,_HandlerInterface_1$H12);return _createClass2(Safari12,[{key:"name",get:function get(){return NAME;}},{key:"close",value:function close(){logger.debug('close()');if(this._closed){return;}this._closed=true;// Close RTCPeerConnection.
if(this._pc){try{this._pc.close();}catch(error){}}this.emit('@close');}},{key:"getNativeRtpCapabilities",value:function(){var _getNativeRtpCapabilities12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee279(){var pc,offer,sdpObject,nativeRtpCapabilities;return _regeneratorRuntime2().wrap(function _callee279$(_context302){while(1)switch(_context302.prev=_context302.next){case 0:logger.debug('getNativeRtpCapabilities()');pc=new RTCPeerConnection({iceServers:[],iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'});_context302.prev=2;pc.addTransceiver('audio');pc.addTransceiver('video');_context302.next=7;return pc.createOffer();case 7:offer=_context302.sent;try{pc.close();}catch(error){}sdpObject=sdpTransform.parse(offer.sdp);nativeRtpCapabilities=sdpCommonUtils.extractRtpCapabilities({sdpObject:sdpObject});// libwebrtc supports NACK for OPUS but doesn't announce it.
ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);return _context302.abrupt("return",nativeRtpCapabilities);case 15:_context302.prev=15;_context302.t0=_context302["catch"](2);try{pc.close();}catch(error2){}throw _context302.t0;case 19:case"end":return _context302.stop();}},_callee279,null,[[2,15]]);}));function getNativeRtpCapabilities(){return _getNativeRtpCapabilities12.apply(this,arguments);}return getNativeRtpCapabilities;}()},{key:"getNativeSctpCapabilities",value:function(){var _getNativeSctpCapabilities12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee280(){return _regeneratorRuntime2().wrap(function _callee280$(_context303){while(1)switch(_context303.prev=_context303.next){case 0:logger.debug('getNativeSctpCapabilities()');return _context303.abrupt("return",{numStreams:SCTP_NUM_STREAMS});case 2:case"end":return _context303.stop();}},_callee280);}));function getNativeSctpCapabilities(){return _getNativeSctpCapabilities12.apply(this,arguments);}return getNativeSctpCapabilities;}()},{key:"run",value:function run(_ref104){var _this82=this;var direction=_ref104.direction,iceParameters=_ref104.iceParameters,iceCandidates=_ref104.iceCandidates,dtlsParameters=_ref104.dtlsParameters,sctpParameters=_ref104.sctpParameters,iceServers=_ref104.iceServers,iceTransportPolicy=_ref104.iceTransportPolicy,additionalSettings=_ref104.additionalSettings,proprietaryConstraints=_ref104.proprietaryConstraints,extendedRtpCapabilities=_ref104.extendedRtpCapabilities;this.assertNotClosed();logger.debug('run()');this._direction=direction;this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,sctpParameters:sctpParameters});this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRtpParameters('video',extendedRtpCapabilities)};this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters('audio',extendedRtpCapabilities),video:ortc.getSendingRemoteRtpParameters('video',extendedRtpCapabilities)};if(dtlsParameters.role&&dtlsParameters.role!=='auto'){this._forcedLocalDtlsRole=dtlsParameters.role==='server'?'client':'server';}this._pc=new RTCPeerConnection(_objectSpread({iceServers:iceServers!==null&&iceServers!==void 0?iceServers:[],iceTransportPolicy:iceTransportPolicy!==null&&iceTransportPolicy!==void 0?iceTransportPolicy:'all',bundlePolicy:'max-bundle',rtcpMuxPolicy:'require'},additionalSettings),proprietaryConstraints);this._pc.addEventListener('icegatheringstatechange',function(){_this82.emit('@icegatheringstatechange',_this82._pc.iceGatheringState);});if(this._pc.connectionState){this._pc.addEventListener('connectionstatechange',function(){_this82.emit('@connectionstatechange',_this82._pc.connectionState);});}else{this._pc.addEventListener('iceconnectionstatechange',function(){logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');switch(_this82._pc.iceConnectionState){case'checking':{_this82.emit('@connectionstatechange','connecting');break;}case'connected':case'completed':{_this82.emit('@connectionstatechange','connected');break;}case'failed':{_this82.emit('@connectionstatechange','failed');break;}case'disconnected':{_this82.emit('@connectionstatechange','disconnected');break;}case'closed':{_this82.emit('@connectionstatechange','closed');break;}}});}}},{key:"updateIceServers",value:function(){var _updateIceServers13=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee281(iceServers){var configuration;return _regeneratorRuntime2().wrap(function _callee281$(_context304){while(1)switch(_context304.prev=_context304.next){case 0:this.assertNotClosed();logger.debug('updateIceServers()');configuration=this._pc.getConfiguration();configuration.iceServers=iceServers;this._pc.setConfiguration(configuration);case 5:case"end":return _context304.stop();}},_callee281,this);}));function updateIceServers(_x258){return _updateIceServers13.apply(this,arguments);}return updateIceServers;}()},{key:"restartIce",value:function(){var _restartIce13=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee282(iceParameters){var offer,answer,_offer11,_answer11;return _regeneratorRuntime2().wrap(function _callee282$(_context305){while(1)switch(_context305.prev=_context305.next){case 0:this.assertNotClosed();logger.debug('restartIce()');// Provide the remote SDP handler with new remote ICE parameters.
this._remoteSdp.updateIceParameters(iceParameters);if(this._transportReady){_context305.next=5;break;}return _context305.abrupt("return");case 5:if(!(this._direction==='send')){_context305.next=18;break;}_context305.next=8;return this._pc.createOffer({iceRestart:true});case 8:offer=_context305.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]',offer);_context305.next=12;return this._pc.setLocalDescription(offer);case 12:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]',answer);_context305.next=16;return this._pc.setRemoteDescription(answer);case 16:_context305.next=28;break;case 18:_offer11={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]',_offer11);_context305.next=22;return this._pc.setRemoteDescription(_offer11);case 22:_context305.next=24;return this._pc.createAnswer();case 24:_answer11=_context305.sent;logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]',_answer11);_context305.next=28;return this._pc.setLocalDescription(_answer11);case 28:case"end":return _context305.stop();}},_callee282,this);}));function restartIce(_x259){return _restartIce13.apply(this,arguments);}return restartIce;}()},{key:"getTransportStats",value:function(){var _getTransportStats12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee283(){return _regeneratorRuntime2().wrap(function _callee283$(_context306){while(1)switch(_context306.prev=_context306.next){case 0:this.assertNotClosed();return _context306.abrupt("return",this._pc.getStats());case 2:case"end":return _context306.stop();}},_callee283,this);}));function getTransportStats(){return _getTransportStats12.apply(this,arguments);}return getTransportStats;}()},{key:"send",value:function(){var _send12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee284(_ref105){var track,encodings,codecOptions,codec,onRtpSender,sendingRtpParameters,sendingRemoteRtpParameters,mediaSectionIdx,transceiver,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl33,layers,localId,idx,_iterator86,_step86,encoding,answer;return _regeneratorRuntime2().wrap(function _callee284$(_context307){while(1)switch(_context307.prev=_context307.next){case 0:track=_ref105.track,encodings=_ref105.encodings,codecOptions=_ref105.codecOptions,codec=_ref105.codec,onRtpSender=_ref105.onRtpSender;this.assertNotClosed();this.assertSendDirection();logger.debug('send() [kind:%s, track.id:%s]',track.kind,track.id);sendingRtpParameters=utils.clone(this._sendingRtpParametersByKind[track.kind]);// This may throw.
sendingRtpParameters.codecs=ortc.reduceCodecs(sendingRtpParameters.codecs,codec);sendingRemoteRtpParameters=utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);// This may throw.
sendingRemoteRtpParameters.codecs=ortc.reduceCodecs(sendingRemoteRtpParameters.codecs,codec);mediaSectionIdx=this._remoteSdp.getNextMediaSectionIdx();transceiver=this._pc.addTransceiver(track,{direction:'sendonly',streams:[this._sendStream]});if(onRtpSender){onRtpSender(transceiver.sender);}_context307.next=13;return this._pc.createOffer();case 13:offer=_context307.sent;localSdpObject=sdpTransform.parse(offer.sdp);if(this._transportReady){_context307.next=18;break;}_context307.next=18;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl33=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl33!==void 0?_this$_forcedLocalDtl33:'client',localSdpObject:localSdpObject});case 18:layers=(0,scalabilityModes_1.parse)((encodings!==null&&encodings!==void 0?encodings:[{}])[0].scalabilityMode);if(encodings&&encodings.length>1){logger.debug('send() | enabling legacy simulcast');localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];sdpUnifiedPlanUtils.addLegacySimulcast({offerMediaObject:offerMediaObject,numStreams:encodings.length});offer={type:'offer',sdp:sdpTransform.write(localSdpObject)};}logger.debug('send() | calling pc.setLocalDescription() [offer:%o]',offer);_context307.next=23;return this._pc.setLocalDescription(offer);case 23:// We can now get the transceiver.mid.
localId=transceiver.mid;// Set MID.
sendingRtpParameters.mid=localId;localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);offerMediaObject=localSdpObject.media[mediaSectionIdx.idx];// Set RTCP CNAME.
sendingRtpParameters.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:offerMediaObject});// Set RTP encodings.
sendingRtpParameters.encodings=sdpUnifiedPlanUtils.getRtpEncodings({offerMediaObject:offerMediaObject});// Complete encodings with given values.
if(encodings){for(idx=0;idx<sendingRtpParameters.encodings.length;++idx){if(encodings[idx]){Object.assign(sendingRtpParameters.encodings[idx],encodings[idx]);}}}// If VP8 or H264 and there is effective simulcast, add scalabilityMode to
// each encoding.
if(sendingRtpParameters.encodings.length>1&&(sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/vp8'||sendingRtpParameters.codecs[0].mimeType.toLowerCase()==='video/h264')){_iterator86=_createForOfIteratorHelper(sendingRtpParameters.encodings);try{for(_iterator86.s();!(_step86=_iterator86.n()).done;){encoding=_step86.value;if(encoding.scalabilityMode){encoding.scalabilityMode="L1T".concat(layers.temporalLayers);}else{encoding.scalabilityMode='L1T3';}}}catch(err){_iterator86.e(err);}finally{_iterator86.f();}}this._remoteSdp.send({offerMediaObject:offerMediaObject,reuseMid:mediaSectionIdx.reuseMid,offerRtpParameters:sendingRtpParameters,answerRtpParameters:sendingRemoteRtpParameters,codecOptions:codecOptions});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]',answer);_context307.next=36;return this._pc.setRemoteDescription(answer);case 36:// Store in the map.
this._mapMidTransceiver.set(localId,transceiver);return _context307.abrupt("return",{localId:localId,rtpParameters:sendingRtpParameters,rtpSender:transceiver.sender});case 38:case"end":return _context307.stop();}},_callee284,this);}));function send(_x260){return _send12.apply(this,arguments);}return send;}()},{key:"stopSending",value:function(){var _stopSending12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee285(localId){var transceiver,mediaSectionClosed,offer,answer;return _regeneratorRuntime2().wrap(function _callee285$(_context308){while(1)switch(_context308.prev=_context308.next){case 0:this.assertSendDirection();if(!this._closed){_context308.next=3;break;}return _context308.abrupt("return");case 3:logger.debug('stopSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context308.next=7;break;}throw new Error('associated RTCRtpTransceiver not found');case 7:void transceiver.sender.replaceTrack(null);this._pc.removeTrack(transceiver.sender);mediaSectionClosed=this._remoteSdp.closeMediaSection(transceiver.mid);if(mediaSectionClosed){try{transceiver.stop();}catch(error){}}_context308.next=13;return this._pc.createOffer();case 13:offer=_context308.sent;logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context308.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context308.next=21;return this._pc.setRemoteDescription(answer);case 21:this._mapMidTransceiver["delete"](localId);case 22:case"end":return _context308.stop();}},_callee285,this);}));function stopSending(_x261){return _stopSending12.apply(this,arguments);}return stopSending;}()},{key:"pauseSending",value:function(){var _pauseSending12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee286(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee286$(_context309){while(1)switch(_context309.prev=_context309.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('pauseSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context309.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);_context309.next=10;return this._pc.createOffer();case 10:offer=_context309.sent;logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context309.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context309.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context309.stop();}},_callee286,this);}));function pauseSending(_x262){return _pauseSending12.apply(this,arguments);}return pauseSending;}()},{key:"resumeSending",value:function(){var _resumeSending12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee287(localId){var transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee287$(_context310){while(1)switch(_context310.prev=_context310.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('resumeSending() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context310.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:transceiver.direction='sendonly';this._remoteSdp.resumeSendingMediaSection(localId);_context310.next=10;return this._pc.createOffer();case 10:offer=_context310.sent;logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]',offer);_context310.next=14;return this._pc.setLocalDescription(offer);case 14:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]',answer);_context310.next=18;return this._pc.setRemoteDescription(answer);case 18:case"end":return _context310.stop();}},_callee287,this);}));function resumeSending(_x263){return _resumeSending12.apply(this,arguments);}return resumeSending;}()},{key:"replaceTrack",value:function(){var _replaceTrack13=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee288(localId,track){var transceiver;return _regeneratorRuntime2().wrap(function _callee288$(_context311){while(1)switch(_context311.prev=_context311.next){case 0:this.assertNotClosed();this.assertSendDirection();if(track){logger.debug('replaceTrack() [localId:%s, track.id:%s]',localId,track.id);}else{logger.debug('replaceTrack() [localId:%s, no track]',localId);}transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context311.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:_context311.next=8;return transceiver.sender.replaceTrack(track);case 8:case"end":return _context311.stop();}},_callee288,this);}));function replaceTrack(_x264,_x265){return _replaceTrack13.apply(this,arguments);}return replaceTrack;}()},{key:"setMaxSpatialLayer",value:function(){var _setMaxSpatialLayer13=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee289(localId,spatialLayer){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee289$(_context312){while(1)switch(_context312.prev=_context312.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]',localId,spatialLayer);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context312.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){if(idx<=spatialLayer){encoding.active=true;}else{encoding.active=false;}});_context312.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context312.next=13;return this._pc.createOffer();case 13:offer=_context312.sent;logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]',offer);_context312.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]',answer);_context312.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context312.stop();}},_callee289,this);}));function setMaxSpatialLayer(_x266,_x267){return _setMaxSpatialLayer13.apply(this,arguments);}return setMaxSpatialLayer;}()},{key:"setRtpEncodingParameters",value:function(){var _setRtpEncodingParameters13=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee290(localId,params){var transceiver,parameters,offer,answer;return _regeneratorRuntime2().wrap(function _callee290$(_context313){while(1)switch(_context313.prev=_context313.next){case 0:this.assertNotClosed();this.assertSendDirection();logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]',localId,params);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context313.next=6;break;}throw new Error('associated RTCRtpTransceiver not found');case 6:parameters=transceiver.sender.getParameters();parameters.encodings.forEach(function(encoding,idx){parameters.encodings[idx]=_objectSpread(_objectSpread({},encoding),params);});_context313.next=10;return transceiver.sender.setParameters(parameters);case 10:this._remoteSdp.muxMediaSectionSimulcast(localId,parameters.encodings);_context313.next=13;return this._pc.createOffer();case 13:offer=_context313.sent;logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]',offer);_context313.next=17;return this._pc.setLocalDescription(offer);case 17:answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]',answer);_context313.next=21;return this._pc.setRemoteDescription(answer);case 21:case"end":return _context313.stop();}},_callee290,this);}));function setRtpEncodingParameters(_x268,_x269){return _setRtpEncodingParameters13.apply(this,arguments);}return setRtpEncodingParameters;}()},{key:"getSenderStats",value:function(){var _getSenderStats12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee291(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee291$(_context314){while(1)switch(_context314.prev=_context314.next){case 0:this.assertNotClosed();this.assertSendDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context314.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context314.abrupt("return",transceiver.sender.getStats());case 6:case"end":return _context314.stop();}},_callee291,this);}));function getSenderStats(_x270){return _getSenderStats12.apply(this,arguments);}return getSenderStats;}()},{key:"sendDataChannel",value:function(){var _sendDataChannel12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee292(_ref106){var ordered,maxPacketLifeTime,maxRetransmits,label,protocol,options,dataChannel,offer,localSdpObject,offerMediaObject,_this$_forcedLocalDtl34,answer,sctpStreamParameters;return _regeneratorRuntime2().wrap(function _callee292$(_context315){while(1)switch(_context315.prev=_context315.next){case 0:ordered=_ref106.ordered,maxPacketLifeTime=_ref106.maxPacketLifeTime,maxRetransmits=_ref106.maxRetransmits,label=_ref106.label,protocol=_ref106.protocol;this.assertNotClosed();this.assertSendDirection();options={negotiated:true,id:this._nextSendSctpStreamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('sendDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// Increase next id.
this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS;// If this is the first DataChannel we need to create the SDP answer with
// m=application section.
if(this._hasDataChannelMediaSection){_context315.next=25;break;}_context315.next=10;return this._pc.createOffer();case 10:offer=_context315.sent;localSdpObject=sdpTransform.parse(offer.sdp);offerMediaObject=localSdpObject.media.find(function(m){return m.type==='application';});if(this._transportReady){_context315.next=16;break;}_context315.next=16;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl34=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl34!==void 0?_this$_forcedLocalDtl34:'client',localSdpObject:localSdpObject});case 16:logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]',offer);_context315.next=19;return this._pc.setLocalDescription(offer);case 19:this._remoteSdp.sendSctpAssociation({offerMediaObject:offerMediaObject});answer={type:'answer',sdp:this._remoteSdp.getSdp()};logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context315.next=24;return this._pc.setRemoteDescription(answer);case 24:this._hasDataChannelMediaSection=true;case 25:sctpStreamParameters={streamId:options.id,ordered:options.ordered,maxPacketLifeTime:options.maxPacketLifeTime,maxRetransmits:options.maxRetransmits};return _context315.abrupt("return",{dataChannel:dataChannel,sctpStreamParameters:sctpStreamParameters});case 27:case"end":return _context315.stop();}},_callee292,this);}));function sendDataChannel(_x271){return _sendDataChannel12.apply(this,arguments);}return sendDataChannel;}()},{key:"receive",value:function(){var _receive12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee293(optionsList){var _this83=this;var results,mapLocalId,_iterator87,_step87,_rtpParameters$mid7,options,trackId,kind,rtpParameters,streamId,localId,offer,_iterator88,_step88,_loop24,answer,localSdpObject,_iterator89,_step89,_loop25,_this$_forcedLocalDtl35,_iterator90,_step90,_loop26;return _regeneratorRuntime2().wrap(function _callee293$(_context319){while(1)switch(_context319.prev=_context319.next){case 0:this.assertNotClosed();this.assertRecvDirection();results=[];mapLocalId=new Map();_iterator87=_createForOfIteratorHelper(optionsList);try{for(_iterator87.s();!(_step87=_iterator87.n()).done;){options=_step87.value;trackId=options.trackId,kind=options.kind,rtpParameters=options.rtpParameters,streamId=options.streamId;logger.debug('receive() [trackId:%s, kind:%s]',trackId,kind);localId=(_rtpParameters$mid7=rtpParameters.mid)!==null&&_rtpParameters$mid7!==void 0?_rtpParameters$mid7:String(this._mapMidTransceiver.size);mapLocalId.set(trackId,localId);this._remoteSdp.receive({mid:localId,kind:kind,offerRtpParameters:rtpParameters,streamId:streamId!==null&&streamId!==void 0?streamId:rtpParameters.rtcp.cname,trackId:trackId});}}catch(err){_iterator87.e(err);}finally{_iterator87.f();}offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]',offer);_context319.next=10;return this._pc.setRemoteDescription(offer);case 10:_iterator88=_createForOfIteratorHelper(optionsList);_context319.prev=11;_loop24=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop24(){var options,trackId,onRtpReceiver,_localId10,transceiver;return _regeneratorRuntime2().wrap(function _loop24$(_context316){while(1)switch(_context316.prev=_context316.next){case 0:options=_step88.value;trackId=options.trackId,onRtpReceiver=options.onRtpReceiver;if(!onRtpReceiver){_context316.next=8;break;}_localId10=mapLocalId.get(trackId);transceiver=_this83._pc.getTransceivers().find(function(t){return t.mid===_localId10;});if(transceiver){_context316.next=7;break;}throw new Error('transceiver not found');case 7:onRtpReceiver(transceiver.receiver);case 8:case"end":return _context316.stop();}},_loop24);});_iterator88.s();case 14:if((_step88=_iterator88.n()).done){_context319.next=18;break;}return _context319.delegateYield(_loop24(),"t0",16);case 16:_context319.next=14;break;case 18:_context319.next=23;break;case 20:_context319.prev=20;_context319.t1=_context319["catch"](11);_iterator88.e(_context319.t1);case 23:_context319.prev=23;_iterator88.f();return _context319.finish(23);case 26:_context319.next=28;return this._pc.createAnswer();case 28:answer=_context319.sent;localSdpObject=sdpTransform.parse(answer.sdp);_iterator89=_createForOfIteratorHelper(optionsList);_context319.prev=31;_loop25=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop25(){var options,trackId,rtpParameters,localId,answerMediaObject;return _regeneratorRuntime2().wrap(function _loop25$(_context317){while(1)switch(_context317.prev=_context317.next){case 0:options=_step89.value;trackId=options.trackId,rtpParameters=options.rtpParameters;localId=mapLocalId.get(trackId);answerMediaObject=localSdpObject.media.find(function(m){return String(m.mid)===localId;});// May need to modify codec parameters in the answer based on codec
// parameters in the offer.
sdpCommonUtils.applyCodecParameters({offerRtpParameters:rtpParameters,answerMediaObject:answerMediaObject});case 5:case"end":return _context317.stop();}},_loop25);});_iterator89.s();case 34:if((_step89=_iterator89.n()).done){_context319.next=38;break;}return _context319.delegateYield(_loop25(),"t2",36);case 36:_context319.next=34;break;case 38:_context319.next=43;break;case 40:_context319.prev=40;_context319.t3=_context319["catch"](31);_iterator89.e(_context319.t3);case 43:_context319.prev=43;_iterator89.f();return _context319.finish(43);case 46:answer={type:'answer',sdp:sdpTransform.write(localSdpObject)};if(this._transportReady){_context319.next=50;break;}_context319.next=50;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl35=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl35!==void 0?_this$_forcedLocalDtl35:'client',localSdpObject:localSdpObject});case 50:logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]',answer);_context319.next=53;return this._pc.setLocalDescription(answer);case 53:_iterator90=_createForOfIteratorHelper(optionsList);_context319.prev=54;_loop26=/*#__PURE__*/_regeneratorRuntime2().mark(function _loop26(){var options,trackId,localId,transceiver;return _regeneratorRuntime2().wrap(function _loop26$(_context318){while(1)switch(_context318.prev=_context318.next){case 0:options=_step90.value;trackId=options.trackId;localId=mapLocalId.get(trackId);transceiver=_this83._pc.getTransceivers().find(function(t){return t.mid===localId;});if(transceiver){_context318.next=6;break;}throw new Error('new RTCRtpTransceiver not found');case 6:// Store in the map.
_this83._mapMidTransceiver.set(localId,transceiver);results.push({localId:localId,track:transceiver.receiver.track,rtpReceiver:transceiver.receiver});case 8:case"end":return _context318.stop();}},_loop26);});_iterator90.s();case 57:if((_step90=_iterator90.n()).done){_context319.next=61;break;}return _context319.delegateYield(_loop26(),"t4",59);case 59:_context319.next=57;break;case 61:_context319.next=66;break;case 63:_context319.prev=63;_context319.t5=_context319["catch"](54);_iterator90.e(_context319.t5);case 66:_context319.prev=66;_iterator90.f();return _context319.finish(66);case 69:return _context319.abrupt("return",results);case 70:case"end":return _context319.stop();}},_callee293,this,[[11,20,23,26],[31,40,43,46],[54,63,66,69]]);}));function receive(_x272){return _receive12.apply(this,arguments);}return receive;}()},{key:"stopReceiving",value:function(){var _stopReceiving12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee294(localIds){var _iterator91,_step91,localId,transceiver,offer,answer,_iterator92,_step92,_localId11;return _regeneratorRuntime2().wrap(function _callee294$(_context320){while(1)switch(_context320.prev=_context320.next){case 0:this.assertRecvDirection();if(!this._closed){_context320.next=3;break;}return _context320.abrupt("return");case 3:_iterator91=_createForOfIteratorHelper(localIds);_context320.prev=4;_iterator91.s();case 6:if((_step91=_iterator91.n()).done){_context320.next=15;break;}localId=_step91.value;logger.debug('stopReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context320.next=12;break;}throw new Error('associated RTCRtpTransceiver not found');case 12:this._remoteSdp.closeMediaSection(transceiver.mid);case 13:_context320.next=6;break;case 15:_context320.next=20;break;case 17:_context320.prev=17;_context320.t0=_context320["catch"](4);_iterator91.e(_context320.t0);case 20:_context320.prev=20;_iterator91.f();return _context320.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context320.next=27;return this._pc.setRemoteDescription(offer);case 27:_context320.next=29;return this._pc.createAnswer();case 29:answer=_context320.sent;logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context320.next=33;return this._pc.setLocalDescription(answer);case 33:_iterator92=_createForOfIteratorHelper(localIds);try{for(_iterator92.s();!(_step92=_iterator92.n()).done;){_localId11=_step92.value;this._mapMidTransceiver["delete"](_localId11);}}catch(err){_iterator92.e(err);}finally{_iterator92.f();}case 35:case"end":return _context320.stop();}},_callee294,this,[[4,17,20,23]]);}));function stopReceiving(_x273){return _stopReceiving12.apply(this,arguments);}return stopReceiving;}()},{key:"pauseReceiving",value:function(){var _pauseReceiving12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee295(localIds){var _iterator93,_step93,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee295$(_context321){while(1)switch(_context321.prev=_context321.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator93=_createForOfIteratorHelper(localIds);_context321.prev=3;_iterator93.s();case 5:if((_step93=_iterator93.n()).done){_context321.next=15;break;}localId=_step93.value;logger.debug('pauseReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context321.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='inactive';this._remoteSdp.pauseMediaSection(localId);case 13:_context321.next=5;break;case 15:_context321.next=20;break;case 17:_context321.prev=17;_context321.t0=_context321["catch"](3);_iterator93.e(_context321.t0);case 20:_context321.prev=20;_iterator93.f();return _context321.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context321.next=27;return this._pc.setRemoteDescription(offer);case 27:_context321.next=29;return this._pc.createAnswer();case 29:answer=_context321.sent;logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context321.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context321.stop();}},_callee295,this,[[3,17,20,23]]);}));function pauseReceiving(_x274){return _pauseReceiving12.apply(this,arguments);}return pauseReceiving;}()},{key:"resumeReceiving",value:function(){var _resumeReceiving12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee296(localIds){var _iterator94,_step94,localId,transceiver,offer,answer;return _regeneratorRuntime2().wrap(function _callee296$(_context322){while(1)switch(_context322.prev=_context322.next){case 0:this.assertNotClosed();this.assertRecvDirection();_iterator94=_createForOfIteratorHelper(localIds);_context322.prev=3;_iterator94.s();case 5:if((_step94=_iterator94.n()).done){_context322.next=15;break;}localId=_step94.value;logger.debug('resumeReceiving() [localId:%s]',localId);transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context322.next=11;break;}throw new Error('associated RTCRtpTransceiver not found');case 11:transceiver.direction='recvonly';this._remoteSdp.resumeReceivingMediaSection(localId);case 13:_context322.next=5;break;case 15:_context322.next=20;break;case 17:_context322.prev=17;_context322.t0=_context322["catch"](3);_iterator94.e(_context322.t0);case 20:_context322.prev=20;_iterator94.f();return _context322.finish(20);case 23:offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]',offer);_context322.next=27;return this._pc.setRemoteDescription(offer);case 27:_context322.next=29;return this._pc.createAnswer();case 29:answer=_context322.sent;logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]',answer);_context322.next=33;return this._pc.setLocalDescription(answer);case 33:case"end":return _context322.stop();}},_callee296,this,[[3,17,20,23]]);}));function resumeReceiving(_x275){return _resumeReceiving12.apply(this,arguments);}return resumeReceiving;}()},{key:"getReceiverStats",value:function(){var _getReceiverStats12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee297(localId){var transceiver;return _regeneratorRuntime2().wrap(function _callee297$(_context323){while(1)switch(_context323.prev=_context323.next){case 0:this.assertNotClosed();this.assertRecvDirection();transceiver=this._mapMidTransceiver.get(localId);if(transceiver){_context323.next=5;break;}throw new Error('associated RTCRtpTransceiver not found');case 5:return _context323.abrupt("return",transceiver.receiver.getStats());case 6:case"end":return _context323.stop();}},_callee297,this);}));function getReceiverStats(_x276){return _getReceiverStats12.apply(this,arguments);}return getReceiverStats;}()},{key:"receiveDataChannel",value:function(){var _receiveDataChannel12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee298(_ref107){var sctpStreamParameters,label,protocol,streamId,ordered,maxPacketLifeTime,maxRetransmits,options,dataChannel,offer,answer,_this$_forcedLocalDtl36,localSdpObject;return _regeneratorRuntime2().wrap(function _callee298$(_context324){while(1)switch(_context324.prev=_context324.next){case 0:sctpStreamParameters=_ref107.sctpStreamParameters,label=_ref107.label,protocol=_ref107.protocol;this.assertNotClosed();this.assertRecvDirection();streamId=sctpStreamParameters.streamId,ordered=sctpStreamParameters.ordered,maxPacketLifeTime=sctpStreamParameters.maxPacketLifeTime,maxRetransmits=sctpStreamParameters.maxRetransmits;options={negotiated:true,id:streamId,ordered:ordered,maxPacketLifeTime:maxPacketLifeTime,maxRetransmits:maxRetransmits,protocol:protocol};logger.debug('receiveDataChannel() [options:%o]',options);dataChannel=this._pc.createDataChannel(label,options);// If this is the first DataChannel we need to create the SDP offer with
// m=application section.
if(this._hasDataChannelMediaSection){_context324.next=24;break;}this._remoteSdp.receiveSctpAssociation();offer={type:'offer',sdp:this._remoteSdp.getSdp()};logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]',offer);_context324.next=13;return this._pc.setRemoteDescription(offer);case 13:_context324.next=15;return this._pc.createAnswer();case 15:answer=_context324.sent;if(this._transportReady){_context324.next=20;break;}localSdpObject=sdpTransform.parse(answer.sdp);_context324.next=20;return this.setupTransport({localDtlsRole:(_this$_forcedLocalDtl36=this._forcedLocalDtlsRole)!==null&&_this$_forcedLocalDtl36!==void 0?_this$_forcedLocalDtl36:'client',localSdpObject:localSdpObject});case 20:logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]',answer);_context324.next=23;return this._pc.setLocalDescription(answer);case 23:this._hasDataChannelMediaSection=true;case 24:return _context324.abrupt("return",{dataChannel:dataChannel});case 25:case"end":return _context324.stop();}},_callee298,this);}));function receiveDataChannel(_x277){return _receiveDataChannel12.apply(this,arguments);}return receiveDataChannel;}()},{key:"setupTransport",value:function(){var _setupTransport12=_asyncToGenerator2(/*#__PURE__*/_regeneratorRuntime2().mark(function _callee299(_ref108){var _this84=this;var localDtlsRole,localSdpObject,dtlsParameters;return _regeneratorRuntime2().wrap(function _callee299$(_context325){while(1)switch(_context325.prev=_context325.next){case 0:localDtlsRole=_ref108.localDtlsRole,localSdpObject=_ref108.localSdpObject;if(!localSdpObject){localSdpObject=sdpTransform.parse(this._pc.localDescription.sdp);}// Get our local DTLS parameters.
dtlsParameters=sdpCommonUtils.extractDtlsParameters({sdpObject:localSdpObject});// Set our DTLS role.
dtlsParameters.role=localDtlsRole;// Update the remote DTLS role in the SDP.
this._remoteSdp.updateDtlsRole(localDtlsRole==='client'?'server':'client');// Need to tell the remote transport about our parameters.
_context325.next=7;return new Promise(function(resolve,reject){_this84.safeEmit('@connect',{dtlsParameters:dtlsParameters},resolve,reject);});case 7:this._transportReady=true;case 8:case"end":return _context325.stop();}},_callee299,this);}));function setupTransport(_x278){return _setupTransport12.apply(this,arguments);}return setupTransport;}()},{key:"assertNotClosed",value:function assertNotClosed(){if(this._closed){throw new errors_1.InvalidStateError('method called in a closed handler');}}},{key:"assertSendDirection",value:function assertSendDirection(){if(this._direction!=='send'){throw new Error('method can just be called for handlers with "send" direction');}}},{key:"assertRecvDirection",value:function assertRecvDirection(){if(this._direction!=='recv'){throw new Error('method can just be called for handlers with "recv" direction');}}}],[{key:"createFactory",value:/**
     * Creates a factory function.
     */function createFactory(){return function(){return new Safari12();};}}]);}(HandlerInterface_1.HandlerInterface);exports.Safari12=Safari12;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":(/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \**********************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_ortc_edgeUtilsJs(__unused_webpack_module,exports,__nested_webpack_require_624878__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.getCapabilities=getCapabilities;exports.mangleRtpParameters=mangleRtpParameters;var utils=__importStar(__nested_webpack_require_624878__(/*! ../../utils */"./node_modules/mediasoup-client/lib/utils.js"));/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */function getCapabilities(){var _caps$codecs;var nativeCaps=RTCRtpReceiver.getCapabilities();var caps=utils.clone(nativeCaps);var _iterator95=_createForOfIteratorHelper((_caps$codecs=caps.codecs)!==null&&_caps$codecs!==void 0?_caps$codecs:[]),_step95;try{for(_iterator95.s();!(_step95=_iterator95.n()).done;){var _codec$mimeType,_codec$rtcpFeedback;var codec=_step95.value;// Rename numChannels to channels.
// @ts-expect-error --- On purpose.
codec.channels=codec.numChannels;// @ts-expect-error --- On purpose.
delete codec.numChannels;// Add mimeType.
// @ts-expect-error --- On purpose (due to codec.name).
codec.mimeType=(_codec$mimeType=codec.mimeType)!==null&&_codec$mimeType!==void 0?_codec$mimeType:"".concat(codec.kind,"/").concat(codec.name);// NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
if(codec.parameters){var parameters=codec.parameters;if(parameters.apt){parameters.apt=Number(parameters.apt);}if(parameters['packetization-mode']){parameters['packetization-mode']=Number(parameters['packetization-mode']);}}// Delete emty parameter String in rtcpFeedback.
var _iterator96=_createForOfIteratorHelper((_codec$rtcpFeedback=codec.rtcpFeedback)!==null&&_codec$rtcpFeedback!==void 0?_codec$rtcpFeedback:[]),_step96;try{for(_iterator96.s();!(_step96=_iterator96.n()).done;){var feedback=_step96.value;if(!feedback.parameter){feedback.parameter='';}}}catch(err){_iterator96.e(err);}finally{_iterator96.f();}}}catch(err){_iterator95.e(err);}finally{_iterator95.f();}return caps;}/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */function mangleRtpParameters(rtpParameters){var params=utils.clone(rtpParameters);// Rename mid to muxId.
if(params.mid){// @ts-expect-error --- On purpose (due to muxId).
params.muxId=params.mid;delete params.mid;}var _iterator97=_createForOfIteratorHelper(params.codecs),_step97;try{for(_iterator97.s();!(_step97=_iterator97.n()).done;){var codec=_step97.value;// Rename channels to numChannels.
if(codec.channels){// @ts-expect-error --- On purpose.
codec.numChannels=codec.channels;delete codec.channels;}// Add codec.name (requried by Edge).
// @ts-expect-error --- On purpose (due to name).
if(codec.mimeType&&!codec.name){// @ts-expect-error --- On purpose (due to name).
codec.name=codec.mimeType.split('/')[1];}// Remove mimeType.
// @ts-expect-error --- On purpose.
delete codec.mimeType;}}catch(err){_iterator97.e(err);}finally{_iterator97.f();}return params;}/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/ortc/utils.js":(/*!******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/utils.js ***!
  \******************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_ortc_utilsJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.addNackSuppportForOpus=addNackSuppportForOpus;/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */function addNackSuppportForOpus(rtpCapabilities){var _rtpCapabilities$code;var _iterator98=_createForOfIteratorHelper((_rtpCapabilities$code=rtpCapabilities.codecs)!==null&&_rtpCapabilities$code!==void 0?_rtpCapabilities$code:[]),_step98;try{for(_iterator98.s();!(_step98=_iterator98.n()).done;){var _codec$rtcpFeedback2;var codec=_step98.value;if((codec.mimeType.toLowerCase()==='audio/opus'||codec.mimeType.toLowerCase()==='audio/multiopus')&&!((_codec$rtcpFeedback2=codec.rtcpFeedback)!==null&&_codec$rtcpFeedback2!==void 0&&_codec$rtcpFeedback2.some(function(fb){return fb.type==='nack'&&!fb.parameter;}))){if(!codec.rtcpFeedback){codec.rtcpFeedback=[];}codec.rtcpFeedback.push({type:'nack'});}}}catch(err){_iterator98.e(err);}finally{_iterator98.f();}}/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":(/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \************************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_sdp_MediaSectionJs(__unused_webpack_module,exports,__nested_webpack_require_630325__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.OfferMediaSection=exports.AnswerMediaSection=exports.MediaSection=void 0;var sdpTransform=__importStar(__nested_webpack_require_630325__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var utils=__importStar(__nested_webpack_require_630325__(/*! ../../utils */"./node_modules/mediasoup-client/lib/utils.js"));var MediaSection=/*#__PURE__*/function(){function MediaSection(_ref109){var iceParameters=_ref109.iceParameters,iceCandidates=_ref109.iceCandidates,dtlsParameters=_ref109.dtlsParameters,_ref109$planB=_ref109.planB,planB=_ref109$planB===void 0?false:_ref109$planB;_classCallCheck2(this,MediaSection);this._mediaObject={};this._planB=planB;if(iceParameters){this.setIceParameters(iceParameters);}if(iceCandidates){this._mediaObject.candidates=[];var _iterator99=_createForOfIteratorHelper(iceCandidates),_step99;try{for(_iterator99.s();!(_step99=_iterator99.n()).done;){var _candidate$address;var candidate=_step99.value;var candidateObject={};// mediasoup does mandates rtcp-mux so candidates component is always
// RTP (1).
candidateObject.component=1;candidateObject.foundation=candidate.foundation;// Be ready for new candidate.address field in mediasoup server side
// field and keep backward compatibility with deprecated candidate.ip.
candidateObject.ip=(_candidate$address=candidate.address)!==null&&_candidate$address!==void 0?_candidate$address:candidate.ip;candidateObject.port=candidate.port;candidateObject.priority=candidate.priority;candidateObject.transport=candidate.protocol;candidateObject.type=candidate.type;if(candidate.tcpType){candidateObject.tcptype=candidate.tcpType;}this._mediaObject.candidates.push(candidateObject);}}catch(err){_iterator99.e(err);}finally{_iterator99.f();}this._mediaObject.endOfCandidates='end-of-candidates';this._mediaObject.iceOptions='renomination';}if(dtlsParameters){this.setDtlsRole(dtlsParameters.role);}}return _createClass2(MediaSection,[{key:"mid",get:function get(){return String(this._mediaObject.mid);}},{key:"closed",get:function get(){return this._mediaObject.port===0;}},{key:"getObject",value:function getObject(){return this._mediaObject;}},{key:"setIceParameters",value:function setIceParameters(iceParameters){this._mediaObject.iceUfrag=iceParameters.usernameFragment;this._mediaObject.icePwd=iceParameters.password;}},{key:"pause",value:function pause(){this._mediaObject.direction='inactive';}},{key:"disable",value:function disable(){this.pause();delete this._mediaObject.ext;delete this._mediaObject.ssrcs;delete this._mediaObject.ssrcGroups;delete this._mediaObject.simulcast;delete this._mediaObject.simulcast_03;delete this._mediaObject.rids;delete this._mediaObject.extmapAllowMixed;}},{key:"close",value:function close(){this.disable();this._mediaObject.port=0;}}]);}();exports.MediaSection=MediaSection;var AnswerMediaSection=/*#__PURE__*/function(_MediaSection){function AnswerMediaSection(_ref110){var _this85;var iceParameters=_ref110.iceParameters,iceCandidates=_ref110.iceCandidates,dtlsParameters=_ref110.dtlsParameters,sctpParameters=_ref110.sctpParameters,plainRtpParameters=_ref110.plainRtpParameters,_ref110$planB=_ref110.planB,planB=_ref110$planB===void 0?false:_ref110$planB,offerMediaObject=_ref110.offerMediaObject,offerRtpParameters=_ref110.offerRtpParameters,answerRtpParameters=_ref110.answerRtpParameters,codecOptions=_ref110.codecOptions,_ref110$extmapAllowMi=_ref110.extmapAllowMixed,extmapAllowMixed=_ref110$extmapAllowMi===void 0?false:_ref110$extmapAllowMi;_classCallCheck2(this,AnswerMediaSection);_this85=_callSuper(this,AnswerMediaSection,[{iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,planB:planB}]);_this85._mediaObject.mid=String(offerMediaObject.mid);_this85._mediaObject.type=offerMediaObject.type;_this85._mediaObject.protocol=offerMediaObject.protocol;if(!plainRtpParameters){_this85._mediaObject.connection={ip:'127.0.0.1',version:4};_this85._mediaObject.port=7;}else{_this85._mediaObject.connection={ip:plainRtpParameters.ip,version:plainRtpParameters.ipVersion};_this85._mediaObject.port=plainRtpParameters.port;}switch(offerMediaObject.type){case'audio':case'video':{_this85._mediaObject.direction='recvonly';_this85._mediaObject.rtp=[];_this85._mediaObject.rtcpFb=[];_this85._mediaObject.fmtp=[];var _iterator100=_createForOfIteratorHelper(answerRtpParameters.codecs),_step100;try{var _loop27=function _loop27(){var _utils$clone2,_utils$clone3;var codec=_step100.value;var rtp={payload:codec.payloadType,codec:getCodecName(codec),rate:codec.clockRate};if(codec.channels>1){rtp.encoding=codec.channels;}_this85._mediaObject.rtp.push(rtp);var codecParameters=(_utils$clone2=utils.clone(codec.parameters))!==null&&_utils$clone2!==void 0?_utils$clone2:{};var codecRtcpFeedback=(_utils$clone3=utils.clone(codec.rtcpFeedback))!==null&&_utils$clone3!==void 0?_utils$clone3:[];if(codecOptions){var opusStereo=codecOptions.opusStereo,opusFec=codecOptions.opusFec,opusDtx=codecOptions.opusDtx,opusMaxPlaybackRate=codecOptions.opusMaxPlaybackRate,opusMaxAverageBitrate=codecOptions.opusMaxAverageBitrate,opusPtime=codecOptions.opusPtime,opusNack=codecOptions.opusNack,videoGoogleStartBitrate=codecOptions.videoGoogleStartBitrate,videoGoogleMaxBitrate=codecOptions.videoGoogleMaxBitrate,videoGoogleMinBitrate=codecOptions.videoGoogleMinBitrate;var offerCodec=offerRtpParameters.codecs.find(function(c){return c.payloadType===codec.payloadType;});switch(codec.mimeType.toLowerCase()){case'audio/opus':case'audio/multiopus':{if(opusStereo!==undefined){offerCodec.parameters['sprop-stereo']=opusStereo?1:0;codecParameters.stereo=opusStereo?1:0;}if(opusFec!==undefined){offerCodec.parameters.useinbandfec=opusFec?1:0;codecParameters.useinbandfec=opusFec?1:0;}if(opusDtx!==undefined){offerCodec.parameters.usedtx=opusDtx?1:0;codecParameters.usedtx=opusDtx?1:0;}if(opusMaxPlaybackRate!==undefined){codecParameters.maxplaybackrate=opusMaxPlaybackRate;}if(opusMaxAverageBitrate!==undefined){codecParameters.maxaveragebitrate=opusMaxAverageBitrate;}if(opusPtime!==undefined){offerCodec.parameters.ptime=opusPtime;codecParameters.ptime=opusPtime;}// If opusNack is not set, we must remove NACK support for OPUS.
// Otherwise it would be enabled for those handlers that artificially
// announce it in their RTP capabilities.
if(!opusNack){offerCodec.rtcpFeedback=offerCodec.rtcpFeedback.filter(function(fb){return fb.type!=='nack'||fb.parameter;});codecRtcpFeedback=codecRtcpFeedback.filter(function(fb){return fb.type!=='nack'||fb.parameter;});}break;}case'video/vp8':case'video/vp9':case'video/h264':case'video/h265':{if(videoGoogleStartBitrate!==undefined){codecParameters['x-google-start-bitrate']=videoGoogleStartBitrate;}if(videoGoogleMaxBitrate!==undefined){codecParameters['x-google-max-bitrate']=videoGoogleMaxBitrate;}if(videoGoogleMinBitrate!==undefined){codecParameters['x-google-min-bitrate']=videoGoogleMinBitrate;}break;}}}var fmtp={payload:codec.payloadType,config:''};for(var _i=0,_Object$keys=Object.keys(codecParameters);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];if(fmtp.config){fmtp.config+=';';}fmtp.config+="".concat(key,"=").concat(codecParameters[key]);}if(fmtp.config){_this85._mediaObject.fmtp.push(fmtp);}var _iterator104=_createForOfIteratorHelper(codecRtcpFeedback),_step104;try{for(_iterator104.s();!(_step104=_iterator104.n()).done;){var fb=_step104.value;_this85._mediaObject.rtcpFb.push({payload:codec.payloadType,type:fb.type,subtype:fb.parameter});}}catch(err){_iterator104.e(err);}finally{_iterator104.f();}};for(_iterator100.s();!(_step100=_iterator100.n()).done;){_loop27();}}catch(err){_iterator100.e(err);}finally{_iterator100.f();}_this85._mediaObject.payloads=answerRtpParameters.codecs.map(function(codec){return codec.payloadType;}).join(' ');_this85._mediaObject.ext=[];var _iterator101=_createForOfIteratorHelper(answerRtpParameters.headerExtensions),_step101;try{var _loop28=function _loop28(){var _offerMediaObject$ext;var ext=_step101.value;// Don't add a header extension if not present in the offer.
var found=((_offerMediaObject$ext=offerMediaObject.ext)!==null&&_offerMediaObject$ext!==void 0?_offerMediaObject$ext:[]).some(function(localExt){return localExt.uri===ext.uri;});if(!found){return 1;// continue
}_this85._mediaObject.ext.push({uri:ext.uri,value:ext.id});};for(_iterator101.s();!(_step101=_iterator101.n()).done;){if(_loop28())continue;}// Allow both 1 byte and 2 bytes length header extensions.
}catch(err){_iterator101.e(err);}finally{_iterator101.f();}if(extmapAllowMixed&&offerMediaObject.extmapAllowMixed==='extmap-allow-mixed'){_this85._mediaObject.extmapAllowMixed='extmap-allow-mixed';}// Simulcast.
if(offerMediaObject.simulcast){var _offerMediaObject$rid;_this85._mediaObject.simulcast={dir1:'recv',list1:offerMediaObject.simulcast.list1};_this85._mediaObject.rids=[];var _iterator102=_createForOfIteratorHelper((_offerMediaObject$rid=offerMediaObject.rids)!==null&&_offerMediaObject$rid!==void 0?_offerMediaObject$rid:[]),_step102;try{for(_iterator102.s();!(_step102=_iterator102.n()).done;){var rid=_step102.value;if(rid.direction!=='send'){continue;}_this85._mediaObject.rids.push({id:rid.id,direction:'recv'});}}catch(err){_iterator102.e(err);}finally{_iterator102.f();}}// Simulcast (draft version 03).
else if(offerMediaObject.simulcast_03){var _offerMediaObject$rid2;_this85._mediaObject.simulcast_03={value:offerMediaObject.simulcast_03.value.replace(/send/g,'recv')};_this85._mediaObject.rids=[];var _iterator103=_createForOfIteratorHelper((_offerMediaObject$rid2=offerMediaObject.rids)!==null&&_offerMediaObject$rid2!==void 0?_offerMediaObject$rid2:[]),_step103;try{for(_iterator103.s();!(_step103=_iterator103.n()).done;){var _rid=_step103.value;if(_rid.direction!=='send'){continue;}_this85._mediaObject.rids.push({id:_rid.id,direction:'recv'});}}catch(err){_iterator103.e(err);}finally{_iterator103.f();}}_this85._mediaObject.rtcpMux='rtcp-mux';_this85._mediaObject.rtcpRsize='rtcp-rsize';if(_this85._planB&&_this85._mediaObject.type==='video'){_this85._mediaObject.xGoogleFlag='conference';}break;}case'application':{// New spec.
if(typeof offerMediaObject.sctpPort==='number'){_this85._mediaObject.payloads='webrtc-datachannel';_this85._mediaObject.sctpPort=sctpParameters.port;_this85._mediaObject.maxMessageSize=sctpParameters.maxMessageSize;}// Old spec.
else if(offerMediaObject.sctpmap){_this85._mediaObject.payloads=sctpParameters.port;_this85._mediaObject.sctpmap={app:'webrtc-datachannel',sctpmapNumber:sctpParameters.port,maxMessageSize:sctpParameters.maxMessageSize};}break;}}return _this85;}_inherits(AnswerMediaSection,_MediaSection);return _createClass2(AnswerMediaSection,[{key:"setDtlsRole",value:function setDtlsRole(role){switch(role){case'client':{this._mediaObject.setup='active';break;}case'server':{this._mediaObject.setup='passive';break;}case'auto':{this._mediaObject.setup='actpass';break;}}}},{key:"resume",value:function resume(){this._mediaObject.direction='recvonly';}},{key:"muxSimulcastStreams",value:function muxSimulcastStreams(encodings){var _this$_mediaObject$si;if(!((_this$_mediaObject$si=this._mediaObject.simulcast)!==null&&_this$_mediaObject$si!==void 0&&_this$_mediaObject$si.list1)){return;}var layers={};var _iterator105=_createForOfIteratorHelper(encodings),_step105;try{for(_iterator105.s();!(_step105=_iterator105.n()).done;){var encoding=_step105.value;if(encoding.rid){layers[encoding.rid]=encoding;}}}catch(err){_iterator105.e(err);}finally{_iterator105.f();}var raw=this._mediaObject.simulcast.list1;var simulcastStreams=sdpTransform.parseSimulcastStreamList(raw);var _iterator106=_createForOfIteratorHelper(simulcastStreams),_step106;try{for(_iterator106.s();!(_step106=_iterator106.n()).done;){var simulcastStream=_step106.value;var _iterator107=_createForOfIteratorHelper(simulcastStream),_step107;try{for(_iterator107.s();!(_step107=_iterator107.n()).done;){var _layers$simulcastForm;var simulcastFormat=_step107.value;simulcastFormat.paused=!((_layers$simulcastForm=layers[simulcastFormat.scid])!==null&&_layers$simulcastForm!==void 0&&_layers$simulcastForm.active);}}catch(err){_iterator107.e(err);}finally{_iterator107.f();}}}catch(err){_iterator106.e(err);}finally{_iterator106.f();}this._mediaObject.simulcast.list1=simulcastStreams.map(function(simulcastFormats){return simulcastFormats.map(function(f){return"".concat(f.paused?'~':'').concat(f.scid);}).join(',');}).join(';');}}]);}(MediaSection);exports.AnswerMediaSection=AnswerMediaSection;var OfferMediaSection=/*#__PURE__*/function(_MediaSection2){function OfferMediaSection(_ref111){var _this86;var iceParameters=_ref111.iceParameters,iceCandidates=_ref111.iceCandidates,dtlsParameters=_ref111.dtlsParameters,sctpParameters=_ref111.sctpParameters,plainRtpParameters=_ref111.plainRtpParameters,_ref111$planB=_ref111.planB,planB=_ref111$planB===void 0?false:_ref111$planB,mid=_ref111.mid,kind=_ref111.kind,offerRtpParameters=_ref111.offerRtpParameters,streamId=_ref111.streamId,trackId=_ref111.trackId,_ref111$oldDataChanne=_ref111.oldDataChannelSpec,oldDataChannelSpec=_ref111$oldDataChanne===void 0?false:_ref111$oldDataChanne;_classCallCheck2(this,OfferMediaSection);_this86=_callSuper(this,OfferMediaSection,[{iceParameters:iceParameters,iceCandidates:iceCandidates,dtlsParameters:dtlsParameters,planB:planB}]);_this86._mediaObject.mid=String(mid);_this86._mediaObject.type=kind;if(!plainRtpParameters){_this86._mediaObject.connection={ip:'127.0.0.1',version:4};if(!sctpParameters){_this86._mediaObject.protocol='UDP/TLS/RTP/SAVPF';}else{_this86._mediaObject.protocol='UDP/DTLS/SCTP';}_this86._mediaObject.port=7;}else{_this86._mediaObject.connection={ip:plainRtpParameters.ip,version:plainRtpParameters.ipVersion};_this86._mediaObject.protocol='RTP/AVP';_this86._mediaObject.port=plainRtpParameters.port;}switch(kind){case'audio':case'video':{var _encoding$rtx;_this86._mediaObject.direction='sendonly';_this86._mediaObject.rtp=[];_this86._mediaObject.rtcpFb=[];_this86._mediaObject.fmtp=[];if(!_this86._planB){_this86._mediaObject.msid="".concat(streamId!==null&&streamId!==void 0?streamId:'-'," ").concat(trackId);}var _iterator108=_createForOfIteratorHelper(offerRtpParameters.codecs),_step108;try{for(_iterator108.s();!(_step108=_iterator108.n()).done;){var codec=_step108.value;var rtp={payload:codec.payloadType,codec:getCodecName(codec),rate:codec.clockRate};if(codec.channels>1){rtp.encoding=codec.channels;}_this86._mediaObject.rtp.push(rtp);var fmtp={payload:codec.payloadType,config:''};for(var _i2=0,_Object$keys2=Object.keys(codec.parameters);_i2<_Object$keys2.length;_i2++){var key=_Object$keys2[_i2];if(fmtp.config){fmtp.config+=';';}fmtp.config+="".concat(key,"=").concat(codec.parameters[key]);}if(fmtp.config){_this86._mediaObject.fmtp.push(fmtp);}var _iterator110=_createForOfIteratorHelper(codec.rtcpFeedback),_step110;try{for(_iterator110.s();!(_step110=_iterator110.n()).done;){var fb=_step110.value;_this86._mediaObject.rtcpFb.push({payload:codec.payloadType,type:fb.type,subtype:fb.parameter});}}catch(err){_iterator110.e(err);}finally{_iterator110.f();}}}catch(err){_iterator108.e(err);}finally{_iterator108.f();}_this86._mediaObject.payloads=offerRtpParameters.codecs.map(function(codec){return codec.payloadType;}).join(' ');_this86._mediaObject.ext=[];var _iterator109=_createForOfIteratorHelper(offerRtpParameters.headerExtensions),_step109;try{for(_iterator109.s();!(_step109=_iterator109.n()).done;){var ext=_step109.value;_this86._mediaObject.ext.push({uri:ext.uri,value:ext.id});}}catch(err){_iterator109.e(err);}finally{_iterator109.f();}_this86._mediaObject.rtcpMux='rtcp-mux';_this86._mediaObject.rtcpRsize='rtcp-rsize';var encoding=offerRtpParameters.encodings[0];var ssrc=encoding.ssrc;var rtxSsrc=(_encoding$rtx=encoding.rtx)===null||_encoding$rtx===void 0?void 0:_encoding$rtx.ssrc;_this86._mediaObject.ssrcs=[];_this86._mediaObject.ssrcGroups=[];if(offerRtpParameters.rtcp.cname){_this86._mediaObject.ssrcs.push({id:ssrc,attribute:'cname',value:offerRtpParameters.rtcp.cname});}if(_this86._planB){_this86._mediaObject.ssrcs.push({id:ssrc,attribute:'msid',value:"".concat(streamId!==null&&streamId!==void 0?streamId:'-'," ").concat(trackId)});}if(rtxSsrc){if(offerRtpParameters.rtcp.cname){_this86._mediaObject.ssrcs.push({id:rtxSsrc,attribute:'cname',value:offerRtpParameters.rtcp.cname});}if(_this86._planB){_this86._mediaObject.ssrcs.push({id:rtxSsrc,attribute:'msid',value:"".concat(streamId!==null&&streamId!==void 0?streamId:'-'," ").concat(trackId)});}// Associate original and retransmission SSRCs.
_this86._mediaObject.ssrcGroups.push({semantics:'FID',ssrcs:"".concat(ssrc," ").concat(rtxSsrc)});}break;}case'application':{// New spec.
if(!oldDataChannelSpec){_this86._mediaObject.payloads='webrtc-datachannel';_this86._mediaObject.sctpPort=sctpParameters.port;_this86._mediaObject.maxMessageSize=sctpParameters.maxMessageSize;}// Old spec.
else{_this86._mediaObject.payloads=sctpParameters.port;_this86._mediaObject.sctpmap={app:'webrtc-datachannel',sctpmapNumber:sctpParameters.port,maxMessageSize:sctpParameters.maxMessageSize};}break;}}return _this86;}// eslint-disable-next-line @typescript-eslint/no-unused-vars
_inherits(OfferMediaSection,_MediaSection2);return _createClass2(OfferMediaSection,[{key:"setDtlsRole",value:function setDtlsRole(role){// Always 'actpass'.
this._mediaObject.setup='actpass';}},{key:"resume",value:function resume(){this._mediaObject.direction='sendonly';}},{key:"planBReceive",value:function planBReceive(_ref112){var _encoding$rtx2,_this87=this;var offerRtpParameters=_ref112.offerRtpParameters,streamId=_ref112.streamId,trackId=_ref112.trackId;var encoding=offerRtpParameters.encodings[0];var ssrc=encoding.ssrc;var rtxSsrc=(_encoding$rtx2=encoding.rtx)===null||_encoding$rtx2===void 0?void 0:_encoding$rtx2.ssrc;var payloads=this._mediaObject.payloads.split(' ');var _iterator111=_createForOfIteratorHelper(offerRtpParameters.codecs),_step111;try{for(_iterator111.s();!(_step111=_iterator111.n()).done;){var codec=_step111.value;if(payloads.includes(String(codec.payloadType))){continue;}var rtp={payload:codec.payloadType,codec:getCodecName(codec),rate:codec.clockRate};if(codec.channels>1){rtp.encoding=codec.channels;}this._mediaObject.rtp.push(rtp);var fmtp={payload:codec.payloadType,config:''};for(var _i3=0,_Object$keys3=Object.keys(codec.parameters);_i3<_Object$keys3.length;_i3++){var key=_Object$keys3[_i3];if(fmtp.config){fmtp.config+=';';}fmtp.config+="".concat(key,"=").concat(codec.parameters[key]);}if(fmtp.config){this._mediaObject.fmtp.push(fmtp);}var _iterator112=_createForOfIteratorHelper(codec.rtcpFeedback),_step112;try{for(_iterator112.s();!(_step112=_iterator112.n()).done;){var fb=_step112.value;this._mediaObject.rtcpFb.push({payload:codec.payloadType,type:fb.type,subtype:fb.parameter});}}catch(err){_iterator112.e(err);}finally{_iterator112.f();}}}catch(err){_iterator111.e(err);}finally{_iterator111.f();}this._mediaObject.payloads+=" ".concat(offerRtpParameters.codecs.filter(function(codec){return!_this87._mediaObject.payloads.includes(codec.payloadType);}).map(function(codec){return codec.payloadType;}).join(' '));this._mediaObject.payloads=this._mediaObject.payloads.trim();if(offerRtpParameters.rtcp.cname){this._mediaObject.ssrcs.push({id:ssrc,attribute:'cname',value:offerRtpParameters.rtcp.cname});}this._mediaObject.ssrcs.push({id:ssrc,attribute:'msid',value:"".concat(streamId!==null&&streamId!==void 0?streamId:'-'," ").concat(trackId)});if(rtxSsrc){if(offerRtpParameters.rtcp.cname){this._mediaObject.ssrcs.push({id:rtxSsrc,attribute:'cname',value:offerRtpParameters.rtcp.cname});}this._mediaObject.ssrcs.push({id:rtxSsrc,attribute:'msid',value:"".concat(streamId!==null&&streamId!==void 0?streamId:'-'," ").concat(trackId)});// Associate original and retransmission SSRCs.
this._mediaObject.ssrcGroups.push({semantics:'FID',ssrcs:"".concat(ssrc," ").concat(rtxSsrc)});}}},{key:"planBStopReceiving",value:function planBStopReceiving(_ref113){var _encoding$rtx3;var offerRtpParameters=_ref113.offerRtpParameters;var encoding=offerRtpParameters.encodings[0];var ssrc=encoding.ssrc;var rtxSsrc=(_encoding$rtx3=encoding.rtx)===null||_encoding$rtx3===void 0?void 0:_encoding$rtx3.ssrc;this._mediaObject.ssrcs=this._mediaObject.ssrcs.filter(function(s){return s.id!==ssrc&&s.id!==rtxSsrc;});if(rtxSsrc){this._mediaObject.ssrcGroups=this._mediaObject.ssrcGroups.filter(function(group){return group.ssrcs!=="".concat(ssrc," ").concat(rtxSsrc);});}}}]);}(MediaSection);exports.OfferMediaSection=OfferMediaSection;function getCodecName(codec){var MimeTypeRegex=new RegExp('^(audio|video)/(.+)','i');var mimeTypeMatch=MimeTypeRegex.exec(codec.mimeType);if(!mimeTypeMatch){throw new TypeError('invalid codec.mimeType');}return mimeTypeMatch[2];}/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":(/*!*********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \*********************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_sdp_RemoteSdpJs(__unused_webpack_module,exports,__nested_webpack_require_652357__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.RemoteSdp=void 0;var sdpTransform=__importStar(__nested_webpack_require_652357__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));var Logger_1=__nested_webpack_require_652357__(/*! ../../Logger */"./node_modules/mediasoup-client/lib/Logger.js");var MediaSection_1=__nested_webpack_require_652357__(/*! ./MediaSection */"./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js");var logger=new Logger_1.Logger('RemoteSdp');var RemoteSdp=/*#__PURE__*/function(){function RemoteSdp(_ref114){var iceParameters=_ref114.iceParameters,iceCandidates=_ref114.iceCandidates,dtlsParameters=_ref114.dtlsParameters,sctpParameters=_ref114.sctpParameters,plainRtpParameters=_ref114.plainRtpParameters,_ref114$planB=_ref114.planB,planB=_ref114$planB===void 0?false:_ref114$planB;_classCallCheck2(this,RemoteSdp);// MediaSection instances with same order as in the SDP.
this._mediaSections=[];// MediaSection indices indexed by MID.
this._midToIndex=new Map();this._iceParameters=iceParameters;this._iceCandidates=iceCandidates;this._dtlsParameters=dtlsParameters;this._sctpParameters=sctpParameters;this._plainRtpParameters=plainRtpParameters;this._planB=planB;this._sdpObject={version:0,origin:{address:'0.0.0.0',ipVer:4,netType:'IN',sessionId:10000,sessionVersion:0,username:'mediasoup-client'},name:'-',timing:{start:0,stop:0},media:[]};// If ICE parameters are given, add ICE-Lite indicator.
if(iceParameters!==null&&iceParameters!==void 0&&iceParameters.iceLite){this._sdpObject.icelite='ice-lite';}// If DTLS parameters are given, assume WebRTC and BUNDLE.
if(dtlsParameters){this._sdpObject.msidSemantic={semantic:'WMS',token:'*'};// NOTE: We take the latest fingerprint.
var numFingerprints=this._dtlsParameters.fingerprints.length;this._sdpObject.fingerprint={type:dtlsParameters.fingerprints[numFingerprints-1].algorithm,hash:dtlsParameters.fingerprints[numFingerprints-1].value};this._sdpObject.groups=[{type:'BUNDLE',mids:''}];}// If there are plain RPT parameters, override SDP origin.
if(plainRtpParameters){this._sdpObject.origin.address=plainRtpParameters.ip;this._sdpObject.origin.ipVer=plainRtpParameters.ipVersion;}}return _createClass2(RemoteSdp,[{key:"updateIceParameters",value:function updateIceParameters(iceParameters){logger.debug('updateIceParameters() [iceParameters:%o]',iceParameters);this._iceParameters=iceParameters;this._sdpObject.icelite=iceParameters.iceLite?'ice-lite':undefined;var _iterator113=_createForOfIteratorHelper(this._mediaSections),_step113;try{for(_iterator113.s();!(_step113=_iterator113.n()).done;){var mediaSection=_step113.value;mediaSection.setIceParameters(iceParameters);}}catch(err){_iterator113.e(err);}finally{_iterator113.f();}}},{key:"updateDtlsRole",value:function updateDtlsRole(role){logger.debug('updateDtlsRole() [role:%s]',role);this._dtlsParameters.role=role;var _iterator114=_createForOfIteratorHelper(this._mediaSections),_step114;try{for(_iterator114.s();!(_step114=_iterator114.n()).done;){var mediaSection=_step114.value;mediaSection.setDtlsRole(role);}}catch(err){_iterator114.e(err);}finally{_iterator114.f();}}},{key:"getNextMediaSectionIdx",value:function getNextMediaSectionIdx(){// If a closed media section is found, return its index.
for(var idx=0;idx<this._mediaSections.length;++idx){var mediaSection=this._mediaSections[idx];if(mediaSection.closed){return{idx:idx,reuseMid:mediaSection.mid};}}// If no closed media section is found, return next one.
return{idx:this._mediaSections.length};}},{key:"send",value:function send(_ref115){var offerMediaObject=_ref115.offerMediaObject,reuseMid=_ref115.reuseMid,offerRtpParameters=_ref115.offerRtpParameters,answerRtpParameters=_ref115.answerRtpParameters,codecOptions=_ref115.codecOptions,_ref115$extmapAllowMi=_ref115.extmapAllowMixed,extmapAllowMixed=_ref115$extmapAllowMi===void 0?false:_ref115$extmapAllowMi;var mediaSection=new MediaSection_1.AnswerMediaSection({iceParameters:this._iceParameters,iceCandidates:this._iceCandidates,dtlsParameters:this._dtlsParameters,plainRtpParameters:this._plainRtpParameters,planB:this._planB,offerMediaObject:offerMediaObject,offerRtpParameters:offerRtpParameters,answerRtpParameters:answerRtpParameters,codecOptions:codecOptions,extmapAllowMixed:extmapAllowMixed});// Unified-Plan with closed media section replacement.
if(reuseMid){this._replaceMediaSection(mediaSection,reuseMid);}// Unified-Plan or Plan-B with different media kind.
else if(!this._midToIndex.has(mediaSection.mid)){this._addMediaSection(mediaSection);}// Plan-B with same media kind.
else{this._replaceMediaSection(mediaSection);}}},{key:"receive",value:function receive(_ref116){var mid=_ref116.mid,kind=_ref116.kind,offerRtpParameters=_ref116.offerRtpParameters,streamId=_ref116.streamId,trackId=_ref116.trackId;var idx=this._midToIndex.get(mid);var mediaSection;if(idx!==undefined){mediaSection=this._mediaSections[idx];}// Unified-Plan or different media kind.
if(!mediaSection){mediaSection=new MediaSection_1.OfferMediaSection({iceParameters:this._iceParameters,iceCandidates:this._iceCandidates,dtlsParameters:this._dtlsParameters,plainRtpParameters:this._plainRtpParameters,planB:this._planB,mid:mid,kind:kind,offerRtpParameters:offerRtpParameters,streamId:streamId,trackId:trackId});// Let's try to recycle a closed media section (if any).
// NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
var oldMediaSection=this._mediaSections.find(function(m){return m.closed;});if(oldMediaSection){this._replaceMediaSection(mediaSection,oldMediaSection.mid);}else{this._addMediaSection(mediaSection);}}// Plan-B.
else{mediaSection.planBReceive({offerRtpParameters:offerRtpParameters,streamId:streamId,trackId:trackId});this._replaceMediaSection(mediaSection);}}},{key:"pauseMediaSection",value:function pauseMediaSection(mid){var mediaSection=this._findMediaSection(mid);mediaSection.pause();}},{key:"resumeSendingMediaSection",value:function resumeSendingMediaSection(mid){var mediaSection=this._findMediaSection(mid);mediaSection.resume();}},{key:"resumeReceivingMediaSection",value:function resumeReceivingMediaSection(mid){var mediaSection=this._findMediaSection(mid);mediaSection.resume();}},{key:"disableMediaSection",value:function disableMediaSection(mid){var mediaSection=this._findMediaSection(mid);mediaSection.disable();}/**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */},{key:"closeMediaSection",value:function closeMediaSection(mid){var mediaSection=this._findMediaSection(mid);// NOTE: Closing the first m section is a pain since it invalidates the
// bundled transport, so let's avoid it.
if(mid===this._firstMid){logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]',mid);this.disableMediaSection(mid);return false;}mediaSection.close();// Regenerate BUNDLE mids.
this._regenerateBundleMids();return true;}},{key:"muxMediaSectionSimulcast",value:function muxMediaSectionSimulcast(mid,encodings){var mediaSection=this._findMediaSection(mid);mediaSection.muxSimulcastStreams(encodings);this._replaceMediaSection(mediaSection);}},{key:"planBStopReceiving",value:function planBStopReceiving(_ref117){var mid=_ref117.mid,offerRtpParameters=_ref117.offerRtpParameters;var mediaSection=this._findMediaSection(mid);mediaSection.planBStopReceiving({offerRtpParameters:offerRtpParameters});this._replaceMediaSection(mediaSection);}},{key:"sendSctpAssociation",value:function sendSctpAssociation(_ref118){var offerMediaObject=_ref118.offerMediaObject;var mediaSection=new MediaSection_1.AnswerMediaSection({iceParameters:this._iceParameters,iceCandidates:this._iceCandidates,dtlsParameters:this._dtlsParameters,sctpParameters:this._sctpParameters,plainRtpParameters:this._plainRtpParameters,offerMediaObject:offerMediaObject});this._addMediaSection(mediaSection);}},{key:"receiveSctpAssociation",value:function receiveSctpAssociation(){var _ref119=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref119$oldDataChanne=_ref119.oldDataChannelSpec,oldDataChannelSpec=_ref119$oldDataChanne===void 0?false:_ref119$oldDataChanne;var mediaSection=new MediaSection_1.OfferMediaSection({iceParameters:this._iceParameters,iceCandidates:this._iceCandidates,dtlsParameters:this._dtlsParameters,sctpParameters:this._sctpParameters,plainRtpParameters:this._plainRtpParameters,mid:'datachannel',kind:'application',oldDataChannelSpec:oldDataChannelSpec});this._addMediaSection(mediaSection);}},{key:"getSdp",value:function getSdp(){// Increase SDP version.
this._sdpObject.origin.sessionVersion++;return sdpTransform.write(this._sdpObject);}},{key:"_addMediaSection",value:function _addMediaSection(newMediaSection){if(!this._firstMid){this._firstMid=newMediaSection.mid;}// Add to the vector.
this._mediaSections.push(newMediaSection);// Add to the map.
this._midToIndex.set(newMediaSection.mid,this._mediaSections.length-1);// Add to the SDP object.
this._sdpObject.media.push(newMediaSection.getObject());// Regenerate BUNDLE mids.
this._regenerateBundleMids();}},{key:"_replaceMediaSection",value:function _replaceMediaSection(newMediaSection,reuseMid){// Store it in the map.
if(typeof reuseMid==='string'){var idx=this._midToIndex.get(reuseMid);if(idx===undefined){throw new Error("no media section found for reuseMid '".concat(reuseMid,"'"));}var oldMediaSection=this._mediaSections[idx];// Replace the index in the vector with the new media section.
this._mediaSections[idx]=newMediaSection;// Update the map.
this._midToIndex["delete"](oldMediaSection.mid);this._midToIndex.set(newMediaSection.mid,idx);// Update the SDP object.
this._sdpObject.media[idx]=newMediaSection.getObject();// Regenerate BUNDLE mids.
this._regenerateBundleMids();}else{var _idx2=this._midToIndex.get(newMediaSection.mid);if(_idx2===undefined){throw new Error("no media section found with mid '".concat(newMediaSection.mid,"'"));}// Replace the index in the vector with the new media section.
this._mediaSections[_idx2]=newMediaSection;// Update the SDP object.
this._sdpObject.media[_idx2]=newMediaSection.getObject();}}},{key:"_findMediaSection",value:function _findMediaSection(mid){var idx=this._midToIndex.get(mid);if(idx===undefined){throw new Error("no media section found with mid '".concat(mid,"'"));}return this._mediaSections[idx];}},{key:"_regenerateBundleMids",value:function _regenerateBundleMids(){if(!this._dtlsParameters){return;}this._sdpObject.groups[0].mids=this._mediaSections.filter(function(mediaSection){return!mediaSection.closed;}).map(function(mediaSection){return mediaSection.mid;}).join(' ');}}]);}();exports.RemoteSdp=RemoteSdp;/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":(/*!***********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \***********************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_sdp_commonUtilsJs(__unused_webpack_module,exports,__nested_webpack_require_664459__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.extractRtpCapabilities=extractRtpCapabilities;exports.extractDtlsParameters=extractDtlsParameters;exports.getCname=getCname;exports.applyCodecParameters=applyCodecParameters;var sdpTransform=__importStar(__nested_webpack_require_664459__(/*! sdp-transform */"./node_modules/sdp-transform/lib/index.js"));/**
 * This function must be called with an SDP with 1 m=audio and 1 m=video
 * sections.
 */function extractRtpCapabilities(_ref120){var sdpObject=_ref120.sdpObject;// Map of RtpCodecParameters indexed by payload type.
var codecsMap=new Map();// Array of RtpHeaderExtensions.
var headerExtensions=[];// Whether a m=audio/video section has been already found.
var gotAudio=false;var gotVideo=false;var _iterator115=_createForOfIteratorHelper(sdpObject.media),_step115;try{for(_iterator115.s();!(_step115=_iterator115.n()).done;){var m=_step115.value;var kind=m.type;switch(kind){case'audio':{if(gotAudio){continue;}gotAudio=true;break;}case'video':{if(gotVideo){continue;}gotVideo=true;break;}default:{continue;}}// Get codecs.
var _iterator116=_createForOfIteratorHelper(m.rtp),_step116;try{for(_iterator116.s();!(_step116=_iterator116.n()).done;){var rtp=_step116.value;var codec={kind:kind,mimeType:"".concat(kind,"/").concat(rtp.codec),preferredPayloadType:rtp.payload,clockRate:rtp.rate,channels:rtp.encoding,parameters:{},rtcpFeedback:[]};codecsMap.set(codec.preferredPayloadType,codec);}// Get codec parameters.
}catch(err){_iterator116.e(err);}finally{_iterator116.f();}var _iterator117=_createForOfIteratorHelper(m.fmtp||[]),_step117;try{for(_iterator117.s();!(_step117=_iterator117.n()).done;){var fmtp=_step117.value;var parameters=sdpTransform.parseParams(fmtp.config);var _codec2=codecsMap.get(fmtp.payload);if(!_codec2){continue;}// Specials case to convert parameter value to string.
if(parameters!==null&&parameters!==void 0&&parameters.hasOwnProperty('profile-level-id')){parameters['profile-level-id']=String(parameters['profile-level-id']);}_codec2.parameters=parameters;}// Get RTCP feedback for each codec.
}catch(err){_iterator117.e(err);}finally{_iterator117.f();}var _iterator118=_createForOfIteratorHelper(m.rtcpFb||[]),_step118;try{for(_iterator118.s();!(_step118=_iterator118.n()).done;){var fb=_step118.value;var feedback={type:fb.type,parameter:fb.subtype};if(!feedback.parameter){delete feedback.parameter;}// rtcp-fb payload is not '*', so just apply it to its corresponding
// codec.
if(fb.payload!=='*'){var _codec3=codecsMap.get(fb.payload);if(!_codec3){continue;}_codec3.rtcpFeedback.push(feedback);}// If rtcp-fb payload is '*' it must be applied to all codecs with same
// kind (with some exceptions such as RTX codec).
else{var _iterator120=_createForOfIteratorHelper(codecsMap.values()),_step120;try{for(_iterator120.s();!(_step120=_iterator120.n()).done;){var _codec4=_step120.value;if(_codec4.kind===kind&&!/.+\/rtx$/i.test(_codec4.mimeType)){_codec4.rtcpFeedback.push(feedback);}}}catch(err){_iterator120.e(err);}finally{_iterator120.f();}}}// Get RTP header extensions.
}catch(err){_iterator118.e(err);}finally{_iterator118.f();}var _iterator119=_createForOfIteratorHelper(m.ext||[]),_step119;try{for(_iterator119.s();!(_step119=_iterator119.n()).done;){var ext=_step119.value;// Ignore encrypted extensions (not yet supported in mediasoup).
if(ext['encrypt-uri']){continue;}var headerExtension={kind:kind,uri:ext.uri,preferredId:ext.value};headerExtensions.push(headerExtension);}}catch(err){_iterator119.e(err);}finally{_iterator119.f();}}}catch(err){_iterator115.e(err);}finally{_iterator115.f();}var rtpCapabilities={codecs:Array.from(codecsMap.values()),headerExtensions:headerExtensions};return rtpCapabilities;}function extractDtlsParameters(_ref121){var sdpObject=_ref121.sdpObject;var setup=sdpObject.setup;var fingerprint=sdpObject.fingerprint;if(!setup||!fingerprint){var mediaObject=(sdpObject.media||[]).find(function(m){return m.port!==0;});if(mediaObject){var _setup,_fingerprint;(_setup=setup)!==null&&_setup!==void 0?_setup:setup=mediaObject.setup;(_fingerprint=fingerprint)!==null&&_fingerprint!==void 0?_fingerprint:fingerprint=mediaObject.fingerprint;}}if(!setup){throw new Error('no a=setup found at SDP session or media level');}else if(!fingerprint){throw new Error('no a=fingerprint found at SDP session or media level');}var role;switch(setup){case'active':{role='client';break;}case'passive':{role='server';break;}case'actpass':{role='auto';break;}}var dtlsParameters={role:role,fingerprints:[{algorithm:fingerprint.type,value:fingerprint.hash}]};return dtlsParameters;}function getCname(_ref122){var offerMediaObject=_ref122.offerMediaObject;var ssrcCnameLine=(offerMediaObject.ssrcs||[]).find(function(line){return line.attribute==='cname';});if(!ssrcCnameLine){return'';}return ssrcCnameLine.value;}/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */function applyCodecParameters(_ref123){var offerRtpParameters=_ref123.offerRtpParameters,answerMediaObject=_ref123.answerMediaObject;var _iterator121=_createForOfIteratorHelper(offerRtpParameters.codecs),_step121;try{var _loop29=function _loop29(){var codec=_step121.value;var mimeType=codec.mimeType.toLowerCase();// Avoid parsing codec parameters for unhandled codecs.
if(mimeType!=='audio/opus'){return 0;// continue
}var rtp=(answerMediaObject.rtp||[]).find(function(r){return r.payload===codec.payloadType;});if(!rtp){return 0;// continue
}// Just in case.
answerMediaObject.fmtp=answerMediaObject.fmtp||[];var fmtp=answerMediaObject.fmtp.find(function(f){return f.payload===codec.payloadType;});if(!fmtp){fmtp={payload:codec.payloadType,config:''};answerMediaObject.fmtp.push(fmtp);}var parameters=sdpTransform.parseParams(fmtp.config);switch(mimeType){case'audio/opus':{var spropStereo=codec.parameters['sprop-stereo'];if(spropStereo!==undefined){parameters.stereo=spropStereo?1:0;}break;}}// Write the codec fmtp.config back.
fmtp.config='';for(var _i4=0,_Object$keys4=Object.keys(parameters);_i4<_Object$keys4.length;_i4++){var key=_Object$keys4[_i4];if(fmtp.config){fmtp.config+=';';}fmtp.config+="".concat(key,"=").concat(parameters[key]);}},_ret;for(_iterator121.s();!(_step121=_iterator121.n()).done;){_ret=_loop29();if(_ret===0)continue;}}catch(err){_iterator121.e(err);}finally{_iterator121.f();}}/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":(/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \**********************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_sdp_planBUtilsJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.getRtpEncodings=getRtpEncodings;exports.addLegacySimulcast=addLegacySimulcast;function getRtpEncodings(_ref124){var offerMediaObject=_ref124.offerMediaObject,track=_ref124.track;// First media SSRC (or the only one).
var firstSsrc;var ssrcs=new Set();var _iterator122=_createForOfIteratorHelper(offerMediaObject.ssrcs||[]),_step122;try{for(_iterator122.s();!(_step122=_iterator122.n()).done;){var line=_step122.value;if(line.attribute!=='msid'){continue;}var trackId=line.value.split(' ')[1];if(trackId===track.id){var ssrc=line.id;ssrcs.add(ssrc);if(!firstSsrc){firstSsrc=ssrc;}}}}catch(err){_iterator122.e(err);}finally{_iterator122.f();}if(ssrcs.size===0){throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id,"]"));}var ssrcToRtxSsrc=new Map();// First assume RTX is used.
var _iterator123=_createForOfIteratorHelper(offerMediaObject.ssrcGroups||[]),_step123;try{for(_iterator123.s();!(_step123=_iterator123.n()).done;){var _line=_step123.value;if(_line.semantics!=='FID'){continue;}var _line$ssrcs$split=_line.ssrcs.split(/\s+/),_line$ssrcs$split2=_slicedToArray(_line$ssrcs$split,2),_ssrc=_line$ssrcs$split2[0],rtxSsrc=_line$ssrcs$split2[1];_ssrc=Number(_ssrc);rtxSsrc=Number(rtxSsrc);if(ssrcs.has(_ssrc)){// Remove both the SSRC and RTX SSRC from the set so later we know that they
// are already handled.
ssrcs["delete"](_ssrc);ssrcs["delete"](rtxSsrc);// Add to the map.
ssrcToRtxSsrc.set(_ssrc,rtxSsrc);}}// If the set of SSRCs is not empty it means that RTX is not being used, so take
// media SSRCs from there.
}catch(err){_iterator123.e(err);}finally{_iterator123.f();}var _iterator124=_createForOfIteratorHelper(ssrcs),_step124;try{for(_iterator124.s();!(_step124=_iterator124.n()).done;){var _ssrc2=_step124.value;// Add to the map.
ssrcToRtxSsrc.set(_ssrc2,null);}}catch(err){_iterator124.e(err);}finally{_iterator124.f();}var encodings=[];var _iterator125=_createForOfIteratorHelper(ssrcToRtxSsrc),_step125;try{for(_iterator125.s();!(_step125=_iterator125.n()).done;){var _step125$value=_slicedToArray(_step125.value,2),_ssrc3=_step125$value[0],_rtxSsrc=_step125$value[1];var encoding={ssrc:_ssrc3};if(_rtxSsrc){encoding.rtx={ssrc:_rtxSsrc};}encodings.push(encoding);}}catch(err){_iterator125.e(err);}finally{_iterator125.f();}return encodings;}/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */function addLegacySimulcast(_ref125){var offerMediaObject=_ref125.offerMediaObject,track=_ref125.track,numStreams=_ref125.numStreams;if(numStreams<=1){throw new TypeError('numStreams must be greater than 1');}var firstSsrc;var firstRtxSsrc;var streamId;// Get the SSRC.
var ssrcMsidLine=(offerMediaObject.ssrcs||[]).find(function(line){if(line.attribute!=='msid'){return false;}var trackId=line.value.split(' ')[1];if(trackId===track.id){firstSsrc=line.id;streamId=line.value.split(' ')[0];return true;}else{return false;}});if(!ssrcMsidLine){throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id,"]"));}// Get the SSRC for RTX.
(offerMediaObject.ssrcGroups||[]).some(function(line){if(line.semantics!=='FID'){return false;}var ssrcs=line.ssrcs.split(/\s+/);if(Number(ssrcs[0])===firstSsrc){firstRtxSsrc=Number(ssrcs[1]);return true;}else{return false;}});var ssrcCnameLine=offerMediaObject.ssrcs.find(function(line){return line.attribute==='cname'&&line.id===firstSsrc;});if(!ssrcCnameLine){throw new Error("a=ssrc line with cname information not found [track.id:".concat(track.id,"]"));}var cname=ssrcCnameLine.value;var ssrcs=[];var rtxSsrcs=[];for(var i=0;i<numStreams;++i){ssrcs.push(firstSsrc+i);if(firstRtxSsrc){rtxSsrcs.push(firstRtxSsrc+i);}}offerMediaObject.ssrcGroups=offerMediaObject.ssrcGroups||[];offerMediaObject.ssrcs=offerMediaObject.ssrcs||[];offerMediaObject.ssrcGroups.push({semantics:'SIM',ssrcs:ssrcs.join(' ')});for(var _i5=0,_ssrcs=ssrcs;_i5<_ssrcs.length;_i5++){var ssrc=_ssrcs[_i5];offerMediaObject.ssrcs.push({id:ssrc,attribute:'cname',value:cname});offerMediaObject.ssrcs.push({id:ssrc,attribute:'msid',value:"".concat(streamId," ").concat(track.id)});}for(var _i6=0;_i6<rtxSsrcs.length;++_i6){var _ssrc4=ssrcs[_i6];var rtxSsrc=rtxSsrcs[_i6];offerMediaObject.ssrcs.push({id:rtxSsrc,attribute:'cname',value:cname});offerMediaObject.ssrcs.push({id:rtxSsrc,attribute:'msid',value:"".concat(streamId," ").concat(track.id)});offerMediaObject.ssrcGroups.push({semantics:'FID',ssrcs:"".concat(_ssrc4," ").concat(rtxSsrc)});}}/***/}),/***/"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":(/*!****************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************************************//***/function _node_modules_mediasoupClient_lib_handlers_sdp_unifiedPlanUtilsJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.getRtpEncodings=getRtpEncodings;exports.addLegacySimulcast=addLegacySimulcast;function getRtpEncodings(_ref126){var offerMediaObject=_ref126.offerMediaObject;var ssrcs=new Set();var _iterator126=_createForOfIteratorHelper(offerMediaObject.ssrcs||[]),_step126;try{for(_iterator126.s();!(_step126=_iterator126.n()).done;){var line=_step126.value;var ssrc=line.id;ssrcs.add(ssrc);}}catch(err){_iterator126.e(err);}finally{_iterator126.f();}if(ssrcs.size===0){throw new Error('no a=ssrc lines found');}var ssrcToRtxSsrc=new Map();// First assume RTX is used.
var _iterator127=_createForOfIteratorHelper(offerMediaObject.ssrcGroups||[]),_step127;try{for(_iterator127.s();!(_step127=_iterator127.n()).done;){var _line2=_step127.value;if(_line2.semantics!=='FID'){continue;}var _line2$ssrcs$split=_line2.ssrcs.split(/\s+/),_line2$ssrcs$split2=_slicedToArray(_line2$ssrcs$split,2),_ssrc5=_line2$ssrcs$split2[0],rtxSsrc=_line2$ssrcs$split2[1];_ssrc5=Number(_ssrc5);rtxSsrc=Number(rtxSsrc);if(ssrcs.has(_ssrc5)){// Remove both the SSRC and RTX SSRC from the set so later we know
// that they are already handled.
ssrcs["delete"](_ssrc5);ssrcs["delete"](rtxSsrc);// Add to the map.
ssrcToRtxSsrc.set(_ssrc5,rtxSsrc);}}// If the set of SSRCs is not empty it means that RTX is not being used, so
// take media SSRCs from there.
}catch(err){_iterator127.e(err);}finally{_iterator127.f();}var _iterator128=_createForOfIteratorHelper(ssrcs),_step128;try{for(_iterator128.s();!(_step128=_iterator128.n()).done;){var _ssrc6=_step128.value;// Add to the map.
ssrcToRtxSsrc.set(_ssrc6,null);}}catch(err){_iterator128.e(err);}finally{_iterator128.f();}var encodings=[];var _iterator129=_createForOfIteratorHelper(ssrcToRtxSsrc),_step129;try{for(_iterator129.s();!(_step129=_iterator129.n()).done;){var _step129$value=_slicedToArray(_step129.value,2),_ssrc7=_step129$value[0],_rtxSsrc2=_step129$value[1];var encoding={ssrc:_ssrc7};if(_rtxSsrc2){encoding.rtx={ssrc:_rtxSsrc2};}encodings.push(encoding);}}catch(err){_iterator129.e(err);}finally{_iterator129.f();}return encodings;}/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */function addLegacySimulcast(_ref127){var offerMediaObject=_ref127.offerMediaObject,numStreams=_ref127.numStreams;if(numStreams<=1){throw new TypeError('numStreams must be greater than 1');}// Get the SSRC.
var ssrcMsidLine=(offerMediaObject.ssrcs||[]).find(function(line){return line.attribute==='msid';});if(!ssrcMsidLine){throw new Error('a=ssrc line with msid information not found');}var _ssrcMsidLine$value$s=ssrcMsidLine.value.split(' '),_ssrcMsidLine$value$s2=_slicedToArray(_ssrcMsidLine$value$s,2),streamId=_ssrcMsidLine$value$s2[0],trackId=_ssrcMsidLine$value$s2[1];var firstSsrc=Number(ssrcMsidLine.id);var firstRtxSsrc;// Get the SSRC for RTX.
(offerMediaObject.ssrcGroups||[]).some(function(line){if(line.semantics!=='FID'){return false;}var ssrcs=line.ssrcs.split(/\s+/);if(Number(ssrcs[0])===firstSsrc){firstRtxSsrc=Number(ssrcs[1]);return true;}else{return false;}});var ssrcCnameLine=offerMediaObject.ssrcs.find(function(line){return line.attribute==='cname';});if(!ssrcCnameLine){throw new Error('a=ssrc line with cname information not found');}var cname=ssrcCnameLine.value;var ssrcs=[];var rtxSsrcs=[];for(var i=0;i<numStreams;++i){ssrcs.push(firstSsrc+i);if(firstRtxSsrc){rtxSsrcs.push(firstRtxSsrc+i);}}offerMediaObject.ssrcGroups=[];offerMediaObject.ssrcs=[];offerMediaObject.ssrcGroups.push({semantics:'SIM',ssrcs:ssrcs.join(' ')});for(var _i7=0,_ssrcs2=ssrcs;_i7<_ssrcs2.length;_i7++){var ssrc=_ssrcs2[_i7];offerMediaObject.ssrcs.push({id:ssrc,attribute:'cname',value:cname});offerMediaObject.ssrcs.push({id:ssrc,attribute:'msid',value:"".concat(streamId," ").concat(trackId)});}for(var _i8=0;_i8<rtxSsrcs.length;++_i8){var _ssrc8=ssrcs[_i8];var rtxSsrc=rtxSsrcs[_i8];offerMediaObject.ssrcs.push({id:rtxSsrc,attribute:'cname',value:cname});offerMediaObject.ssrcs.push({id:rtxSsrc,attribute:'msid',value:"".concat(streamId," ").concat(trackId)});offerMediaObject.ssrcGroups.push({semantics:'FID',ssrcs:"".concat(_ssrc8," ").concat(rtxSsrc)});}}/***/}),/***/"./node_modules/mediasoup-client/lib/index.js":(/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/index.js ***!
  \****************************************************//***/function _node_modules_mediasoupClient_lib_indexJs(__unused_webpack_module,exports,__nested_webpack_require_681531__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});exports.debug=exports.parseScalabilityMode=exports.detectDevice=exports.Device=exports.version=exports.types=void 0;var debug_1=__importDefault(__nested_webpack_require_681531__(/*! debug */"./node_modules/debug/src/browser.js"));exports.debug=debug_1["default"];var Device_1=__nested_webpack_require_681531__(/*! ./Device */"./node_modules/mediasoup-client/lib/Device.js");Object.defineProperty(exports,"Device",{enumerable:true,get:function get(){return Device_1.Device;}});Object.defineProperty(exports,"detectDevice",{enumerable:true,get:function get(){return Device_1.detectDevice;}});var types=__importStar(__nested_webpack_require_681531__(/*! ./types */"./node_modules/mediasoup-client/lib/types.js"));exports.types=types;/**
 * Expose mediasoup-client version.
 */exports.version='3.7.17';/**
 * Expose parseScalabilityMode() function.
 */var scalabilityModes_1=__nested_webpack_require_681531__(/*! ./scalabilityModes */"./node_modules/mediasoup-client/lib/scalabilityModes.js");Object.defineProperty(exports,"parseScalabilityMode",{enumerable:true,get:function get(){return scalabilityModes_1.parse;}});/***/}),/***/"./node_modules/mediasoup-client/lib/ortc.js":(/*!***************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/ortc.js ***!
  \***************************************************//***/function _node_modules_mediasoupClient_lib_ortcJs(__unused_webpack_module,exports,__nested_webpack_require_683917__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v});}:function(o,v){o["default"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,"__esModule",{value:true});exports.validateRtpCapabilities=validateRtpCapabilities;exports.validateRtpParameters=validateRtpParameters;exports.validateSctpStreamParameters=validateSctpStreamParameters;exports.validateSctpCapabilities=validateSctpCapabilities;exports.getExtendedRtpCapabilities=getExtendedRtpCapabilities;exports.getRecvRtpCapabilities=getRecvRtpCapabilities;exports.getSendingRtpParameters=getSendingRtpParameters;exports.getSendingRemoteRtpParameters=getSendingRemoteRtpParameters;exports.reduceCodecs=reduceCodecs;exports.generateProbatorRtpParameters=generateProbatorRtpParameters;exports.canSend=canSend;exports.canReceive=canReceive;var h264=__importStar(__nested_webpack_require_683917__(/*! h264-profile-level-id */"./node_modules/h264-profile-level-id/lib/index.js"));var utils=__importStar(__nested_webpack_require_683917__(/*! ./utils */"./node_modules/mediasoup-client/lib/utils.js"));var RTP_PROBATOR_MID='probator';var RTP_PROBATOR_SSRC=1234;var RTP_PROBATOR_CODEC_PAYLOAD_TYPE=127;/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpCapabilities(caps){if(_typeof2(caps)!=='object'){throw new TypeError('caps is not an object');}// codecs is optional. If unset, fill with an empty array.
if(caps.codecs&&!Array.isArray(caps.codecs)){throw new TypeError('caps.codecs is not an array');}else if(!caps.codecs){caps.codecs=[];}var _iterator130=_createForOfIteratorHelper(caps.codecs),_step130;try{for(_iterator130.s();!(_step130=_iterator130.n()).done;){var codec=_step130.value;validateRtpCodecCapability(codec);}// headerExtensions is optional. If unset, fill with an empty array.
}catch(err){_iterator130.e(err);}finally{_iterator130.f();}if(caps.headerExtensions&&!Array.isArray(caps.headerExtensions)){throw new TypeError('caps.headerExtensions is not an array');}else if(!caps.headerExtensions){caps.headerExtensions=[];}var _iterator131=_createForOfIteratorHelper(caps.headerExtensions),_step131;try{for(_iterator131.s();!(_step131=_iterator131.n()).done;){var ext=_step131.value;validateRtpHeaderExtension(ext);}}catch(err){_iterator131.e(err);}finally{_iterator131.f();}}/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpParameters(params){if(_typeof2(params)!=='object'){throw new TypeError('params is not an object');}// mid is optional.
if(params.mid&&typeof params.mid!=='string'){throw new TypeError('params.mid is not a string');}// codecs is mandatory.
if(!Array.isArray(params.codecs)){throw new TypeError('missing params.codecs');}var _iterator132=_createForOfIteratorHelper(params.codecs),_step132;try{for(_iterator132.s();!(_step132=_iterator132.n()).done;){var codec=_step132.value;validateRtpCodecParameters(codec);}// headerExtensions is optional. If unset, fill with an empty array.
}catch(err){_iterator132.e(err);}finally{_iterator132.f();}if(params.headerExtensions&&!Array.isArray(params.headerExtensions)){throw new TypeError('params.headerExtensions is not an array');}else if(!params.headerExtensions){params.headerExtensions=[];}var _iterator133=_createForOfIteratorHelper(params.headerExtensions),_step133;try{for(_iterator133.s();!(_step133=_iterator133.n()).done;){var ext=_step133.value;validateRtpHeaderExtensionParameters(ext);}// encodings is optional. If unset, fill with an empty array.
}catch(err){_iterator133.e(err);}finally{_iterator133.f();}if(params.encodings&&!Array.isArray(params.encodings)){throw new TypeError('params.encodings is not an array');}else if(!params.encodings){params.encodings=[];}var _iterator134=_createForOfIteratorHelper(params.encodings),_step134;try{for(_iterator134.s();!(_step134=_iterator134.n()).done;){var encoding=_step134.value;validateRtpEncodingParameters(encoding);}// rtcp is optional. If unset, fill with an empty object.
}catch(err){_iterator134.e(err);}finally{_iterator134.f();}if(params.rtcp&&_typeof2(params.rtcp)!=='object'){throw new TypeError('params.rtcp is not an object');}else if(!params.rtcp){params.rtcp={};}validateRtcpParameters(params.rtcp);}/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateSctpStreamParameters(params){if(_typeof2(params)!=='object'){throw new TypeError('params is not an object');}// streamId is mandatory.
if(typeof params.streamId!=='number'){throw new TypeError('missing params.streamId');}// ordered is optional.
var orderedGiven=false;if(typeof params.ordered==='boolean'){orderedGiven=true;}else{params.ordered=true;}// maxPacketLifeTime is optional.
if(params.maxPacketLifeTime&&typeof params.maxPacketLifeTime!=='number'){throw new TypeError('invalid params.maxPacketLifeTime');}// maxRetransmits is optional.
if(params.maxRetransmits&&typeof params.maxRetransmits!=='number'){throw new TypeError('invalid params.maxRetransmits');}if(params.maxPacketLifeTime&&params.maxRetransmits){throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');}if(orderedGiven&&params.ordered&&(params.maxPacketLifeTime||params.maxRetransmits)){throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');}else if(!orderedGiven&&(params.maxPacketLifeTime||params.maxRetransmits)){params.ordered=false;}// label is optional.
if(params.label&&typeof params.label!=='string'){throw new TypeError('invalid params.label');}// protocol is optional.
if(params.protocol&&typeof params.protocol!=='string'){throw new TypeError('invalid params.protocol');}}/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateSctpCapabilities(caps){if(_typeof2(caps)!=='object'){throw new TypeError('caps is not an object');}// numStreams is mandatory.
if(!caps.numStreams||_typeof2(caps.numStreams)!=='object'){throw new TypeError('missing caps.numStreams');}validateNumSctpStreams(caps.numStreams);}/**
 * Generate extended RTP capabilities for sending and receiving.
 */function getExtendedRtpCapabilities(localCaps,remoteCaps){var _remoteCaps$codecs;var extendedRtpCapabilities={codecs:[],headerExtensions:[]};// Match media codecs and keep the order preferred by remoteCaps.
var _iterator135=_createForOfIteratorHelper((_remoteCaps$codecs=remoteCaps.codecs)!==null&&_remoteCaps$codecs!==void 0?_remoteCaps$codecs:[]),_step135;try{var _loop30=function _loop30(){var _localCaps$codecs;var remoteCodec=_step135.value;if(isRtxCodec(remoteCodec)){return 0;// continue
}var matchingLocalCodec=((_localCaps$codecs=localCaps.codecs)!==null&&_localCaps$codecs!==void 0?_localCaps$codecs:[]).find(function(localCodec){return matchCodecs(localCodec,remoteCodec,{strict:true,modify:true});});if(!matchingLocalCodec){return 0;// continue
}var extendedCodec={mimeType:matchingLocalCodec.mimeType,kind:matchingLocalCodec.kind,clockRate:matchingLocalCodec.clockRate,channels:matchingLocalCodec.channels,localPayloadType:matchingLocalCodec.preferredPayloadType,localRtxPayloadType:undefined,remotePayloadType:remoteCodec.preferredPayloadType,remoteRtxPayloadType:undefined,localParameters:matchingLocalCodec.parameters,remoteParameters:remoteCodec.parameters,rtcpFeedback:reduceRtcpFeedback(matchingLocalCodec,remoteCodec)};extendedRtpCapabilities.codecs.push(extendedCodec);},_ret2;for(_iterator135.s();!(_step135=_iterator135.n()).done;){_ret2=_loop30();if(_ret2===0)continue;}// Match RTX codecs.
}catch(err){_iterator135.e(err);}finally{_iterator135.f();}var _iterator136=_createForOfIteratorHelper(extendedRtpCapabilities.codecs),_step136;try{var _loop31=function _loop31(){var extendedCodec=_step136.value;var matchingLocalRtxCodec=localCaps.codecs.find(function(localCodec){return isRtxCodec(localCodec)&&localCodec.parameters.apt===extendedCodec.localPayloadType;});var matchingRemoteRtxCodec=remoteCaps.codecs.find(function(remoteCodec){return isRtxCodec(remoteCodec)&&remoteCodec.parameters.apt===extendedCodec.remotePayloadType;});if(matchingLocalRtxCodec&&matchingRemoteRtxCodec){extendedCodec.localRtxPayloadType=matchingLocalRtxCodec.preferredPayloadType;extendedCodec.remoteRtxPayloadType=matchingRemoteRtxCodec.preferredPayloadType;}};for(_iterator136.s();!(_step136=_iterator136.n()).done;){_loop31();}// Match header extensions.
}catch(err){_iterator136.e(err);}finally{_iterator136.f();}var _iterator137=_createForOfIteratorHelper(remoteCaps.headerExtensions),_step137;try{var _loop32=function _loop32(){var remoteExt=_step137.value;var matchingLocalExt=localCaps.headerExtensions.find(function(localExt){return matchHeaderExtensions(localExt,remoteExt);});if(!matchingLocalExt){return 1;// continue
}var extendedExt={kind:remoteExt.kind,uri:remoteExt.uri,sendId:matchingLocalExt.preferredId,recvId:remoteExt.preferredId,encrypt:matchingLocalExt.preferredEncrypt,direction:'sendrecv'};switch(remoteExt.direction){case'sendrecv':{extendedExt.direction='sendrecv';break;}case'recvonly':{extendedExt.direction='sendonly';break;}case'sendonly':{extendedExt.direction='recvonly';break;}case'inactive':{extendedExt.direction='inactive';break;}}extendedRtpCapabilities.headerExtensions.push(extendedExt);};for(_iterator137.s();!(_step137=_iterator137.n()).done;){if(_loop32())continue;}}catch(err){_iterator137.e(err);}finally{_iterator137.f();}return extendedRtpCapabilities;}/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */function getRecvRtpCapabilities(extendedRtpCapabilities){var rtpCapabilities={codecs:[],headerExtensions:[]};var _iterator138=_createForOfIteratorHelper(extendedRtpCapabilities.codecs),_step138;try{for(_iterator138.s();!(_step138=_iterator138.n()).done;){var extendedCodec=_step138.value;var codec={mimeType:extendedCodec.mimeType,kind:extendedCodec.kind,preferredPayloadType:extendedCodec.remotePayloadType,clockRate:extendedCodec.clockRate,channels:extendedCodec.channels,parameters:extendedCodec.localParameters,rtcpFeedback:extendedCodec.rtcpFeedback};rtpCapabilities.codecs.push(codec);// Add RTX codec.
if(!extendedCodec.remoteRtxPayloadType){continue;}var rtxCodec={mimeType:"".concat(extendedCodec.kind,"/rtx"),kind:extendedCodec.kind,preferredPayloadType:extendedCodec.remoteRtxPayloadType,clockRate:extendedCodec.clockRate,parameters:{apt:extendedCodec.remotePayloadType},rtcpFeedback:[]};rtpCapabilities.codecs.push(rtxCodec);// TODO: In the future, we need to add FEC, CN, etc, codecs.
}}catch(err){_iterator138.e(err);}finally{_iterator138.f();}var _iterator139=_createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),_step139;try{for(_iterator139.s();!(_step139=_iterator139.n()).done;){var extendedExtension=_step139.value;// Ignore RTP extensions not valid for receiving.
if(extendedExtension.direction!=='sendrecv'&&extendedExtension.direction!=='recvonly'){continue;}var ext={kind:extendedExtension.kind,uri:extendedExtension.uri,preferredId:extendedExtension.recvId,preferredEncrypt:extendedExtension.encrypt,direction:extendedExtension.direction};rtpCapabilities.headerExtensions.push(ext);}}catch(err){_iterator139.e(err);}finally{_iterator139.f();}return rtpCapabilities;}/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */function getSendingRtpParameters(kind,extendedRtpCapabilities){var rtpParameters={mid:undefined,codecs:[],headerExtensions:[],encodings:[],rtcp:{}};var _iterator140=_createForOfIteratorHelper(extendedRtpCapabilities.codecs),_step140;try{for(_iterator140.s();!(_step140=_iterator140.n()).done;){var extendedCodec=_step140.value;if(extendedCodec.kind!==kind){continue;}var codec={mimeType:extendedCodec.mimeType,payloadType:extendedCodec.localPayloadType,clockRate:extendedCodec.clockRate,channels:extendedCodec.channels,parameters:extendedCodec.localParameters,rtcpFeedback:extendedCodec.rtcpFeedback};rtpParameters.codecs.push(codec);// Add RTX codec.
if(extendedCodec.localRtxPayloadType){var rtxCodec={mimeType:"".concat(extendedCodec.kind,"/rtx"),payloadType:extendedCodec.localRtxPayloadType,clockRate:extendedCodec.clockRate,parameters:{apt:extendedCodec.localPayloadType},rtcpFeedback:[]};rtpParameters.codecs.push(rtxCodec);}}}catch(err){_iterator140.e(err);}finally{_iterator140.f();}var _iterator141=_createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),_step141;try{for(_iterator141.s();!(_step141=_iterator141.n()).done;){var extendedExtension=_step141.value;// Ignore RTP extensions of a different kind and those not valid for sending.
if(extendedExtension.kind&&extendedExtension.kind!==kind||extendedExtension.direction!=='sendrecv'&&extendedExtension.direction!=='sendonly'){continue;}var ext={uri:extendedExtension.uri,id:extendedExtension.sendId,encrypt:extendedExtension.encrypt,parameters:{}};rtpParameters.headerExtensions.push(ext);}}catch(err){_iterator141.e(err);}finally{_iterator141.f();}return rtpParameters;}/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */function getSendingRemoteRtpParameters(kind,extendedRtpCapabilities){var rtpParameters={mid:undefined,codecs:[],headerExtensions:[],encodings:[],rtcp:{}};var _iterator142=_createForOfIteratorHelper(extendedRtpCapabilities.codecs),_step142;try{for(_iterator142.s();!(_step142=_iterator142.n()).done;){var extendedCodec=_step142.value;if(extendedCodec.kind!==kind){continue;}var _codec7={mimeType:extendedCodec.mimeType,payloadType:extendedCodec.localPayloadType,clockRate:extendedCodec.clockRate,channels:extendedCodec.channels,parameters:extendedCodec.remoteParameters,rtcpFeedback:extendedCodec.rtcpFeedback};rtpParameters.codecs.push(_codec7);// Add RTX codec.
if(extendedCodec.localRtxPayloadType){var rtxCodec={mimeType:"".concat(extendedCodec.kind,"/rtx"),payloadType:extendedCodec.localRtxPayloadType,clockRate:extendedCodec.clockRate,parameters:{apt:extendedCodec.localPayloadType},rtcpFeedback:[]};rtpParameters.codecs.push(rtxCodec);}}}catch(err){_iterator142.e(err);}finally{_iterator142.f();}var _iterator143=_createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),_step143;try{for(_iterator143.s();!(_step143=_iterator143.n()).done;){var extendedExtension=_step143.value;// Ignore RTP extensions of a different kind and those not valid for sending.
if(extendedExtension.kind&&extendedExtension.kind!==kind||extendedExtension.direction!=='sendrecv'&&extendedExtension.direction!=='sendonly'){continue;}var ext={uri:extendedExtension.uri,id:extendedExtension.sendId,encrypt:extendedExtension.encrypt,parameters:{}};rtpParameters.headerExtensions.push(ext);}// Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
}catch(err){_iterator143.e(err);}finally{_iterator143.f();}if(rtpParameters.headerExtensions.some(function(ext){return ext.uri==='http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';})){var _iterator144=_createForOfIteratorHelper(rtpParameters.codecs),_step144;try{for(_iterator144.s();!(_step144=_iterator144.n()).done;){var _codec$rtcpFeedback3;var codec=_step144.value;codec.rtcpFeedback=((_codec$rtcpFeedback3=codec.rtcpFeedback)!==null&&_codec$rtcpFeedback3!==void 0?_codec$rtcpFeedback3:[]).filter(function(fb){return fb.type!=='goog-remb';});}}catch(err){_iterator144.e(err);}finally{_iterator144.f();}}else if(rtpParameters.headerExtensions.some(function(ext){return ext.uri==='http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';})){var _iterator145=_createForOfIteratorHelper(rtpParameters.codecs),_step145;try{for(_iterator145.s();!(_step145=_iterator145.n()).done;){var _codec5$rtcpFeedback;var _codec5=_step145.value;_codec5.rtcpFeedback=((_codec5$rtcpFeedback=_codec5.rtcpFeedback)!==null&&_codec5$rtcpFeedback!==void 0?_codec5$rtcpFeedback:[]).filter(function(fb){return fb.type!=='transport-cc';});}}catch(err){_iterator145.e(err);}finally{_iterator145.f();}}else{var _iterator146=_createForOfIteratorHelper(rtpParameters.codecs),_step146;try{for(_iterator146.s();!(_step146=_iterator146.n()).done;){var _codec6$rtcpFeedback;var _codec6=_step146.value;_codec6.rtcpFeedback=((_codec6$rtcpFeedback=_codec6.rtcpFeedback)!==null&&_codec6$rtcpFeedback!==void 0?_codec6$rtcpFeedback:[]).filter(function(fb){return fb.type!=='transport-cc'&&fb.type!=='goog-remb';});}}catch(err){_iterator146.e(err);}finally{_iterator146.f();}}return rtpParameters;}/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */function reduceCodecs(codecs,capCodec){var filteredCodecs=[];// If no capability codec is given, take the first one (and RTX).
if(!capCodec){filteredCodecs.push(codecs[0]);if(isRtxCodec(codecs[1])){filteredCodecs.push(codecs[1]);}}// Otherwise look for a compatible set of codecs.
else{for(var idx=0;idx<codecs.length;++idx){if(matchCodecs(codecs[idx],capCodec,{strict:true})){filteredCodecs.push(codecs[idx]);if(isRtxCodec(codecs[idx+1])){filteredCodecs.push(codecs[idx+1]);}break;}}if(filteredCodecs.length===0){throw new TypeError('no matching codec found');}}return filteredCodecs;}/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */function generateProbatorRtpParameters(videoRtpParameters){// Clone given reference video RTP parameters.
videoRtpParameters=utils.clone(videoRtpParameters);// This may throw.
validateRtpParameters(videoRtpParameters);var rtpParameters={mid:RTP_PROBATOR_MID,codecs:[],headerExtensions:[],encodings:[{ssrc:RTP_PROBATOR_SSRC}],rtcp:{cname:'probator'}};rtpParameters.codecs.push(videoRtpParameters.codecs[0]);rtpParameters.codecs[0].payloadType=RTP_PROBATOR_CODEC_PAYLOAD_TYPE;rtpParameters.headerExtensions=videoRtpParameters.headerExtensions;return rtpParameters;}/**
 * Whether media can be sent based on the given RTP capabilities.
 */function canSend(kind,extendedRtpCapabilities){return extendedRtpCapabilities.codecs.some(function(codec){return codec.kind===kind;});}/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */function canReceive(rtpParameters,extendedRtpCapabilities){// This may throw.
validateRtpParameters(rtpParameters);if(rtpParameters.codecs.length===0){return false;}var firstMediaCodec=rtpParameters.codecs[0];return extendedRtpCapabilities.codecs.some(function(codec){return codec.remotePayloadType===firstMediaCodec.payloadType;});}/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpCodecCapability(codec){var MimeTypeRegex=new RegExp('^(audio|video)/(.+)','i');if(_typeof2(codec)!=='object'){throw new TypeError('codec is not an object');}// mimeType is mandatory.
if(!codec.mimeType||typeof codec.mimeType!=='string'){throw new TypeError('missing codec.mimeType');}var mimeTypeMatch=MimeTypeRegex.exec(codec.mimeType);if(!mimeTypeMatch){throw new TypeError('invalid codec.mimeType');}// Just override kind with media component of mimeType.
codec.kind=mimeTypeMatch[1].toLowerCase();// preferredPayloadType is optional.
if(codec.preferredPayloadType&&typeof codec.preferredPayloadType!=='number'){throw new TypeError('invalid codec.preferredPayloadType');}// clockRate is mandatory.
if(typeof codec.clockRate!=='number'){throw new TypeError('missing codec.clockRate');}// channels is optional. If unset, set it to 1 (just if audio).
if(codec.kind==='audio'){if(typeof codec.channels!=='number'){codec.channels=1;}}else{delete codec.channels;}// parameters is optional. If unset, set it to an empty object.
if(!codec.parameters||_typeof2(codec.parameters)!=='object'){codec.parameters={};}for(var _i9=0,_Object$keys5=Object.keys(codec.parameters);_i9<_Object$keys5.length;_i9++){var key=_Object$keys5[_i9];var value=codec.parameters[key];if(value===undefined){codec.parameters[key]='';value='';}if(typeof value!=='string'&&typeof value!=='number'){throw new TypeError("invalid codec parameter [key:".concat(key,"s, value:").concat(value,"]"));}// Specific parameters validation.
if(key==='apt'){if(typeof value!=='number'){throw new TypeError('invalid codec apt parameter');}}}// rtcpFeedback is optional. If unset, set it to an empty array.
if(!codec.rtcpFeedback||!Array.isArray(codec.rtcpFeedback)){codec.rtcpFeedback=[];}var _iterator147=_createForOfIteratorHelper(codec.rtcpFeedback),_step147;try{for(_iterator147.s();!(_step147=_iterator147.n()).done;){var fb=_step147.value;validateRtcpFeedback(fb);}}catch(err){_iterator147.e(err);}finally{_iterator147.f();}}/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtcpFeedback(fb){if(_typeof2(fb)!=='object'){throw new TypeError('fb is not an object');}// type is mandatory.
if(!fb.type||typeof fb.type!=='string'){throw new TypeError('missing fb.type');}// parameter is optional. If unset set it to an empty string.
if(!fb.parameter||typeof fb.parameter!=='string'){fb.parameter='';}}/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpHeaderExtension(ext){if(_typeof2(ext)!=='object'){throw new TypeError('ext is not an object');}// kind is mandatory.
if(ext.kind!=='audio'&&ext.kind!=='video'){throw new TypeError('invalid ext.kind');}// uri is mandatory.
if(!ext.uri||typeof ext.uri!=='string'){throw new TypeError('missing ext.uri');}// preferredId is mandatory.
if(typeof ext.preferredId!=='number'){throw new TypeError('missing ext.preferredId');}// preferredEncrypt is optional. If unset set it to false.
if(ext.preferredEncrypt&&typeof ext.preferredEncrypt!=='boolean'){throw new TypeError('invalid ext.preferredEncrypt');}else if(!ext.preferredEncrypt){ext.preferredEncrypt=false;}// direction is optional. If unset set it to sendrecv.
if(ext.direction&&typeof ext.direction!=='string'){throw new TypeError('invalid ext.direction');}else if(!ext.direction){ext.direction='sendrecv';}}/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpCodecParameters(codec){var MimeTypeRegex=new RegExp('^(audio|video)/(.+)','i');if(_typeof2(codec)!=='object'){throw new TypeError('codec is not an object');}// mimeType is mandatory.
if(!codec.mimeType||typeof codec.mimeType!=='string'){throw new TypeError('missing codec.mimeType');}var mimeTypeMatch=MimeTypeRegex.exec(codec.mimeType);if(!mimeTypeMatch){throw new TypeError('invalid codec.mimeType');}// payloadType is mandatory.
if(typeof codec.payloadType!=='number'){throw new TypeError('missing codec.payloadType');}// clockRate is mandatory.
if(typeof codec.clockRate!=='number'){throw new TypeError('missing codec.clockRate');}var kind=mimeTypeMatch[1].toLowerCase();// channels is optional. If unset, set it to 1 (just if audio).
if(kind==='audio'){if(typeof codec.channels!=='number'){codec.channels=1;}}else{delete codec.channels;}// parameters is optional. If unset, set it to an empty object.
if(!codec.parameters||_typeof2(codec.parameters)!=='object'){codec.parameters={};}for(var _i10=0,_Object$keys6=Object.keys(codec.parameters);_i10<_Object$keys6.length;_i10++){var key=_Object$keys6[_i10];var value=codec.parameters[key];if(value===undefined){codec.parameters[key]='';value='';}if(typeof value!=='string'&&typeof value!=='number'){throw new TypeError("invalid codec parameter [key:".concat(key,"s, value:").concat(value,"]"));}// Specific parameters validation.
if(key==='apt'){if(typeof value!=='number'){throw new TypeError('invalid codec apt parameter');}}}// rtcpFeedback is optional. If unset, set it to an empty array.
if(!codec.rtcpFeedback||!Array.isArray(codec.rtcpFeedback)){codec.rtcpFeedback=[];}var _iterator148=_createForOfIteratorHelper(codec.rtcpFeedback),_step148;try{for(_iterator148.s();!(_step148=_iterator148.n()).done;){var fb=_step148.value;validateRtcpFeedback(fb);}}catch(err){_iterator148.e(err);}finally{_iterator148.f();}}/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpHeaderExtensionParameters(ext){if(_typeof2(ext)!=='object'){throw new TypeError('ext is not an object');}// uri is mandatory.
if(!ext.uri||typeof ext.uri!=='string'){throw new TypeError('missing ext.uri');}// id is mandatory.
if(typeof ext.id!=='number'){throw new TypeError('missing ext.id');}// encrypt is optional. If unset set it to false.
if(ext.encrypt&&typeof ext.encrypt!=='boolean'){throw new TypeError('invalid ext.encrypt');}else if(!ext.encrypt){ext.encrypt=false;}// parameters is optional. If unset, set it to an empty object.
if(!ext.parameters||_typeof2(ext.parameters)!=='object'){ext.parameters={};}for(var _i11=0,_Object$keys7=Object.keys(ext.parameters);_i11<_Object$keys7.length;_i11++){var key=_Object$keys7[_i11];var value=ext.parameters[key];if(value===undefined){ext.parameters[key]='';value='';}if(typeof value!=='string'&&typeof value!=='number'){throw new TypeError('invalid header extension parameter');}}}/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtpEncodingParameters(encoding){if(_typeof2(encoding)!=='object'){throw new TypeError('encoding is not an object');}// ssrc is optional.
if(encoding.ssrc&&typeof encoding.ssrc!=='number'){throw new TypeError('invalid encoding.ssrc');}// rid is optional.
if(encoding.rid&&typeof encoding.rid!=='string'){throw new TypeError('invalid encoding.rid');}// rtx is optional.
if(encoding.rtx&&_typeof2(encoding.rtx)!=='object'){throw new TypeError('invalid encoding.rtx');}else if(encoding.rtx){// RTX ssrc is mandatory if rtx is present.
if(typeof encoding.rtx.ssrc!=='number'){throw new TypeError('missing encoding.rtx.ssrc');}}// dtx is optional. If unset set it to false.
if(!encoding.dtx||typeof encoding.dtx!=='boolean'){encoding.dtx=false;}// scalabilityMode is optional.
if(encoding.scalabilityMode&&typeof encoding.scalabilityMode!=='string'){throw new TypeError('invalid encoding.scalabilityMode');}}/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateRtcpParameters(rtcp){if(_typeof2(rtcp)!=='object'){throw new TypeError('rtcp is not an object');}// cname is optional.
if(rtcp.cname&&typeof rtcp.cname!=='string'){throw new TypeError('invalid rtcp.cname');}// reducedSize is optional. If unset set it to true.
if(!rtcp.reducedSize||typeof rtcp.reducedSize!=='boolean'){rtcp.reducedSize=true;}}/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */function validateNumSctpStreams(numStreams){if(_typeof2(numStreams)!=='object'){throw new TypeError('numStreams is not an object');}// OS is mandatory.
if(typeof numStreams.OS!=='number'){throw new TypeError('missing numStreams.OS');}// MIS is mandatory.
if(typeof numStreams.MIS!=='number'){throw new TypeError('missing numStreams.MIS');}}function isRtxCodec(codec){if(!codec){return false;}return /.+\/rtx$/i.test(codec.mimeType);}function matchCodecs(aCodec,bCodec){var _ref128=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref128$strict=_ref128.strict,strict=_ref128$strict===void 0?false:_ref128$strict,_ref128$modify=_ref128.modify,modify=_ref128$modify===void 0?false:_ref128$modify;var aMimeType=aCodec.mimeType.toLowerCase();var bMimeType=bCodec.mimeType.toLowerCase();if(aMimeType!==bMimeType){return false;}if(aCodec.clockRate!==bCodec.clockRate){return false;}if(aCodec.channels!==bCodec.channels){return false;}// Per codec special checks.
switch(aMimeType){case'video/h264':{if(strict){var aPacketizationMode=aCodec.parameters['packetization-mode']||0;var bPacketizationMode=bCodec.parameters['packetization-mode']||0;if(aPacketizationMode!==bPacketizationMode){return false;}if(!h264.isSameProfile(aCodec.parameters,bCodec.parameters)){return false;}var selectedProfileLevelId;try{selectedProfileLevelId=h264.generateProfileLevelIdStringForAnswer(aCodec.parameters,bCodec.parameters);}catch(error){return false;}if(modify){if(selectedProfileLevelId){aCodec.parameters['profile-level-id']=selectedProfileLevelId;bCodec.parameters['profile-level-id']=selectedProfileLevelId;}else{delete aCodec.parameters['profile-level-id'];delete bCodec.parameters['profile-level-id'];}}}break;}case'video/vp9':{if(strict){var aProfileId=aCodec.parameters['profile-id']||0;var bProfileId=bCodec.parameters['profile-id']||0;if(aProfileId!==bProfileId){return false;}}break;}}return true;}function matchHeaderExtensions(aExt,bExt){if(aExt.kind&&bExt.kind&&aExt.kind!==bExt.kind){return false;}if(aExt.uri!==bExt.uri){return false;}return true;}function reduceRtcpFeedback(codecA,codecB){var _codecA$rtcpFeedback;var reducedRtcpFeedback=[];var _iterator149=_createForOfIteratorHelper((_codecA$rtcpFeedback=codecA.rtcpFeedback)!==null&&_codecA$rtcpFeedback!==void 0?_codecA$rtcpFeedback:[]),_step149;try{var _loop33=function _loop33(){var _codecB$rtcpFeedback;var aFb=_step149.value;var matchingBFb=((_codecB$rtcpFeedback=codecB.rtcpFeedback)!==null&&_codecB$rtcpFeedback!==void 0?_codecB$rtcpFeedback:[]).find(function(bFb){return bFb.type===aFb.type&&(bFb.parameter===aFb.parameter||!bFb.parameter&&!aFb.parameter);});if(matchingBFb){reducedRtcpFeedback.push(matchingBFb);}};for(_iterator149.s();!(_step149=_iterator149.n()).done;){_loop33();}}catch(err){_iterator149.e(err);}finally{_iterator149.f();}return reducedRtcpFeedback;}/***/}),/***/"./node_modules/mediasoup-client/lib/scalabilityModes.js":(/*!***************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \***************************************************************//***/function _node_modules_mediasoupClient_lib_scalabilityModesJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.parse=parse;var ScalabilityModeRegex=new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');function parse(scalabilityMode){var match=ScalabilityModeRegex.exec(scalabilityMode!==null&&scalabilityMode!==void 0?scalabilityMode:'');if(match){return{spatialLayers:Number(match[1]),temporalLayers:Number(match[2])};}else{return{spatialLayers:1,temporalLayers:1};}}/***/}),/***/"./node_modules/mediasoup-client/lib/types.js":(/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/types.js ***!
  \****************************************************//***/function _node_modules_mediasoupClient_lib_typesJs(__unused_webpack_module,exports,__nested_webpack_require_715866__){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)if(p!=="default"&&!Object.prototype.hasOwnProperty.call(exports,p))__createBinding(exports,m,p);};Object.defineProperty(exports,"__esModule",{value:true});__exportStar(__nested_webpack_require_715866__(/*! ./Device */"./node_modules/mediasoup-client/lib/Device.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./Transport */"./node_modules/mediasoup-client/lib/Transport.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./Producer */"./node_modules/mediasoup-client/lib/Producer.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./Consumer */"./node_modules/mediasoup-client/lib/Consumer.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./DataProducer */"./node_modules/mediasoup-client/lib/DataProducer.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./DataConsumer */"./node_modules/mediasoup-client/lib/DataConsumer.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./RtpParameters */"./node_modules/mediasoup-client/lib/RtpParameters.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./SctpParameters */"./node_modules/mediasoup-client/lib/SctpParameters.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./handlers/HandlerInterface */"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"),exports);__exportStar(__nested_webpack_require_715866__(/*! ./errors */"./node_modules/mediasoup-client/lib/errors.js"),exports);/***/}),/***/"./node_modules/mediasoup-client/lib/utils.js":(/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/utils.js ***!
  \****************************************************//***/function _node_modules_mediasoupClient_lib_utilsJs(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.clone=clone;exports.generateRandomNumber=generateRandomNumber;exports.deepFreeze=deepFreeze;/**
 * Clones the given value.
 */function clone(value){if(value===undefined){return undefined;}else if(Number.isNaN(value)){return NaN;}else if(typeof structuredClone==='function'){// Available in Node >= 18.
return structuredClone(value);}else{return JSON.parse(JSON.stringify(value));}}/**
 * Generates a random positive integer.
 */function generateRandomNumber(){return Math.round(Math.random()*10000000);}/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */function deepFreeze(object){// Retrieve the property names defined on object.
var propNames=Reflect.ownKeys(object);// Freeze properties before freezing self.
var _iterator150=_createForOfIteratorHelper(propNames),_step150;try{for(_iterator150.s();!(_step150=_iterator150.n()).done;){var name=_step150.value;var value=object[name];if(value&&_typeof2(value)==='object'||typeof value==='function'){deepFreeze(value);}}}catch(err){_iterator150.e(err);}finally{_iterator150.f();}return Object.freeze(object);}/***/}),/***/"./node_modules/ms/index.js":(/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************//***/function _node_modules_ms_indexJs(module){/**
 * Helpers.
 */var s=1000;var m=s*60;var h=m*60;var d=h*24;var w=d*7;var y=d*365.25;/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */module.exports=function(val,options){options=options||{};var type=_typeof2(val);if(type==='string'&&val.length>0){return parse(val);}else if(type==='number'&&isFinite(val)){return options["long"]?fmtLong(val):fmtShort(val);}throw new Error('val is not a non-empty string or a valid number. val='+JSON.stringify(val));};/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */function parse(str){str=String(str);if(str.length>100){return;}var match=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);if(!match){return;}var n=parseFloat(match[1]);var type=(match[2]||'ms').toLowerCase();switch(type){case'years':case'year':case'yrs':case'yr':case'y':return n*y;case'weeks':case'week':case'w':return n*w;case'days':case'day':case'd':return n*d;case'hours':case'hour':case'hrs':case'hr':case'h':return n*h;case'minutes':case'minute':case'mins':case'min':case'm':return n*m;case'seconds':case'second':case'secs':case'sec':case's':return n*s;case'milliseconds':case'millisecond':case'msecs':case'msec':case'ms':return n;default:return undefined;}}/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */function fmtShort(ms){var msAbs=Math.abs(ms);if(msAbs>=d){return Math.round(ms/d)+'d';}if(msAbs>=h){return Math.round(ms/h)+'h';}if(msAbs>=m){return Math.round(ms/m)+'m';}if(msAbs>=s){return Math.round(ms/s)+'s';}return ms+'ms';}/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */function fmtLong(ms){var msAbs=Math.abs(ms);if(msAbs>=d){return plural(ms,msAbs,d,'day');}if(msAbs>=h){return plural(ms,msAbs,h,'hour');}if(msAbs>=m){return plural(ms,msAbs,m,'minute');}if(msAbs>=s){return plural(ms,msAbs,s,'second');}return ms+' ms';}/**
 * Pluralization helper.
 */function plural(ms,msAbs,n,name){var isPlural=msAbs>=n*1.5;return Math.round(ms/n)+' '+name+(isPlural?'s':'');}/***/}),/***/"./node_modules/npm-events-package/events.js":(/*!***************************************************!*\
  !*** ./node_modules/npm-events-package/events.js ***!
  \***************************************************//***/function _node_modules_npmEventsPackage_eventsJs(module){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var R=(typeof Reflect==="undefined"?"undefined":_typeof2(Reflect))==='object'?Reflect:null;var ReflectApply=R&&typeof R.apply==='function'?R.apply:function ReflectApply(target,receiver,args){return Function.prototype.apply.call(target,receiver,args);};var ReflectOwnKeys;if(R&&typeof R.ownKeys==='function'){ReflectOwnKeys=R.ownKeys;}else if(Object.getOwnPropertySymbols){ReflectOwnKeys=function ReflectOwnKeys(target){return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));};}else{ReflectOwnKeys=function ReflectOwnKeys(target){return Object.getOwnPropertyNames(target);};}function ProcessEmitWarning(warning){if(console&&console.warn)console.warn(warning);}var NumberIsNaN=Number.isNaN||function NumberIsNaN(value){return value!==value;};function EventEmitter(){EventEmitter.init.call(this);}module.exports=EventEmitter;module.exports.once=once;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._eventsCount=0;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners=10;function checkListener(listener){if(typeof listener!=='function'){throw new TypeError('The "listener" argument must be of type Function. Received type '+_typeof2(listener));}}Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){if(typeof arg!=='number'||arg<0||NumberIsNaN(arg)){throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+arg+'.');}defaultMaxListeners=arg;}});EventEmitter.init=function(){if(this._events===undefined||this._events===Object.getPrototypeOf(this)._events){this._events=Object.create(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;};// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||NumberIsNaN(n)){throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+n+'.');}this._maxListeners=n;return this;};function _getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return _getMaxListeners(this);};EventEmitter.prototype.emit=function emit(type){var args=[];for(var i=1;i<arguments.length;i++)args.push(arguments[i]);var doError=type==='error';var events=this._events;if(events!==undefined)doError=doError&&events.error===undefined;else if(!doError)return false;// If there is no 'error' event listener then throw.
if(doError){var er;if(args.length>0)er=args[0];if(er instanceof Error){// Note: The comments on the `throw` lines are intentional, they show
// up in Node's output if this results in an unhandled exception.
throw er;// Unhandled 'error' event
}// At least give some kind of context to the user
var err=new Error('Unhandled error.'+(er?' ('+er.message+')':''));err.context=er;throw err;// Unhandled 'error' event
}var handler=events[type];if(handler===undefined)return false;if(typeof handler==='function'){ReflectApply(handler,this,args);}else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i)ReflectApply(listeners[i],this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;checkListener(listener);events=target._events;if(events===undefined){events=target._events=Object.create(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(events.newListener!==undefined){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
events=target._events;}existing=events[type];}if(existing===undefined){// Optimize the case of one listener. Don't need the extra array object.
existing=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.
existing=events[type]=prepend?[listener,existing]:[existing,listener];// If we've already got an array, just append.
}else if(prepend){existing.unshift(listener);}else{existing.push(listener);}// Check for listener leak
m=_getMaxListeners(target);if(m>0&&existing.length>m&&!existing.warned){existing.warned=true;// No error code for this since it is a Warning
// eslint-disable-next-line no-restricted-syntax
var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' '+String(type)+' listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;ProcessEmitWarning(w);}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;if(arguments.length===0)return this.listener.call(this.target);return this.listener.apply(this.target,arguments);}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=onceWrapper.bind(state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){checkListener(listener);this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){checkListener(listener);this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;checkListener(listener);events=this._events;if(events===undefined)return this;list=events[type];if(list===undefined)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=Object.create(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else{spliceOne(list,position);}if(list.length===1)events[type]=list[0];if(events.removeListener!==undefined)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(events===undefined)return this;// not listening for removeListener, no need to emit
if(events.removeListener===undefined){if(arguments.length===0){this._events=Object.create(null);this._eventsCount=0;}else if(events[type]!==undefined){if(--this._eventsCount===0)this._events=Object.create(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){var keys=Object.keys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=Object.create(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners!==undefined){// LIFO order
for(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(events===undefined)return[];var evlistener=events[type];if(evlistener===undefined)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events!==undefined){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener!==undefined){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?ReflectOwnKeys(this._events):[];};function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i)copy[i]=arr[i];return copy;}function spliceOne(list,index){for(;index+1<list.length;index++)list[index]=list[index+1];list.pop();}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function once(emitter,name){return new Promise(function(resolve,reject){function errorListener(err){emitter.removeListener(name,resolver);reject(err);}function resolver(){if(typeof emitter.removeListener==='function'){emitter.removeListener('error',errorListener);}resolve([].slice.call(arguments));};eventTargetAgnosticAddListener(emitter,name,resolver,{once:true});if(name!=='error'){addErrorHandlerIfEventEmitter(emitter,errorListener,{once:true});}});}function addErrorHandlerIfEventEmitter(emitter,handler,flags){if(typeof emitter.on==='function'){eventTargetAgnosticAddListener(emitter,'error',handler,flags);}}function eventTargetAgnosticAddListener(emitter,name,listener,flags){if(typeof emitter.on==='function'){if(flags.once){emitter.once(name,listener);}else{emitter.on(name,listener);}}else if(typeof emitter.addEventListener==='function'){// EventTarget does not have `error` event semantics like Node
// EventEmitters, we do not listen for `error` events here.
emitter.addEventListener(name,function wrapListener(arg){// IE does not have builtin `{ once: true }` support so we
// have to do it manually.
if(flags.once){emitter.removeEventListener(name,wrapListener);}listener(arg);});}else{throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+_typeof2(emitter));}}/***/}),/***/"./node_modules/queue-microtask/index.js":(/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************//***/function _node_modules_queueMicrotask_indexJs(module,__unused_webpack_exports,__nested_webpack_require_734565__){/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var promise;module.exports=typeof queueMicrotask==='function'?queueMicrotask.bind(typeof window!=='undefined'?window:__nested_webpack_require_734565__.g)// reuse resolved promise, and allocate it lazily
:function(cb){return(promise||(promise=Promise.resolve())).then(cb)["catch"](function(err){return setTimeout(function(){throw err;},0);});};/***/}),/***/"./node_modules/sdp-transform/lib/grammar.js":(/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************//***/function _node_modules_sdpTransform_lib_grammarJs(module){var grammar=module.exports={v:[{name:'version',reg:/^(\d*)$/}],o:[{// o=- 20518 0 IN IP4 203.0.113.1
// NB: sessionId will be a String in most cases because it is huge
name:'origin',reg:/^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,names:['username','sessionId','sessionVersion','netType','ipVer','address'],format:'%s %s %d %s IP%d %s'}],// default parsing of these only (though some of these feel outdated)
s:[{name:'name'}],i:[{name:'description'}],u:[{name:'uri'}],e:[{name:'email'}],p:[{name:'phone'}],z:[{name:'timezones'}],// TODO: this one can actually be parsed properly...
r:[{name:'repeats'}],// TODO: this one can also be parsed properly
// k: [{}], // outdated thing ignored
t:[{// t=0 0
name:'timing',reg:/^(\d*) (\d*)/,names:['start','stop'],format:'%d %d'}],c:[{// c=IN IP4 10.47.197.26
name:'connection',reg:/^IN IP(\d) (\S*)/,names:['version','ip'],format:'IN IP%d %s'}],b:[{// b=AS:4000
push:'bandwidth',reg:/^(TIAS|AS|CT|RR|RS):(\d*)/,names:['type','limit'],format:'%s:%s'}],m:[{// m=video 51744 RTP/AVP 126 97 98 34 31
// NB: special - pushes to session
// TODO: rtp/fmtp should be filtered by the payloads found here?
reg:/^(\w*) (\d*) ([\w/]*)(?: (.*))?/,names:['type','port','protocol','payloads'],format:'%s %d %s %s'}],a:[{// a=rtpmap:110 opus/48000/2
push:'rtp',reg:/^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,names:['payload','codec','rate','encoding'],format:function format(o){return o.encoding?'rtpmap:%d %s/%s/%s':o.rate?'rtpmap:%d %s/%s':'rtpmap:%d %s';}},{// a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
// a=fmtp:111 minptime=10; useinbandfec=1
push:'fmtp',reg:/^fmtp:(\d*) ([\S| ]*)/,names:['payload','config'],format:'fmtp:%d %s'},{// a=control:streamid=0
name:'control',reg:/^control:(.*)/,format:'control:%s'},{// a=rtcp:65179 IN IP4 193.84.77.194
name:'rtcp',reg:/^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,names:['port','netType','ipVer','address'],format:function format(o){return o.address!=null?'rtcp:%d %s IP%d %s':'rtcp:%d';}},{// a=rtcp-fb:98 trr-int 100
push:'rtcpFbTrrInt',reg:/^rtcp-fb:(\*|\d*) trr-int (\d*)/,names:['payload','value'],format:'rtcp-fb:%s trr-int %d'},{// a=rtcp-fb:98 nack rpsi
push:'rtcpFb',reg:/^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,names:['payload','type','subtype'],format:function format(o){return o.subtype!=null?'rtcp-fb:%s %s %s':'rtcp-fb:%s %s';}},{// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:1/recvonly URI-gps-string
// a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
push:'ext',reg:/^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,names:['value','direction','encrypt-uri','uri','config'],format:function format(o){return'extmap:%d'+(o.direction?'/%s':'%v')+(o['encrypt-uri']?' %s':'%v')+' %s'+(o.config?' %s':'');}},{// a=extmap-allow-mixed
name:'extmapAllowMixed',reg:/^(extmap-allow-mixed)/},{// a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
push:'crypto',reg:/^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,names:['id','suite','config','sessionConfig'],format:function format(o){return o.sessionConfig!=null?'crypto:%d %s %s %s':'crypto:%d %s %s';}},{// a=setup:actpass
name:'setup',reg:/^setup:(\w*)/,format:'setup:%s'},{// a=connection:new
name:'connectionType',reg:/^connection:(new|existing)/,format:'connection:%s'},{// a=mid:1
name:'mid',reg:/^mid:([^\s]*)/,format:'mid:%s'},{// a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
name:'msid',reg:/^msid:(.*)/,format:'msid:%s'},{// a=ptime:20
name:'ptime',reg:/^ptime:(\d*(?:\.\d*)*)/,format:'ptime:%d'},{// a=maxptime:60
name:'maxptime',reg:/^maxptime:(\d*(?:\.\d*)*)/,format:'maxptime:%d'},{// a=sendrecv
name:'direction',reg:/^(sendrecv|recvonly|sendonly|inactive)/},{// a=ice-lite
name:'icelite',reg:/^(ice-lite)/},{// a=ice-ufrag:F7gI
name:'iceUfrag',reg:/^ice-ufrag:(\S*)/,format:'ice-ufrag:%s'},{// a=ice-pwd:x9cml/YzichV2+XlhiMu8g
name:'icePwd',reg:/^ice-pwd:(\S*)/,format:'ice-pwd:%s'},{// a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
name:'fingerprint',reg:/^fingerprint:(\S*) (\S*)/,names:['type','hash'],format:'fingerprint:%s %s'},{// a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
// a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
// a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
// a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
// a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
push:'candidates',reg:/^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,names:['foundation','component','transport','priority','ip','port','type','raddr','rport','tcptype','generation','network-id','network-cost'],format:function format(o){var str='candidate:%s %d %s %d %s %d typ %s';str+=o.raddr!=null?' raddr %s rport %d':'%v%v';// NB: candidate has three optional chunks, so %void middles one if it's missing
str+=o.tcptype!=null?' tcptype %s':'%v';if(o.generation!=null){str+=' generation %d';}str+=o['network-id']!=null?' network-id %d':'%v';str+=o['network-cost']!=null?' network-cost %d':'%v';return str;}},{// a=end-of-candidates (keep after the candidates line for readability)
name:'endOfCandidates',reg:/^(end-of-candidates)/},{// a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
name:'remoteCandidates',reg:/^remote-candidates:(.*)/,format:'remote-candidates:%s'},{// a=ice-options:google-ice
name:'iceOptions',reg:/^ice-options:(\S*)/,format:'ice-options:%s'},{// a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
push:'ssrcs',reg:/^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,names:['id','attribute','value'],format:function format(o){var str='ssrc:%d';if(o.attribute!=null){str+=' %s';if(o.value!=null){str+=':%s';}}return str;}},{// a=ssrc-group:FEC 1 2
// a=ssrc-group:FEC-FR 3004364195 1080772241
push:'ssrcGroups',// token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
reg:/^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,names:['semantics','ssrcs'],format:'ssrc-group:%s %s'},{// a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
name:'msidSemantic',reg:/^msid-semantic:\s?(\w*) (\S*)/,names:['semantic','token'],format:'msid-semantic: %s %s'// space after ':' is not accidental
},{// a=group:BUNDLE audio video
push:'groups',reg:/^group:(\w*) (.*)/,names:['type','mids'],format:'group:%s %s'},{// a=rtcp-mux
name:'rtcpMux',reg:/^(rtcp-mux)/},{// a=rtcp-rsize
name:'rtcpRsize',reg:/^(rtcp-rsize)/},{// a=sctpmap:5000 webrtc-datachannel 1024
name:'sctpmap',reg:/^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,names:['sctpmapNumber','app','maxMessageSize'],format:function format(o){return o.maxMessageSize!=null?'sctpmap:%s %s %s':'sctpmap:%s %s';}},{// a=x-google-flag:conference
name:'xGoogleFlag',reg:/^x-google-flag:([^\s]*)/,format:'x-google-flag:%s'},{// a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
push:'rids',reg:/^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,names:['id','direction','params'],format:function format(o){return o.params?'rid:%s %s %s':'rid:%s %s';}},{// a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
// a=imageattr:* send [x=800,y=640] recv *
// a=imageattr:100 recv [x=320,y=240]
push:'imageattrs',reg:new RegExp(// a=imageattr:97
'^imageattr:(\\d+|\\*)'+// send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
'[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)'+// recv [x=330,y=250]
'(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'),names:['pt','dir1','attrs1','dir2','attrs2'],format:function format(o){return'imageattr:%s %s %s'+(o.dir2?' %s %s':'');}},{// a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
// a=simulcast:recv 1;4,5 send 6;7
name:'simulcast',reg:new RegExp(// a=simulcast:
'^simulcast:'+// send 1,2,3;~4,~5
'(send|recv) ([a-zA-Z0-9\\-_~;,]+)'+// space + recv 6;~7,~8
'(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?'+// end
'$'),names:['dir1','list1','dir2','list2'],format:function format(o){return'simulcast:%s %s'+(o.dir2?' %s %s':'');}},{// old simulcast draft 03 (implemented by Firefox)
//   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
// a=simulcast: recv pt=97;98 send pt=97
// a=simulcast: send rid=5;6;7 paused=6,7
name:'simulcast_03',reg:/^simulcast:[\s\t]+([\S+\s\t]+)$/,names:['value'],format:'simulcast: %s'},{// a=framerate:25
// a=framerate:29.97
name:'framerate',reg:/^framerate:(\d+(?:$|\.\d+))/,format:'framerate:%s'},{// RFC4570
// a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
name:'sourceFilter',reg:/^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,names:['filterMode','netType','addressTypes','destAddress','srcList'],format:'source-filter: %s %s %s %s %s'},{// a=bundle-only
name:'bundleOnly',reg:/^(bundle-only)/},{// a=label:1
name:'label',reg:/^label:(.+)/,format:'label:%s'},{// RFC version 26 for SCTP over DTLS
// https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
name:'sctpPort',reg:/^sctp-port:(\d+)$/,format:'sctp-port:%s'},{// RFC version 26 for SCTP over DTLS
// https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
name:'maxMessageSize',reg:/^max-message-size:(\d+)$/,format:'max-message-size:%s'},{// RFC7273
// a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
push:'tsRefClocks',reg:/^ts-refclk:([^\s=]*)(?:=(\S*))?/,names:['clksrc','clksrcExt'],format:function format(o){return'ts-refclk:%s'+(o.clksrcExt!=null?'=%s':'');}},{// RFC7273
// a=mediaclk:direct=963214424
name:'mediaClk',reg:/^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,names:['id','mediaClockName','mediaClockValue','rateNumerator','rateDenominator'],format:function format(o){var str='mediaclk:';str+=o.id!=null?'id=%s %s':'%v%s';str+=o.mediaClockValue!=null?'=%s':'';str+=o.rateNumerator!=null?' rate=%s':'';str+=o.rateDenominator!=null?'/%s':'';return str;}},{// a=keywds:keywords
name:'keywords',reg:/^keywds:(.+)$/,format:'keywds:%s'},{// a=content:main
name:'content',reg:/^content:(.+)/,format:'content:%s'},// BFCP https://tools.ietf.org/html/rfc4583
{// a=floorctrl:c-s
name:'bfcpFloorCtrl',reg:/^floorctrl:(c-only|s-only|c-s)/,format:'floorctrl:%s'},{// a=confid:1
name:'bfcpConfId',reg:/^confid:(\d+)/,format:'confid:%s'},{// a=userid:1
name:'bfcpUserId',reg:/^userid:(\d+)/,format:'userid:%s'},{// a=floorid:1
name:'bfcpFloorId',reg:/^floorid:(.+) (?:m-stream|mstrm):(.+)/,names:['id','mStream'],format:'floorid:%s mstrm:%s'},{// any a= that we don't understand is kept verbatim on media.invalid
push:'invalid',names:['value']}]};// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function(key){var objs=grammar[key];objs.forEach(function(obj){if(!obj.reg){obj.reg=/(.*)/;}if(!obj.format){obj.format='%s';}});});/***/}),/***/"./node_modules/sdp-transform/lib/index.js":(/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************//***/function _node_modules_sdpTransform_lib_indexJs(__unused_webpack_module,exports,__nested_webpack_require_746803__){var parser=__nested_webpack_require_746803__(/*! ./parser */"./node_modules/sdp-transform/lib/parser.js");var writer=__nested_webpack_require_746803__(/*! ./writer */"./node_modules/sdp-transform/lib/writer.js");exports.write=writer;exports.parse=parser.parse;exports.parseParams=parser.parseParams;exports.parseFmtpConfig=parser.parseFmtpConfig;// Alias of parseParams().
exports.parsePayloads=parser.parsePayloads;exports.parseRemoteCandidates=parser.parseRemoteCandidates;exports.parseImageAttributes=parser.parseImageAttributes;exports.parseSimulcastStreamList=parser.parseSimulcastStreamList;/***/}),/***/"./node_modules/sdp-transform/lib/parser.js":(/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************//***/function _node_modules_sdpTransform_lib_parserJs(__unused_webpack_module,exports,__nested_webpack_require_747704__){var toIntIfInt=function toIntIfInt(v){return String(Number(v))===v?Number(v):v;};var attachProperties=function attachProperties(match,location,names,rawName){if(rawName&&!names){location[rawName]=toIntIfInt(match[1]);}else{for(var i=0;i<names.length;i+=1){if(match[i+1]!=null){location[names[i]]=toIntIfInt(match[i+1]);}}}};var parseReg=function parseReg(obj,location,content){var needsBlank=obj.name&&obj.names;if(obj.push&&!location[obj.push]){location[obj.push]=[];}else if(needsBlank&&!location[obj.name]){location[obj.name]={};}var keyLocation=obj.push?{}:// blank object that will be pushed
needsBlank?location[obj.name]:location;// otherwise, named location or root
attachProperties(content.match(obj.reg),keyLocation,obj.names,obj.name);if(obj.push){location[obj.push].push(keyLocation);}};var grammar=__nested_webpack_require_747704__(/*! ./grammar */"./node_modules/sdp-transform/lib/grammar.js");var validLine=RegExp.prototype.test.bind(/^([a-z])=(.*)/);exports.parse=function(sdp){var session={},media=[],location=session;// points at where properties go under (one of the above)
// parse lines we understand
sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l){var type=l[0];var content=l.slice(2);if(type==='m'){media.push({rtp:[],fmtp:[]});location=media[media.length-1];// point at latest media line
}for(var j=0;j<(grammar[type]||[]).length;j+=1){var obj=grammar[type][j];if(obj.reg.test(content)){return parseReg(obj,location,content);}}});session.media=media;// link it up
return session;};var paramReducer=function paramReducer(acc,expr){var s=expr.split(/=(.+)/,2);if(s.length===2){acc[s[0]]=toIntIfInt(s[1]);}else if(s.length===1&&expr.length>1){acc[s[0]]=undefined;}return acc;};exports.parseParams=function(str){return str.split(/;\s?/).reduce(paramReducer,{});};// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig=exports.parseParams;exports.parsePayloads=function(str){return str.toString().split(' ').map(Number);};exports.parseRemoteCandidates=function(str){var candidates=[];var parts=str.split(' ').map(toIntIfInt);for(var i=0;i<parts.length;i+=3){candidates.push({component:parts[i],ip:parts[i+1],port:parts[i+2]});}return candidates;};exports.parseImageAttributes=function(str){return str.split(' ').map(function(item){return item.substring(1,item.length-1).split(',').reduce(paramReducer,{});});};exports.parseSimulcastStreamList=function(str){return str.split(';').map(function(stream){return stream.split(',').map(function(format){var scid,paused=false;if(format[0]!=='~'){scid=toIntIfInt(format);}else{scid=toIntIfInt(format.substring(1,format.length));paused=true;}return{scid:scid,paused:paused};});});};/***/}),/***/"./node_modules/sdp-transform/lib/writer.js":(/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************//***/function _node_modules_sdpTransform_lib_writerJs(module,__unused_webpack_exports,__nested_webpack_require_750710__){var grammar=__nested_webpack_require_750710__(/*! ./grammar */"./node_modules/sdp-transform/lib/grammar.js");// customized util.format - discards excess arguments and can void middle ones
var formatRegExp=/%[sdv%]/g;var format=function format(formatStr){var i=1;var args=arguments;var len=args.length;return formatStr.replace(formatRegExp,function(x){if(i>=len){return x;// missing argument
}var arg=args[i];i+=1;switch(x){case'%%':return'%';case'%s':return String(arg);case'%d':return Number(arg);case'%v':return'';}});// NB: we discard excess arguments - they are typically undefined from makeLine
};var makeLine=function makeLine(type,obj,location){var str=obj.format instanceof Function?obj.format(obj.push?location:location[obj.name]):obj.format;var args=[type+'='+str];if(obj.names){for(var i=0;i<obj.names.length;i+=1){var n=obj.names[i];if(obj.name){args.push(location[obj.name][n]);}else{// for mLine and push attributes
args.push(location[obj.names[i]]);}}}else{args.push(location[obj.name]);}return format.apply(null,args);};// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder=['v','o','s','i','u','e','p','c','b','t','r','z','a'];var defaultInnerOrder=['i','c','b','a'];module.exports=function(session,opts){opts=opts||{};// ensure certain properties exist
if(session.version==null){session.version=0;// 'v=0' must be there (only defined version atm)
}if(session.name==null){session.name=' ';// 's= ' must be there if no meaningful name set
}session.media.forEach(function(mLine){if(mLine.payloads==null){mLine.payloads='';}});var outerOrder=opts.outerOrder||defaultOuterOrder;var innerOrder=opts.innerOrder||defaultInnerOrder;var sdp=[];// loop through outerOrder for matching properties on session
outerOrder.forEach(function(type){grammar[type].forEach(function(obj){if(obj.name in session&&session[obj.name]!=null){sdp.push(makeLine(type,obj,session));}else if(obj.push in session&&session[obj.push]!=null){session[obj.push].forEach(function(el){sdp.push(makeLine(type,obj,el));});}});});// then for each media line, follow the innerOrder
session.media.forEach(function(mLine){sdp.push(makeLine('m',grammar.m[0],mLine));innerOrder.forEach(function(type){grammar[type].forEach(function(obj){if(obj.name in mLine&&mLine[obj.name]!=null){sdp.push(makeLine(type,obj,mLine));}else if(obj.push in mLine&&mLine[obj.push]!=null){mLine[obj.push].forEach(function(el){sdp.push(makeLine(type,obj,el));});}});});});return sdp.join('\r\n')+'\r\n';};/***/}),/***/"./node_modules/ua-parser-js/src/ua-parser.js":(/*!****************************************************!*\
  !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************//***/function _node_modules_uaParserJs_src_uaParserJs(module,exports,__nested_webpack_require_753503__){var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v1.0.39
   Copyright Â© 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js *//////////////////////////////////////////////////////////////////////////////////
(function(window,undefined){'use strict';//////////////
// Constants
/////////////
var LIBVERSION='1.0.39',EMPTY='',UNKNOWN='?',FUNC_TYPE='function',UNDEF_TYPE='undefined',OBJ_TYPE='object',STR_TYPE='string',MAJOR='major',MODEL='model',NAME='name',TYPE='type',VENDOR='vendor',VERSION='version',ARCHITECTURE='architecture',CONSOLE='console',MOBILE='mobile',TABLET='tablet',SMARTTV='smarttv',WEARABLE='wearable',EMBEDDED='embedded',UA_MAX_LENGTH=500;var AMAZON='Amazon',APPLE='Apple',ASUS='ASUS',BLACKBERRY='BlackBerry',BROWSER='Browser',CHROME='Chrome',EDGE='Edge',FIREFOX='Firefox',GOOGLE='Google',HUAWEI='Huawei',LG='LG',MICROSOFT='Microsoft',MOTOROLA='Motorola',OPERA='Opera',SAMSUNG='Samsung',SHARP='Sharp',SONY='Sony',XIAOMI='Xiaomi',ZEBRA='Zebra',FACEBOOK='Facebook',CHROMIUM_OS='Chromium OS',MAC_OS='Mac OS',SUFFIX_BROWSER=' Browser';///////////
// Helper
//////////
var extend=function extend(regexes,extensions){var mergedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){mergedRegexes[i]=extensions[i].concat(regexes[i]);}else{mergedRegexes[i]=regexes[i];}}return mergedRegexes;},enumerize=function enumerize(arr){var enums={};for(var i=0;i<arr.length;i++){enums[arr[i].toUpperCase()]=arr[i];}return enums;},has=function has(str1,str2){return _typeof2(str1)===STR_TYPE?lowerize(str2).indexOf(lowerize(str1))!==-1:false;},lowerize=function lowerize(str){return str.toLowerCase();},majorize=function majorize(version){return _typeof2(version)===STR_TYPE?version.replace(/[^\d\.]/g,EMPTY).split('.')[0]:undefined;},trim=function trim(str,len){if(_typeof2(str)===STR_TYPE){str=str.replace(/^\s\s*/,EMPTY);return _typeof2(len)===UNDEF_TYPE?str:str.substring(0,UA_MAX_LENGTH);}};///////////////
// Map helper
//////////////
var rgxMapper=function rgxMapper(ua,arrays){var i=0,j,k,p,q,matches,match;// loop through all regexes maps
while(i<arrays.length&&!matches){var regex=arrays[i],// even sequence (0,2,4,..)
props=arrays[i+1];// odd sequence (1,3,5,..)
j=k=0;// try matching uastring with regexes
while(j<regex.length&&!matches){if(!regex[j]){break;}matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];// check if given property is actually array
if(_typeof2(q)===OBJ_TYPE&&q.length>0){if(q.length===2){if(_typeof2(q[1])==FUNC_TYPE){// assign modified match
this[q[0]]=q[1].call(this,match);}else{// assign given value, ignore regex match
this[q[0]]=q[1];}}else if(q.length===3){// check whether function or regex
if(_typeof2(q[1])===FUNC_TYPE&&!(q[1].exec&&q[1].test)){// call function (usually string mapper)
this[q[0]]=match?q[1].call(this,match,q[2]):undefined;}else{// sanitize match using given regex
this[q[0]]=match?match.replace(q[1],q[2]):undefined;}}else if(q.length===4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined;}}else{this[q]=match?match:undefined;}}}}i+=2;}},strMapper=function strMapper(str,map){for(var i in map){// check if current value is array
if(_typeof2(map[i])===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(has(map[i][j],str)){return i===UNKNOWN?undefined:i;}}}else if(has(map[i],str)){return i===UNKNOWN?undefined:i;}}return map.hasOwnProperty('*')?map['*']:str;};///////////////
// String map
//////////////
// Safari < 3.0
var oldSafariMap={'1.0':'/8','1.2':'/1','1.3':'/3','2.0':'/412','2.0.2':'/416','2.0.3':'/417','2.0.4':'/419','?':'/'},windowsVersionMap={'ME':'4.90','NT 3.11':'NT3.51','NT 4.0':'NT4.0','2000':'NT 5.0','XP':['NT 5.1','NT 5.2'],'Vista':'NT 6.0','7':'NT 6.1','8':'NT 6.2','8.1':'NT 6.3','10':['NT 6.4','NT 10.0'],'RT':'ARM'};//////////////
// Regex map
/////////////
var regexes={browser:[[/\b(?:crmo|crios)\/([\w\.]+)/i// Chrome for Android/iOS
],[VERSION,[NAME,'Chrome']],[/edg(?:e|ios|a)?\/([\w\.]+)/i// Microsoft Edge
],[VERSION,[NAME,'Edge']],[// Presto based
/(opera mini)\/([-\w\.]+)/i,// Opera Mini
/(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,// Opera Mobi/Tablet
/(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i// Opera
],[NAME,VERSION],[/opios[\/ ]+([\w\.]+)/i// Opera mini on iphone >= 8.0
],[VERSION,[NAME,OPERA+' Mini']],[/\bop(?:rg)?x\/([\w\.]+)/i// Opera GX
],[VERSION,[NAME,OPERA+' GX']],[/\bopr\/([\w\.]+)/i// Opera Webkit
],[VERSION,[NAME,OPERA]],[// Mixed
/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i// Baidu
],[VERSION,[NAME,'Baidu']],[/(kindle)\/([\w\.]+)/i,// Kindle
/(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,// Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
// Trident based
/(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,// Avant/IEMobile/SlimBrowser
/(?:ms|\()(ie) ([\w\.]+)/i,// Internet Explorer
// Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
/(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio)\/([-\w\.]+)/i,// Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio
/(heytap|ovi)browser\/([\d\.]+)/i,// HeyTap/Ovi
/(weibo)__([\d\.]+)/i// Weibo
],[NAME,VERSION],[/quark(?:pc)?\/([-\w\.]+)/i// Quark
],[VERSION,[NAME,'Quark']],[/\bddg\/([\w\.]+)/i// DuckDuckGo
],[VERSION,[NAME,'DuckDuckGo']],[/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i// UCBrowser
],[VERSION,[NAME,'UC'+BROWSER]],[/microm.+\bqbcore\/([\w\.]+)/i,// WeChat Desktop for Windows Built-in Browser
/\bqbcore\/([\w\.]+).+microm/i,/micromessenger\/([\w\.]+)/i// WeChat
],[VERSION,[NAME,'WeChat']],[/konqueror\/([\w\.]+)/i// Konqueror
],[VERSION,[NAME,'Konqueror']],[/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i// IE11
],[VERSION,[NAME,'IE']],[/ya(?:search)?browser\/([\w\.]+)/i// Yandex
],[VERSION,[NAME,'Yandex']],[/slbrowser\/([\w\.]+)/i// Smart Lenovo Browser
],[VERSION,[NAME,'Smart Lenovo '+BROWSER]],[/(avast|avg)\/([\w\.]+)/i// Avast/AVG Secure Browser
],[[NAME,/(.+)/,'$1 Secure '+BROWSER],VERSION],[/\bfocus\/([\w\.]+)/i// Firefox Focus
],[VERSION,[NAME,FIREFOX+' Focus']],[/\bopt\/([\w\.]+)/i// Opera Touch
],[VERSION,[NAME,OPERA+' Touch']],[/coc_coc\w+\/([\w\.]+)/i// Coc Coc Browser
],[VERSION,[NAME,'Coc Coc']],[/dolfin\/([\w\.]+)/i// Dolphin
],[VERSION,[NAME,'Dolphin']],[/coast\/([\w\.]+)/i// Opera Coast
],[VERSION,[NAME,OPERA+' Coast']],[/miuibrowser\/([\w\.]+)/i// MIUI Browser
],[VERSION,[NAME,'MIUI '+BROWSER]],[/fxios\/([-\w\.]+)/i// Firefox for iOS
],[VERSION,[NAME,FIREFOX]],[/\bqihu|(qi?ho?o?|360)browser/i// 360
],[[NAME,'360'+SUFFIX_BROWSER]],[/\b(qq)\/([\w\.]+)/i// QQ
],[[NAME,/(.+)/,'$1Browser'],VERSION],[/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i],[[NAME,/(.+)/,'$1'+SUFFIX_BROWSER],VERSION],[// Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
/samsungbrowser\/([\w\.]+)/i// Samsung Internet
],[VERSION,[NAME,SAMSUNG+' Internet']],[/(comodo_dragon)\/([\w\.]+)/i// Comodo Dragon
],[[NAME,/_/g,' '],VERSION],[/metasr[\/ ]?([\d\.]+)/i// Sogou Explorer
],[VERSION,[NAME,'Sogou Explorer']],[/(sogou)mo\w+\/([\d\.]+)/i// Sogou Mobile
],[[NAME,'Sogou Mobile'],VERSION],[/(electron)\/([\w\.]+) safari/i,// Electron-based App
/(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,// Tesla
/m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i// QQBrowser/2345 Browser
],[NAME,VERSION],[/(lbbrowser|rekonq)/i,// LieBao Browser/Rekonq
/\[(linkedin)app\]/i// LinkedIn App for iOS & Android
],[NAME],[// WebView
/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i// Facebook App for iOS & Android
],[[NAME,FACEBOOK],VERSION],[/(Klarna)\/([\w\.]+)/i,// Klarna Shopping Browser for iOS & Android
/(kakao(?:talk|story))[\/ ]([\w\.]+)/i,// Kakao App
/(naver)\(.*?(\d+\.[\w\.]+).*\)/i,// Naver InApp
/safari (line)\/([\w\.]+)/i,// Line App for iOS
/\b(line)\/([\w\.]+)\/iab/i,// Line App for Android
/(alipay)client\/([\w\.]+)/i,// Alipay
/(twitter)(?:and| f.+e\/([\w\.]+))/i,// Twitter
/(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i// Chromium/Instagram/Snapchat
],[NAME,VERSION],[/\bgsa\/([\w\.]+) .*safari\//i// Google Search Appliance on iOS
],[VERSION,[NAME,'GSA']],[/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i// TikTok
],[VERSION,[NAME,'TikTok']],[/headlesschrome(?:\/([\w\.]+)| )/i// Chrome Headless
],[VERSION,[NAME,CHROME+' Headless']],[/ wv\).+(chrome)\/([\w\.]+)/i// Chrome WebView
],[[NAME,CHROME+' WebView'],VERSION],[/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i// Android Browser
],[VERSION,[NAME,'Android '+BROWSER]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i// Chrome/OmniWeb/Arora/Tizen/Nokia
],[NAME,VERSION],[/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i// Mobile Safari
],[VERSION,[NAME,'Mobile Safari']],[/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i// Safari & Safari Mobile
],[VERSION,NAME],[/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i// Safari < 3.0
],[NAME,[VERSION,strMapper,oldSafariMap]],[/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[// Gecko based
/(navigator|netscape\d?)\/([-\w\.]+)/i// Netscape
],[[NAME,'Netscape'],VERSION],[/(wolvic)\/([\w\.]+)/i// Wolvic
],[NAME,VERSION],[/mobile vr; rv:([\w\.]+)\).+firefox/i// Firefox Reality
],[VERSION,[NAME,FIREFOX+' Reality']],[/ekiohf.+(flow)\/([\w\.]+)/i,// Flow
/(swiftfox)/i,// Swiftfox
/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,// IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,// Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
/(firefox)\/([\w\.]+)/i,// Other Firefox-based
/(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,// Mozilla
// Other
/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,// Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
/(links) \(([\w\.]+)/i// Links
],[NAME,[VERSION,/_/g,'.']],[/(cobalt)\/([\w\.]+)/i// Cobalt
],[NAME,[VERSION,/master.|lts./,""]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i// AMD64 (x64)
],[[ARCHITECTURE,'amd64']],[/(ia32(?=;))/i// IA32 (quicktime)
],[[ARCHITECTURE,lowerize]],[/((?:i[346]|x)86)[;\)]/i// IA32 (x86)
],[[ARCHITECTURE,'ia32']],[/\b(aarch64|arm(v?8e?l?|_?64))\b/i// ARM64
],[[ARCHITECTURE,'arm64']],[/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i// ARMHF
],[[ARCHITECTURE,'armhf']],[// PocketPC mistakenly identified as PowerPC
/windows (ce|mobile); ppc;/i],[[ARCHITECTURE,'arm']],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i// PowerPC
],[[ARCHITECTURE,/ower/,EMPTY,lowerize]],[/(sun4\w)[;\)]/i// SPARC
],[[ARCHITECTURE,'sparc']],[/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i// IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
],[[ARCHITECTURE,lowerize]]],device:[[//////////////////////////
// MOBILES & TABLETS
/////////////////////////
// Samsung
/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],[MODEL,[VENDOR,SAMSUNG],[TYPE,TABLET]],[/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,/samsung[- ]((?!sm-[lr])[-\w]+)/i,/sec-(sgh\w+)/i],[MODEL,[VENDOR,SAMSUNG],[TYPE,MOBILE]],[// Apple
/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i// iPod/iPhone
],[MODEL,[VENDOR,APPLE],[TYPE,MOBILE]],[/\((ipad);[-\w\),; ]+apple/i,// iPad
/applecoremedia\/[\w\.]+ \((ipad)/i,/\b(ipad)\d\d?,\d\d?[;\]].+ios/i],[MODEL,[VENDOR,APPLE],[TYPE,TABLET]],[/(macintosh);/i],[MODEL,[VENDOR,APPLE]],[// Sharp
/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],[MODEL,[VENDOR,SHARP],[TYPE,MOBILE]],[// Huawei
/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],[MODEL,[VENDOR,HUAWEI],[TYPE,TABLET]],[/(?:huawei|honor)([-\w ]+)[;\)]/i,/\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],[MODEL,[VENDOR,HUAWEI],[TYPE,MOBILE]],[// Xiaomi
/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,// Xiaomi POCO
/\b; (\w+) build\/hm\1/i,// Xiaomi Hongmi 'numeric' models
/\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,// Xiaomi Hongmi
/\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,// Xiaomi Redmi
/oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,// Xiaomi Redmi 'numeric' models
/\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i// Xiaomi Mi
],[[MODEL,/_/g,' '],[VENDOR,XIAOMI],[TYPE,MOBILE]],[/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,// Redmi Pad
/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i// Mi Pad tablets
],[[MODEL,/_/g,' '],[VENDOR,XIAOMI],[TYPE,TABLET]],[// OPPO
/; (\w+) bui.+ oppo/i,/\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],[MODEL,[VENDOR,'OPPO'],[TYPE,MOBILE]],[/\b(opd2\d{3}a?) bui/i],[MODEL,[VENDOR,'OPPO'],[TYPE,TABLET]],[// Vivo
/vivo (\w+)(?: bui|\))/i,/\b(v[12]\d{3}\w?[at])(?: bui|;)/i],[MODEL,[VENDOR,'Vivo'],[TYPE,MOBILE]],[// Realme
/\b(rmx[1-3]\d{3})(?: bui|;|\))/i],[MODEL,[VENDOR,'Realme'],[TYPE,MOBILE]],[// Motorola
/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,/\bmot(?:orola)?[- ](\w*)/i,/((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],[MODEL,[VENDOR,MOTOROLA],[TYPE,MOBILE]],[/\b(mz60\d|xoom[2 ]{0,2}) build\//i],[MODEL,[VENDOR,MOTOROLA],[TYPE,TABLET]],[// LG
/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],[MODEL,[VENDOR,LG],[TYPE,TABLET]],[/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,/\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,/\blg-?([\d\w]+) bui/i],[MODEL,[VENDOR,LG],[TYPE,MOBILE]],[// Lenovo
/(ideatab[-\w ]+)/i,/lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],[MODEL,[VENDOR,'Lenovo'],[TYPE,TABLET]],[// Nokia
/(?:maemo|nokia).*(n900|lumia \d+)/i,/nokia[-_ ]?([-\w\.]*)/i],[[MODEL,/_/g,' '],[VENDOR,'Nokia'],[TYPE,MOBILE]],[// Google
/(pixel c)\b/i// Google Pixel C
],[MODEL,[VENDOR,GOOGLE],[TYPE,TABLET]],[/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i// Google Pixel
],[MODEL,[VENDOR,GOOGLE],[TYPE,MOBILE]],[// Sony
/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[MODEL,[VENDOR,SONY],[TYPE,MOBILE]],[/sony tablet [ps]/i,/\b(?:sony)?sgp\w+(?: bui|\))/i],[[MODEL,'Xperia Tablet'],[VENDOR,SONY],[TYPE,TABLET]],[// OnePlus
/ (kb2005|in20[12]5|be20[12][59])\b/i,/(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],[MODEL,[VENDOR,'OnePlus'],[TYPE,MOBILE]],[// Amazon
/(alexa)webm/i,/(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,// Kindle Fire without Silk / Echo Show
/(kf[a-z]+)( bui|\)).+silk\//i// Kindle Fire HD
],[MODEL,[VENDOR,AMAZON],[TYPE,TABLET]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i// Fire Phone
],[[MODEL,/(.+)/g,'Fire Phone $1'],[VENDOR,AMAZON],[TYPE,MOBILE]],[// BlackBerry
/(playbook);[-\w\),; ]+(rim)/i// BlackBerry PlayBook
],[MODEL,VENDOR,[TYPE,TABLET]],[/\b((?:bb[a-f]|st[hv])100-\d)/i,/\(bb10; (\w+)/i// BlackBerry 10
],[MODEL,[VENDOR,BLACKBERRY],[TYPE,MOBILE]],[// Asus
/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],[MODEL,[VENDOR,ASUS],[TYPE,TABLET]],[/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],[MODEL,[VENDOR,ASUS],[TYPE,MOBILE]],[// HTC
/(nexus 9)/i// HTC Nexus 9
],[MODEL,[VENDOR,'HTC'],[TYPE,TABLET]],[/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,// HTC
// ZTE
/(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i// Alcatel/GeeksPhone/Nexian/Panasonic/Sony
],[VENDOR,[MODEL,/_/g,' '],[TYPE,MOBILE]],[// TCL
/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i],[MODEL,[VENDOR,'TCL'],[TYPE,TABLET]],[// itel
/(itel) ((\w+))/i],[[VENDOR,lowerize],MODEL,[TYPE,strMapper,{'tablet':['p10001l','w7001'],'*':'mobile'}]],[// Acer
/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],[MODEL,[VENDOR,'Acer'],[TYPE,TABLET]],[// Meizu
/droid.+; (m[1-5] note) bui/i,/\bmz-([-\w]{2,})/i],[MODEL,[VENDOR,'Meizu'],[TYPE,MOBILE]],[// Ulefone
/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i],[MODEL,[VENDOR,'Ulefone'],[TYPE,MOBILE]],[// Nothing
/droid.+; (a(?:015|06[35]|142p?))/i],[MODEL,[VENDOR,'Nothing'],[TYPE,MOBILE]],[// MIXED
/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,// BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
/(hp) ([\w ]+\w)/i,// HP iPAQ
/(asus)-?(\w+)/i,// Asus
/(microsoft); (lumia[\w ]+)/i,// Microsoft Lumia
/(lenovo)[-_ ]?([-\w]+)/i,// Lenovo
/(jolla)/i,// Jolla
/(oppo) ?([\w ]+) bui/i// OPPO
],[VENDOR,MODEL,[TYPE,MOBILE]],[/(kobo)\s(ereader|touch)/i,// Kobo
/(archos) (gamepad2?)/i,// Archos
/(hp).+(touchpad(?!.+tablet)|tablet)/i,// HP TouchPad
/(kindle)\/([\w\.]+)/i,// Kindle
/(nook)[\w ]+build\/(\w+)/i,// Nook
/(dell) (strea[kpr\d ]*[\dko])/i,// Dell Streak
/(le[- ]+pan)[- ]+(\w{1,9}) bui/i,// Le Pan Tablets
/(trinity)[- ]*(t\d{3}) bui/i,// Trinity Tablets
/(gigaset)[- ]+(q\w{1,9}) bui/i,// Gigaset Tablets
/(vodafone) ([\w ]+)(?:\)| bui)/i// Vodafone
],[VENDOR,MODEL,[TYPE,TABLET]],[/(surface duo)/i// Surface Duo
],[MODEL,[VENDOR,MICROSOFT],[TYPE,TABLET]],[/droid [\d\.]+; (fp\du?)(?: b|\))/i// Fairphone
],[MODEL,[VENDOR,'Fairphone'],[TYPE,MOBILE]],[/(u304aa)/i// AT&T
],[MODEL,[VENDOR,'AT&T'],[TYPE,MOBILE]],[/\bsie-(\w*)/i// Siemens
],[MODEL,[VENDOR,'Siemens'],[TYPE,MOBILE]],[/\b(rct\w+) b/i// RCA Tablets
],[MODEL,[VENDOR,'RCA'],[TYPE,TABLET]],[/\b(venue[\d ]{2,7}) b/i// Dell Venue Tablets
],[MODEL,[VENDOR,'Dell'],[TYPE,TABLET]],[/\b(q(?:mv|ta)\w+) b/i// Verizon Tablet
],[MODEL,[VENDOR,'Verizon'],[TYPE,TABLET]],[/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i// Barnes & Noble Tablet
],[MODEL,[VENDOR,'Barnes & Noble'],[TYPE,TABLET]],[/\b(tm\d{3}\w+) b/i],[MODEL,[VENDOR,'NuVision'],[TYPE,TABLET]],[/\b(k88) b/i// ZTE K Series Tablet
],[MODEL,[VENDOR,'ZTE'],[TYPE,TABLET]],[/\b(nx\d{3}j) b/i// ZTE Nubia
],[MODEL,[VENDOR,'ZTE'],[TYPE,MOBILE]],[/\b(gen\d{3}) b.+49h/i// Swiss GEN Mobile
],[MODEL,[VENDOR,'Swiss'],[TYPE,MOBILE]],[/\b(zur\d{3}) b/i// Swiss ZUR Tablet
],[MODEL,[VENDOR,'Swiss'],[TYPE,TABLET]],[/\b((zeki)?tb.*\b) b/i// Zeki Tablets
],[MODEL,[VENDOR,'Zeki'],[TYPE,TABLET]],[/\b([yr]\d{2}) b/i,/\b(dragon[- ]+touch |dt)(\w{5}) b/i// Dragon Touch Tablet
],[[VENDOR,'Dragon Touch'],MODEL,[TYPE,TABLET]],[/\b(ns-?\w{0,9}) b/i// Insignia Tablets
],[MODEL,[VENDOR,'Insignia'],[TYPE,TABLET]],[/\b((nxa|next)-?\w{0,9}) b/i// NextBook Tablets
],[MODEL,[VENDOR,'NextBook'],[TYPE,TABLET]],[/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i// Voice Xtreme Phones
],[[VENDOR,'Voice'],MODEL,[TYPE,MOBILE]],[/\b(lvtel\-)?(v1[12]) b/i// LvTel Phones
],[[VENDOR,'LvTel'],MODEL,[TYPE,MOBILE]],[/\b(ph-1) /i// Essential PH-1
],[MODEL,[VENDOR,'Essential'],[TYPE,MOBILE]],[/\b(v(100md|700na|7011|917g).*\b) b/i// Envizen Tablets
],[MODEL,[VENDOR,'Envizen'],[TYPE,TABLET]],[/\b(trio[-\w\. ]+) b/i// MachSpeed Tablets
],[MODEL,[VENDOR,'MachSpeed'],[TYPE,TABLET]],[/\btu_(1491) b/i// Rotor Tablets
],[MODEL,[VENDOR,'Rotor'],[TYPE,TABLET]],[/(shield[\w ]+) b/i// Nvidia Shield Tablets
],[MODEL,[VENDOR,'Nvidia'],[TYPE,TABLET]],[/(sprint) (\w+)/i// Sprint Phones
],[VENDOR,MODEL,[TYPE,MOBILE]],[/(kin\.[onetw]{3})/i// Microsoft Kin
],[[MODEL,/\./g,' '],[VENDOR,MICROSOFT],[TYPE,MOBILE]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i// Zebra
],[MODEL,[VENDOR,ZEBRA],[TYPE,TABLET]],[/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],[MODEL,[VENDOR,ZEBRA],[TYPE,MOBILE]],[///////////////////
// SMARTTVS
///////////////////
/smart-tv.+(samsung)/i// Samsung
],[VENDOR,[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,'SmartTV'],[VENDOR,SAMSUNG],[TYPE,SMARTTV]],[/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i// LG SmartTV
],[[VENDOR,LG],[TYPE,SMARTTV]],[/(apple) ?tv/i// Apple TV
],[VENDOR,[MODEL,APPLE+' TV'],[TYPE,SMARTTV]],[/crkey/i// Google Chromecast
],[[MODEL,CHROME+'cast'],[VENDOR,GOOGLE],[TYPE,SMARTTV]],[/droid.+aft(\w+)( bui|\))/i// Fire TV
],[MODEL,[VENDOR,AMAZON],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i,/(aquos-tv[\w ]+)\)/i// Sharp
],[MODEL,[VENDOR,SHARP],[TYPE,SMARTTV]],[/(bravia[\w ]+)( bui|\))/i// Sony
],[MODEL,[VENDOR,SONY],[TYPE,SMARTTV]],[/(mitv-\w{5}) bui/i// Xiaomi
],[MODEL,[VENDOR,XIAOMI],[TYPE,SMARTTV]],[/Hbbtv.*(technisat) (.*);/i// TechniSAT
],[VENDOR,MODEL,[TYPE,SMARTTV]],[/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,// Roku
/hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i// HbbTV devices
],[[VENDOR,trim],[MODEL,trim],[TYPE,SMARTTV]],[/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i// SmartTV from Unidentified Vendors
],[[TYPE,SMARTTV]],[///////////////////
// CONSOLES
///////////////////
/(ouya)/i,// Ouya
/(nintendo) ([wids3utch]+)/i// Nintendo
],[VENDOR,MODEL,[TYPE,CONSOLE]],[/droid.+; (shield) bui/i// Nvidia
],[MODEL,[VENDOR,'Nvidia'],[TYPE,CONSOLE]],[/(playstation [345portablevi]+)/i// Playstation
],[MODEL,[VENDOR,SONY],[TYPE,CONSOLE]],[/\b(xbox(?: one)?(?!; xbox))[\); ]/i// Microsoft Xbox
],[MODEL,[VENDOR,MICROSOFT],[TYPE,CONSOLE]],[///////////////////
// WEARABLES
///////////////////
/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i// Samsung Galaxy Watch
],[MODEL,[VENDOR,SAMSUNG],[TYPE,WEARABLE]],[/((pebble))app/i// Pebble
],[VENDOR,MODEL,[TYPE,WEARABLE]],[/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i// Apple Watch
],[MODEL,[VENDOR,APPLE],[TYPE,WEARABLE]],[/droid.+; (glass) \d/i// Google Glass
],[MODEL,[VENDOR,GOOGLE],[TYPE,WEARABLE]],[/droid.+; (wt63?0{2,3})\)/i],[MODEL,[VENDOR,ZEBRA],[TYPE,WEARABLE]],[/(quest( \d| pro)?)/i// Oculus Quest
],[MODEL,[VENDOR,FACEBOOK],[TYPE,WEARABLE]],[///////////////////
// EMBEDDED
///////////////////
/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i// Tesla
],[VENDOR,[TYPE,EMBEDDED]],[/(aeobc)\b/i// Echo Dot
],[MODEL,[VENDOR,AMAZON],[TYPE,EMBEDDED]],[////////////////////
// MIXED (GENERIC)
///////////////////
/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i// Android Phones from Unidentified Vendors
],[MODEL,[TYPE,MOBILE]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i// Android Tablets from Unidentified Vendors
],[MODEL,[TYPE,TABLET]],[/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i// Unidentifiable Tablet
],[[TYPE,TABLET]],[/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i// Unidentifiable Mobile
],[[TYPE,MOBILE]],[/(android[-\w\. ]{0,9});.+buil/i// Generic Android Device
],[MODEL,[VENDOR,'Generic']]],engine:[[/windows.+ edge\/([\w\.]+)/i// EdgeHTML
],[VERSION,[NAME,EDGE+'HTML']],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i// Blink
],[VERSION,[NAME,'Blink']],[/(presto)\/([\w\.]+)/i,// Presto
/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,// WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
/ekioh(flow)\/([\w\.]+)/i,// Flow
/(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,// KHTML/Tasman/Links
/(icab)[\/ ]([23]\.[\d\.]+)/i,// iCab
/\b(libweb)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9})\b.+(gecko)/i// Gecko
],[VERSION,NAME]],os:[[// Windows
/microsoft (windows) (vista|xp)/i// Windows (iTunes)
],[NAME,VERSION],[/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i// Windows Phone
],[NAME,[VERSION,strMapper,windowsVersionMap]],[/windows nt 6\.2; (arm)/i,// Windows RT
/windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,/(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i],[[VERSION,strMapper,windowsVersionMap],[NAME,'Windows']],[// iOS/macOS
/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,// iOS
/(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,/cfnetwork\/.+darwin/i],[[VERSION,/_/g,'.'],[NAME,'iOS']],[/(mac os x) ?([\w\. ]*)/i,/(macintosh|mac_powerpc\b)(?!.+haiku)/i// Mac OS
],[[NAME,MAC_OS],[VERSION,/_/g,'.']],[// Mobile OSes
/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i// Android-x86/HarmonyOS
],[VERSION,NAME],[// Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,/(blackberry)\w*\/([\w\.]*)/i,// Blackberry
/(tizen|kaios)[\/ ]([\w\.]+)/i,// Tizen/KaiOS
/\((series40);/i// Series 40
],[NAME,VERSION],[/\(bb(10);/i// BlackBerry 10
],[VERSION,[NAME,BLACKBERRY]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i// Symbian
],[VERSION,[NAME,'Symbian']],[/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i// Firefox OS
],[VERSION,[NAME,FIREFOX+' OS']],[/web0s;.+rt(tv)/i,/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i// WebOS
],[VERSION,[NAME,'webOS']],[/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i// watchOS
],[VERSION,[NAME,'watchOS']],[// Google Chromecast
/crkey\/([\d\.]+)/i// Google Chromecast
],[VERSION,[NAME,CHROME+'cast']],[/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i// Chromium OS
],[[NAME,CHROMIUM_OS],VERSION],[// Smart TVs
/panasonic;(viera)/i,// Panasonic Viera
/(netrange)mmh/i,// Netrange
/(nettv)\/(\d+\.[\w\.]+)/i,// NetTV
// Console
/(nintendo|playstation) ([wids345portablevuch]+)/i,// Nintendo/Playstation
/(xbox); +xbox ([^\);]+)/i,// Microsoft Xbox (360, One, X, S, Series X, Series S)
// Other
/\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,// Joli/Palm
/(mint)[\/\(\) ]?(\w*)/i,// Mint
/(mageia|vectorlinux)[; ]/i,// Mageia/VectorLinux
/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,// Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
/(hurd|linux) ?([\w\.]*)/i,// Hurd/Linux
/(gnu) ?([\w\.]*)/i,// GNU
/\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,// FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
/(haiku) (\w+)/i// Haiku
],[NAME,VERSION],[/(sunos) ?([\w\.\d]*)/i// Solaris
],[[NAME,'Solaris'],VERSION],[/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,// Solaris
/(aix) ((\d)(?=\.|\)| )[\w\.])*/i,// AIX
/\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,// BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
/(unix) ?([\w\.]*)/i// UNIX
],[NAME,VERSION]]};/////////////////
// Constructor
////////////////
var _UAParser=function UAParser(ua,extensions){if(_typeof2(ua)===OBJ_TYPE){extensions=ua;ua=undefined;}if(!(this instanceof _UAParser)){return new _UAParser(ua,extensions).getResult();}var _navigator=_typeof2(window)!==UNDEF_TYPE&&window.navigator?window.navigator:undefined;var _ua=ua||(_navigator&&_navigator.userAgent?_navigator.userAgent:EMPTY);var _uach=_navigator&&_navigator.userAgentData?_navigator.userAgentData:undefined;var _rgxmap=extensions?extend(regexes,extensions):regexes;var _isSelfNav=_navigator&&_navigator.userAgent==_ua;this.getBrowser=function(){var _browser={};_browser[NAME]=undefined;_browser[VERSION]=undefined;rgxMapper.call(_browser,_ua,_rgxmap.browser);_browser[MAJOR]=majorize(_browser[VERSION]);// Brave-specific detection
if(_isSelfNav&&_navigator&&_navigator.brave&&_typeof2(_navigator.brave.isBrave)==FUNC_TYPE){_browser[NAME]='Brave';}return _browser;};this.getCPU=function(){var _cpu={};_cpu[ARCHITECTURE]=undefined;rgxMapper.call(_cpu,_ua,_rgxmap.cpu);return _cpu;};this.getDevice=function(){var _device={};_device[VENDOR]=undefined;_device[MODEL]=undefined;_device[TYPE]=undefined;rgxMapper.call(_device,_ua,_rgxmap.device);if(_isSelfNav&&!_device[TYPE]&&_uach&&_uach.mobile){_device[TYPE]=MOBILE;}// iPadOS-specific detection: identified as Mac, but has some iOS-only properties
if(_isSelfNav&&_device[MODEL]=='Macintosh'&&_navigator&&_typeof2(_navigator.standalone)!==UNDEF_TYPE&&_navigator.maxTouchPoints&&_navigator.maxTouchPoints>2){_device[MODEL]='iPad';_device[TYPE]=TABLET;}return _device;};this.getEngine=function(){var _engine={};_engine[NAME]=undefined;_engine[VERSION]=undefined;rgxMapper.call(_engine,_ua,_rgxmap.engine);return _engine;};this.getOS=function(){var _os={};_os[NAME]=undefined;_os[VERSION]=undefined;rgxMapper.call(_os,_ua,_rgxmap.os);if(_isSelfNav&&!_os[NAME]&&_uach&&_uach.platform&&_uach.platform!='Unknown'){_os[NAME]=_uach.platform.replace(/chrome os/i,CHROMIUM_OS).replace(/macos/i,MAC_OS);// backward compatibility
}return _os;};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()};};this.getUA=function(){return _ua;};this.setUA=function(ua){_ua=_typeof2(ua)===STR_TYPE&&ua.length>UA_MAX_LENGTH?trim(ua,UA_MAX_LENGTH):ua;return this;};this.setUA(_ua);return this;};_UAParser.VERSION=LIBVERSION;_UAParser.BROWSER=enumerize([NAME,VERSION,MAJOR]);_UAParser.CPU=enumerize([ARCHITECTURE]);_UAParser.DEVICE=enumerize([MODEL,VENDOR,TYPE,CONSOLE,MOBILE,SMARTTV,TABLET,WEARABLE,EMBEDDED]);_UAParser.ENGINE=_UAParser.OS=enumerize([NAME,VERSION]);///////////
// Export
//////////
// check js environment
if(_typeof2(exports)!==UNDEF_TYPE){// nodejs env
if("object"!==UNDEF_TYPE&&module.exports){exports=module.exports=_UAParser;}exports.UAParser=_UAParser;}else{// requirejs env (optional)
if("function"===FUNC_TYPE&&__nested_webpack_require_753503__.amdO){!(__WEBPACK_AMD_DEFINE_RESULT__=function(){return _UAParser;}.call(exports,__nested_webpack_require_753503__,exports,module),__WEBPACK_AMD_DEFINE_RESULT__!==undefined&&(module.exports=__WEBPACK_AMD_DEFINE_RESULT__));}else if(_typeof2(window)!==UNDEF_TYPE){// browser env
window.UAParser=_UAParser;}}// jQuery/Zepto specific (optional)
// Note:
//   In AMD env the global scope should be kept clean, but jQuery is an exception.
//   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
//   and we should catch that.
var $=_typeof2(window)!==UNDEF_TYPE&&(window.jQuery||window.Zepto);if($&&!$.ua){var parser=new _UAParser();$.ua=parser.getResult();$.ua.get=function(){return parser.getUA();};$.ua.set=function(ua){parser.setUA(ua);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop];}};}})((typeof window==="undefined"?"undefined":_typeof2(window))==='object'?window:this);/***/})/******/};/************************************************************************//******/// The module cache
/******/var __webpack_module_cache__={};/******//******/// The require function
/******/function __nested_webpack_require_784044__(moduleId){/******/// Check if module is in cache
/******/var cachedModule=__webpack_module_cache__[moduleId];/******/if(cachedModule!==undefined){/******/return cachedModule.exports;/******/}/******/// Create a new module (and put it into the cache)
/******/var module=__webpack_module_cache__[moduleId]={/******/// no module.id needed
/******/// no module.loaded needed
/******/exports:{}/******/};/******//******/// Execute the module function
/******/__webpack_modules__[moduleId].call(module.exports,module,module.exports,__nested_webpack_require_784044__);/******//******/// Return the exports of the module
/******/return module.exports;/******/}/******//************************************************************************//******//* webpack/runtime/amd options *//******/(function(){/******/__nested_webpack_require_784044__.amdO={};/******/})();/******//******//* webpack/runtime/global *//******/(function(){/******/__nested_webpack_require_784044__.g=function(){/******/if((typeof globalThis==="undefined"?"undefined":_typeof2(globalThis))==='object')return globalThis;/******/try{/******/return this||new Function('return this')();/******/}catch(e){/******/if((typeof window==="undefined"?"undefined":_typeof2(window))==='object')return window;/******/}/******/}();/******/})();/******//************************************************************************/var __webpack_exports__={};// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(function(){/*!**************************************!*\
  !*** ./services/mediaSoupService.js ***!
  \**************************************/function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o;},_typeof(o);}var _socketService=_interopRequireDefault(__nested_webpack_require_784044__(/*! ./socketService.js */"./services/socketService.js"));var _chatService=__nested_webpack_require_784044__(/*! ./chatService.js */"./services/chatService.js");var _mediasoupClient=__nested_webpack_require_784044__(/*! mediasoup-client */"./node_modules/mediasoup-client/lib/index.js");function _interopRequireDefault(e){return e&&e.__esModule?e:{"default":e};}function _regeneratorRuntime(){"use strict";/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function _regeneratorRuntime(){return e;};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value;},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e];}try{define({},"");}catch(t){define=function define(t,e,r){return t[e]=r;};}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a;}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)};}catch(t){return{type:"throw",arg:t};}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,function(){return this;});var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach(function(e){define(t,e,function(t){return this._invoke(e,t);});});}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==_typeof(h)&&n.call(h,"__await")?e.resolve(h.__await).then(function(t){invoke("next",t,i,a);},function(t){invoke("throw",t,i,a);}):e.resolve(h).then(function(t){u.value=t,i(u);},function(t){return invoke("throw",t,i,a);});}a(c.arg);}var r;o(this,"_invoke",{value:function value(t,n){function callInvokeWithMethodAndArg(){return new e(function(e,r){invoke(t,n,e,r);});}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}});}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0};}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u;}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg);}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done};}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg);}};}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator["return"]&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y);}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e);}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e;}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0);}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next;};return i.next=i;}}throw new TypeError(_typeof(e)+" is not iterable");}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name));},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t;},e.awrap=function(t){return{__await:t};},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,function(){return this;}),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then(function(t){return t.done?t.value:a.next();});},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,function(){return this;}),define(g,"toString",function(){return"[object Generator]";}),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next;}return next.done=!0,next;};},e.values=values,Context.prototype={constructor:Context,reset:function reset(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t);},stop:function stop(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval;},dispatchException:function dispatchException(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o;}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc);}}}},abrupt:function abrupt(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break;}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a);},complete:function complete(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y;},finish:function finish(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y;}},"catch":function _catch(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r);}return o;}}throw Error("illegal catch attempt");},delegateYield:function delegateYield(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y;}},e;}function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value;}catch(n){return void e(n);}i.done?t(u):Promise.resolve(u).then(r,o);}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n);}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n);}_next(void 0);});};}// const { io } = require('socket.io-client');
// const socket = io('http://localhost:3000');
// import { socket, createConnection} from './socketService.js';
var localVideo=document.getElementById('localVideo');// const remoteVideo = document.getElementById('remoteVideo');
var start=document.getElementById('start');// const join = document.getElementById('join');
var rtpCapabilities;var device;var sendTransport;var recvTransport;var producer;var consumer;var isProducer=false;start.addEventListener('click',/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:// await initializeSocket();
console.log('start button');_context.next=3;return initializeDevice();case 3:setTimeout(function(){createSendTransport();},500);case 4:case"end":return _context.stop();}},_callee);})));var urlParams=new URLSearchParams(window.location.search);var roomId=urlParams.get('roomId');var userName=urlParams.get('username');console.log('roomid: ',roomId);var socket;_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:socket=_socketService["default"].initialize();_socketService["default"].connect();socket.on('connect',function(){console.log('Socket connected:',socket.id);(0,_chatService.chatroom)(roomId,userName,socket);});case 3:case"end":return _context2.stop();}},_callee2);}))// socket  = await connectSocket(roomId, userName);
// socket.on('connect', () => {
//     console.log('Socket connected:', socket.id);
//     chatroom(roomId, userName, socket)
// });
();function socketConnection(){return _socketConnection.apply(this,arguments);}//   createConnection(roomId,userName).then((result) => {
//     console.log('socket in media: ', result);
//     chatroom(roomId,userName,result);
//     socket = result;
//     socketInstance(socket);
//   }).catch((err) => {
//     console.log(err);
//   })
// Make sure to await the socket connection
// (async () => {
//     // await socketConnection();
// })();
function _socketConnection(){_socketConnection=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(){var result;return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:try{result=createConnection(roomId,userName);console.log('socket in media: ');// Initialize message service before chatroom
// await socketInstance(result);
// Then initialize chatroom
(0,_chatService.chatroom)(roomId,userName,result);// let socket = result;
}catch(err){console.error('Socket connection error:',err);}case 1:case"end":return _context3.stop();}},_callee3);}));return _socketConnection.apply(this,arguments);}function streamSuccess(stream){localVideo.srcObject=stream;}function mediaStream(){return _mediaStream.apply(this,arguments);}// socket.on('connect', () => {
//     console.log(`A client connected: ${socket.id}`);
//     socket.emit('room',roomId,(data) => {
//             console.log("new client joined the room")
//             mediaStream();
//             rtpCapabilities = data.rtpCapabilities;
//     });
// })
function _mediaStream(){_mediaStream=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(){return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:navigator.mediaDevices.getUserMedia({audio:false,video:true}).then(function(stream){streamSuccess(stream);})["catch"](function(err){console.log(err);});case 1:case"end":return _context4.stop();}},_callee4);}));return _mediaStream.apply(this,arguments);}function initializeDevice(){return _initializeDevice.apply(this,arguments);}//get all the producers that are already in the room
function _initializeDevice(){_initializeDevice=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(){var routerRtpCapabilities;return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:console.log("Initializing device");device=new _mediasoupClient.Device();routerRtpCapabilities=rtpCapabilities;_context5.next=5;return device.load({routerRtpCapabilities:routerRtpCapabilities});case 5:console.log('Device loaded with rtpCapabilities: ',device.rtpCapabilities);// socket.emit('getRtpCapabilities',{},async (rtpCapabilities) => {
//     console.log('getting rtpCapabilities: ',rtpCapabilities)
//     const routerRtpCapabilities = rtpCapabilities;
//     device = new mediasoupClient.Device();
//     await device.load({routerRtpCapabilities});
//     console.log('Device loaded with rtpCapabilities: ',device.rtpCapabilities);
// })
case 6:case"end":return _context5.stop();}},_callee5);}));return _initializeDevice.apply(this,arguments);}function getProducers(){return _getProducers.apply(this,arguments);}function _getProducers(){_getProducers=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(){return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:console.log('producer exists');socket.emit('getProducers',{},function(_ref3){var producerList=_ref3.producerList;console.log("Producer ids: ",producerList);producerList.forEach(function(element){console.log("you are both producer and consumer");newConsumer(element);});});case 2:case"end":return _context6.stop();}},_callee6);}));return _getProducers.apply(this,arguments);}function createSendTransport(){return _createSendTransport.apply(this,arguments);}function _createSendTransport(){_createSendTransport=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(){return _regeneratorRuntime().wrap(function _callee10$(_context10){while(1)switch(_context10.prev=_context10.next){case 0:if(!device)console.log("Device not initialized");socket.emit('createTransport',{rtpCapabilities:device.rtpCapabilities,consumer:false},/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(params){return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1)switch(_context9.prev=_context9.next){case 0:console.log("Params from send tranport: ",params);_context9.prev=1;_context9.next=4;return device.createSendTransport(params);case 4:sendTransport=_context9.sent;sendTransport.on('connect',/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref5,callback,errback){var dtlsParameters;return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:dtlsParameters=_ref5.dtlsParameters;console.log("dtlsparameters: ",dtlsParameters);try{console.log("producer connect event");socket.emit('producer-connect',{id:sendTransport.id,dtlsParameters:dtlsParameters});callback();}catch(err){console.log("Error emitting produce-connect: ",err);errback(err);}case 3:case"end":return _context7.stop();}},_callee7);}));return function(_x6,_x7,_x8){return _ref6.apply(this,arguments);};}());sendTransport.on('produce',/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(parameters,callback,errback){var _socket$emit,id;return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:try{console.log('produce event');_socket$emit=socket.emit('produce',{id:sendTransport.id,kind:parameters.kind,rtpParameters:parameters.rtpParameters},function(_ref8){var id=_ref8.id,producerExists=_ref8.producerExists;console.log("producer exists: ",producerExists);callback({id:id});if(producerExists)getProducers();}),id=_socket$emit.id;}catch(err){errback(err);}case 1:case"end":return _context8.stop();}},_callee8);}));return function(_x9,_x10,_x11){return _ref7.apply(this,arguments);};}());sendTransport.on('icestatechange',function(state){console.log("IceStateChange: ",state);});sendTransport.on('connectionstatechange',function(state){console.log("ConnectionStateChange: ",state);});_context9.next=11;return produceMedia();case 11:_context9.next=16;break;case 13:_context9.prev=13;_context9.t0=_context9["catch"](1);console.log("Error creating sendTransport: ",_context9.t0);case 16:case"end":return _context9.stop();}},_callee9,null,[[1,13]]);}));return function(_x5){return _ref4.apply(this,arguments);};}());case 2:case"end":return _context10.stop();}},_callee10);}));return _createSendTransport.apply(this,arguments);}function produceMedia(){return _produceMedia.apply(this,arguments);}function _produceMedia(){_produceMedia=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(){var stream,track;return _regeneratorRuntime().wrap(function _callee11$(_context11){while(1)switch(_context11.prev=_context11.next){case 0:console.log("producing media");_context11.next=3;return navigator.mediaDevices.getUserMedia({video:true});case 3:stream=_context11.sent;// localVideo.srcObject = stream;
track=stream.getVideoTracks()[0];console.log(track);_context11.prev=6;console.log('before producing');_context11.next=10;return sendTransport.produce({track:track});case 10:producer=_context11.sent;console.log("produced media");_context11.next=17;break;case 14:_context11.prev=14;_context11.t0=_context11["catch"](6);console.log("error in producing media: ",_context11.t0);case 17:case"end":return _context11.stop();}},_callee11,null,[[6,14]]);}));return _produceMedia.apply(this,arguments);}var consumingTransports=[];function newConsumer(_x){return _newConsumer.apply(this,arguments);}// socket.on('newProducer',({producerId}) => {
//     console.log("inform about new producer: ",producerId);
//     newConsumer(producerId);
// })
function _newConsumer(){_newConsumer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(remoteProducerId){return _regeneratorRuntime().wrap(function _callee14$(_context14){while(1)switch(_context14.prev=_context14.next){case 0:if(!device)console.log("Device not initialized");if(!consumingTransports.includes(remoteProducerId)){_context14.next=6;break;}console.log("already consumed");return _context14.abrupt("return");case 6:console.log('pusing into consuming transports');consumingTransports.push(remoteProducerId);case 8:socket.emit('createTransport',{rtpCapabilities:device.rtpCapabilities,consumer:true},/*#__PURE__*/function(){var _ref9=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(params){return _regeneratorRuntime().wrap(function _callee13$(_context13){while(1)switch(_context13.prev=_context13.next){case 0:_context13.prev=0;_context13.next=3;return device.createRecvTransport(params);case 3:recvTransport=_context13.sent;console.log("recv transport created: ",params);recvTransport.on('connect',/*#__PURE__*/function(){var _ref11=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref10,callback,errback){var dtlsParameters;return _regeneratorRuntime().wrap(function _callee12$(_context12){while(1)switch(_context12.prev=_context12.next){case 0:dtlsParameters=_ref10.dtlsParameters;try{console.log('consumer connect');socket.emit('consumer-connect',{dtlsParameters:dtlsParameters,consumerTransportId:params.id});callback();}catch(err){console.log("Error emitting consumer-connect: ",err);errback(err);}case 2:case"end":return _context12.stop();}},_callee12);}));return function(_x13,_x14,_x15){return _ref11.apply(this,arguments);};}());recvTransport.on('connectionstatechange',function(state){console.log("Consumer ConnectionStateChange: ",state);});console.log("calling consume");console.log("remote producer id: ",remoteProducerId);_context13.next=11;return consume(remoteProducerId,params.id,recvTransport);case 11:_context13.next=16;break;case 13:_context13.prev=13;_context13.t0=_context13["catch"](0);console.log("error in recv transport: ",_context13.t0);case 16:case"end":return _context13.stop();}},_callee13,null,[[0,13]]);}));return function(_x12){return _ref9.apply(this,arguments);};}());case 9:case"end":return _context14.stop();}},_callee14);}));return _newConsumer.apply(this,arguments);}function consume(_x2,_x3,_x4){return _consume.apply(this,arguments);}function _consume(){_consume=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(remoteProducerId,consumerTransportId,recvTransport){return _regeneratorRuntime().wrap(function _callee16$(_context16){while(1)switch(_context16.prev=_context16.next){case 0:console.log("consume...");socket.emit('consume',{rtpCapabilities:device.rtpCapabilities,remoteProducerId:remoteProducerId,consumerTransportId:consumerTransportId},/*#__PURE__*/function(){var _ref12=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(params){var _consumer,track,video;return _regeneratorRuntime().wrap(function _callee15$(_context15){while(1)switch(_context15.prev=_context15.next){case 0:_context15.prev=0;console.log("before consuming");console.log('producerId: ',params.producerId);_context15.next=5;return recvTransport.consume({id:params.id,producerId:params.producerId,kind:params.kind,rtpParameters:params.rtpParameters});case 5:consumer=_context15.sent;console.log('track');// Render the remote video track into a HTML video element.
_consumer=consumer,track=_consumer.track;console.log(track);video=document.createElement('video');video.setAttribute('autoplay','true');video.setAttribute('id',"td-".concat(remoteProducerId));document.querySelector('.video').appendChild(video);document.getElementById("td-".concat(remoteProducerId)).srcObject=new MediaStream([track]);// console.log(remoteVideo.srcObject);
// remoteVideo.muted = true;
// remoteVideo.play().catch(error => console.error("Error playing video:", error));
socket.emit('resume',params.id);_context15.next=20;break;case 17:_context15.prev=17;_context15.t0=_context15["catch"](0);console.log("error consuming: ",_context15.t0);case 20:case"end":return _context15.stop();}},_callee15,null,[[0,17]]);}));return function(_x16){return _ref12.apply(this,arguments);};}());case 2:case"end":return _context16.stop();}},_callee16);}));return _consume.apply(this,arguments);}})();

/***/ }),

/***/ "./services/chatService.js":
/*!*********************************!*\
  !*** ./services/chatService.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.chatroom = chatroom;
exports.message = message;
var _mediaBundle = __webpack_require__(/*! ../dist/media.bundle.js */ "./dist/media.bundle.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } // import socketManager from './socketService.js';
function chatroom(roomId, username, socket) {
  console.log("imported room id ".concat(roomId, " and username ").concat(username));
  console.log('chatroom socket: ', socket);
  socket.emit('joinChatRoom', {
    roomId: roomId,
    name: username
  });
}
function message(_x) {
  return _message.apply(this, arguments);
}
function _message() {
  _message = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(text) {
    var socket;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          // const socket = window.socketService.getSocket();
          socket = (0, _mediaBundle.getSocket)();
          console.log('socket: ', socket);
          // if (!socket) {
          //     console.warn('Socket not initialized, queuing message');
          //     return;
          // }
          socket.once('connect', function () {
            try {
              console.log('Sending message:', text);
              socket.emit('chat', {
                content: text,
                timestamp: Date.now()
              });
            } catch (error) {
              console.error('Error sending message:', error);
            }
          });
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _message.apply(this, arguments);
}

/***/ }),

/***/ "./services/socketService.js":
/*!***********************************!*\
  !*** ./services/socketService.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createConnection = createConnection;
exports["default"] = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SocketService = /*#__PURE__*/function () {
  function SocketService() {
    _classCallCheck(this, SocketService);
    this.socket = null;
    // Add this to make the instance available globally
    window.socketService = this;
  }
  return _createClass(SocketService, [{
    key: "initialize",
    value: function initialize() {
      if (!this.socket) {
        this.socket = io('http://127.0.0.1:3000', {
          autoConnect: false
        });
      }
      return this.socket;
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.socket && !this.socket.connected) {
        this.socket.connect();
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.socket && this.socket.connected) {
        this.socket.disconnect();
      }
    }
  }, {
    key: "getSocket",
    value: function getSocket() {
      return this.socket;
    }
    // Add this method to make it easy to access from anywhere
  }], [{
    key: "getInstance",
    value: function getInstance() {
      return window.socketService;
    }
  }]);
}(); // Create and expose the instance
var socketService = new SocketService();
var _default = exports["default"] = socketService;
var currentUserId = null;
function createConnection(roomId, username) {
  console.log("room id ".concat(roomId, " and username ").concat(username));
  // this is used because server will not initiate connection automatically as we have set 
  // autoConnect: false
  if (!socket.connected) {
    socket.connect();
    // return new Promise((resolve, reject) => {
    //     socket.on('connect', () => {
    //         currentUserId = socket.id;
    //         console.log("A client connected: ",socket.id);

    //         // sendMessage(socketId,socket);
    //         resolve(socket);
    //     })
    //     socket.on('connect_error', (err) => {
    //         console.log("Socket connection error:", err);
    //         reject(err); // Reject if thereâ€™s a connection error
    //       });
    // });
  }

  // socket.on('disconnect',() => {
  //     console.log('disconnected from server');
  // })
  // socket.on('recvMessage', ({msg,userId}) => {
  //     console.log('message: ',msg);
  //     displayMessage(msg,userId,currentUserId);
  // })
}

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/h264-profile-level-id/lib/Logger.js":
/*!**********************************************************!*\
  !*** ./node_modules/h264-profile-level-id/lib/Logger.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const APP_NAME = 'h264-profile-level-id';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/h264-profile-level-id/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/h264-profile-level-id/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/h264-profile-level-id/lib/Logger.js");
const logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
// ESLint absurdly complains about "'Profile' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Profile;
(function (Profile) {
    Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
    Profile[Profile["Baseline"] = 2] = "Baseline";
    Profile[Profile["Main"] = 3] = "Main";
    Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
    Profile[Profile["High"] = 5] = "High";
    Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
// ESLint absurdly complains about "'Level' is already declared in
// the upper scope".
// eslint-disable-next-line no-shadow
var Level;
(function (Level) {
    Level[Level["L1_b"] = 0] = "L1_b";
    Level[Level["L1"] = 10] = "L1";
    Level[Level["L1_1"] = 11] = "L1_1";
    Level[Level["L1_2"] = 12] = "L1_2";
    Level[Level["L1_3"] = 13] = "L1_3";
    Level[Level["L2"] = 20] = "L2";
    Level[Level["L2_1"] = 21] = "L2_1";
    Level[Level["L2_2"] = 22] = "L2_2";
    Level[Level["L3"] = 30] = "L3";
    Level[Level["L3_1"] = 31] = "L3_1";
    Level[Level["L3_2"] = 32] = "L3_2";
    Level[Level["L4"] = 40] = "L4";
    Level[Level["L4_1"] = 41] = "L4_1";
    Level[Level["L4_2"] = 42] = "L4_2";
    Level[Level["L5"] = 50] = "L5";
    Level[Level["L5_1"] = 51] = "L5_1";
    Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
class ProfileLevelId {
    constructor(profile, level) {
        this.profile = profile;
        this.level = level;
    }
}
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
class BitPattern {
    constructor(str) {
        this.mask = ~byteMaskString('x', str);
        this.masked_value = byteMaskString('1', str);
    }
    isMatch(value) {
        return this.masked_value === (value & this.mask);
    }
}
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
class ProfilePattern {
    constructor(profile_idc, profile_iop, profile) {
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
    }
}
// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns = [
    new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x4D, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline),
    new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline),
    new ProfilePattern(0x4D, new BitPattern('0x0x0000'), Profile.Main),
    new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High),
    new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh),
    new ProfilePattern(0xF4, new BitPattern('00000000'), Profile.PredictiveHigh444)
];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
    // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
    // flag specifies if level 1b or level 1.1 is used.
    const ConstraintSet3Flag = 0x10;
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== 'string' || str.length !== 6) {
        return undefined;
    }
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) {
        return undefined;
    }
    // Separate into three bytes.
    const level_idc = (profile_level_id_numeric & 0xFF);
    const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;
    const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
    switch (level_idc) {
        case Level.L1_1:
            {
                level = (profile_iop & ConstraintSet3Flag) !== 0
                    ? Level.L1_b
                    : Level.L1_1;
                break;
            }
        case Level.L1:
        case Level.L1_2:
        case Level.L1_3:
        case Level.L2:
        case Level.L2_1:
        case Level.L2_2:
        case Level.L3:
        case Level.L3_1:
        case Level.L3_2:
        case Level.L4:
        case Level.L4_1:
        case Level.L4_2:
        case Level.L5:
        case Level.L5_1:
        case Level.L5_2:
            {
                level = level_idc;
                break;
            }
        // Unrecognized level_idc.
        default:
            {
                logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
                return undefined;
            }
    }
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns) {
        if (profile_idc === pattern.profile_idc &&
            pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
        }
    }
    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
    return undefined;
}
exports.parseProfileLevelId = parseProfileLevelId;
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level.L1_b) {
        switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline:
                {
                    return '42f00b';
                }
            case Profile.Baseline:
                {
                    return '42100b';
                }
            case Profile.Main:
                {
                    return '4d100b';
                }
            // Level 1_b is not allowed for other profiles.
            default:
                {
                    logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
                    return undefined;
                }
        }
    }
    let profile_idc_iop_string;
    switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline:
            {
                profile_idc_iop_string = '42e0';
                break;
            }
        case Profile.Baseline:
            {
                profile_idc_iop_string = '4200';
                break;
            }
        case Profile.Main:
            {
                profile_idc_iop_string = '4d00';
                break;
            }
        case Profile.ConstrainedHigh:
            {
                profile_idc_iop_string = '640c';
                break;
            }
        case Profile.High:
            {
                profile_idc_iop_string = '6400';
                break;
            }
        case Profile.PredictiveHigh444:
            {
                profile_idc_iop_string = 'f400';
                break;
            }
        default:
            {
                logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
                return undefined;
            }
    }
    let levelStr = (profile_level_id.level).toString(16);
    if (levelStr.length === 1) {
        levelStr = `0${levelStr}`;
    }
    return `${profile_idc_iop_string}${levelStr}`;
}
exports.profileLevelIdToString = profileLevelIdToString;
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
    switch (profile) {
        case Profile.ConstrainedBaseline:
            {
                return 'ConstrainedBaseline';
            }
        case Profile.Baseline:
            {
                return 'Baseline';
            }
        case Profile.Main:
            {
                return 'Main';
            }
        case Profile.ConstrainedHigh:
            {
                return 'ConstrainedHigh';
            }
        case Profile.High:
            {
                return 'High';
            }
        case Profile.PredictiveHigh444:
            {
                return 'PredictiveHigh444';
            }
        default:
            {
                logger.warn(`profileToString() | unrecognized profile ${profile}`);
                return undefined;
            }
    }
}
exports.profileToString = profileToString;
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
    switch (level) {
        case Level.L1_b:
            {
                return '1b';
            }
        case Level.L1:
            {
                return '1';
            }
        case Level.L1_1:
            {
                return '1.1';
            }
        case Level.L1_2:
            {
                return '1.2';
            }
        case Level.L1_3:
            {
                return '1.3';
            }
        case Level.L2:
            {
                return '2';
            }
        case Level.L2_1:
            {
                return '2.1';
            }
        case Level.L2_2:
            {
                return '2.2';
            }
        case Level.L3:
            {
                return '3';
            }
        case Level.L3_1:
            {
                return '3.1';
            }
        case Level.L3_2:
            {
                return '3.2';
            }
        case Level.L4:
            {
                return '4';
            }
        case Level.L4_1:
            {
                return '4.1';
            }
        case Level.L4_2:
            {
                return '4.2';
            }
        case Level.L5:
            {
                return '5';
            }
        case Level.L5_1:
            {
                return '5.1';
            }
        case Level.L5_2:
            {
                return '5.2';
            }
        default:
            {
                logger.warn(`levelToString() | unrecognized level ${level}`);
                return undefined;
            }
    }
}
exports.levelToString = levelToString;
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId(params = {}) {
    const profile_level_id = params['profile-level-id'];
    return profile_level_id
        ? parseProfileLevelId(profile_level_id)
        : DefaultProfileLevelId;
}
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 */
function isSameProfile(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 &&
        profile_level_id_2 &&
        profile_level_id_1.profile === profile_level_id_2.profile);
}
exports.isSameProfile = isSameProfile;
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (!local_supported_params['profile-level-id'] &&
        !remote_offered_params['profile-level-id']) {
        logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
        return undefined;
    }
    // Parse profile-level-ids.
    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id) {
        throw new TypeError('invalid local_profile_level_id');
    }
    if (!remote_profile_level_id) {
        throw new TypeError('invalid remote_profile_level_id');
    }
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
        throw new TypeError('H264 Profile mismatch');
    }
    // Parse level information.
    const level_asymmetry_allowed = (isLevelAsymmetryAllowed(local_supported_params) &&
        isLevelAsymmetryAllowed(remote_offered_params));
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed
        ? local_level
        : min_level;
    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
    // Return the resulting profile-level-id for the answer parameters.
    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
    return ((Number(str[0] === c) << 7) | (Number(str[1] === c) << 6) |
        (Number(str[2] === c) << 5) | (Number(str[3] === c) << 4) |
        (Number(str[4] === c) << 3) | (Number(str[5] === c) << 2) |
        (Number(str[6] === c) << 1) | (Number(str[7] === c) << 0));
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
    if (a === Level.L1_b) {
        return b !== Level.L1 && b !== Level.L1_b;
    }
    if (b === Level.L1_b) {
        return a !== Level.L1;
    }
    return a < b;
}
function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed(params = {}) {
    const level_asymmetry_allowed = params['level-asymmetry-allowed'];
    return (level_asymmetry_allowed === true ||
        level_asymmetry_allowed === 1 ||
        level_asymmetry_allowed === '1');
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Consumer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Consumer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Consumer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
const logger = new Logger_1.Logger('Consumer');
class Consumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
    }
    /**
     * Consumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
        return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
    get rtpReceiver() {
        return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Consumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses receiving media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Consumer closed');
            return;
        }
        if (this._paused) {
            logger.debug('pause() | Consumer is already paused');
            return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit('@pause');
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Consumer closed');
            return;
        }
        if (!this._paused) {
            logger.debug('resume() | Consumer is already resumed');
            return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit('@resume');
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            this._track.stop();
        }
        catch (error) { }
    }
}
exports.Consumer = Consumer;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataConsumer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataConsumer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const logger = new Logger_1.Logger('DataConsumer');
class DataConsumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataConsumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
        return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
    get binaryType() {
        return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */
    set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed) {
                return;
            }
            let { error } = event;
            if (!error) {
                error = new Error('unknown DataChannel error');
            }
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', (event) => {
            if (this._closed) {
                return;
            }
            this.safeEmit('message', event.data);
        });
    }
}
exports.DataConsumer = DataConsumer;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataProducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataProducer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataProducer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
const logger = new Logger_1.Logger('DataProducer');
class DataProducer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataChannel, sctpStreamParameters, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataProducer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
    get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
    get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    send(data) {
        logger.debug('send()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        this._dataChannel.send(data);
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed) {
                return;
            }
            let { error } = event;
            if (!error) {
                error = new Error('unknown DataChannel error');
            }
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener('bufferedamountlow', () => {
            if (this._closed) {
                return;
            }
            this.safeEmit('bufferedamountlow');
        });
    }
}
exports.DataProducer = DataProducer;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Device.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Device.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Device = void 0;
exports.detectDevice = detectDevice;
const ua_parser_js_1 = __webpack_require__(/*! ua-parser-js */ "./node_modules/ua-parser-js/src/ua-parser.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ./ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/mediasoup-client/lib/Transport.js");
const Chrome111_1 = __webpack_require__(/*! ./handlers/Chrome111 */ "./node_modules/mediasoup-client/lib/handlers/Chrome111.js");
const Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js");
const Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js");
const Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js");
const Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js");
const Firefox120_1 = __webpack_require__(/*! ./handlers/Firefox120 */ "./node_modules/mediasoup-client/lib/handlers/Firefox120.js");
const Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js");
const Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ "./node_modules/mediasoup-client/lib/handlers/Safari12.js");
const Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ "./node_modules/mediasoup-client/lib/handlers/Safari11.js");
const Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ "./node_modules/mediasoup-client/lib/handlers/Edge11.js");
const ReactNativeUnifiedPlan_1 = __webpack_require__(/*! ./handlers/ReactNativeUnifiedPlan */ "./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js");
const ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js");
const logger = new Logger_1.Logger('Device');
function detectDevice(userAgent) {
    // React-Native.
    // NOTE: react-native-webrtc >= 1.75.0 is required.
    // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
    if (!userAgent &&
        typeof navigator === 'object' &&
        navigator.product === 'ReactNative') {
        logger.debug('detectDevice() | React-Native detected');
        if (typeof RTCPeerConnection === 'undefined') {
            logger.warn('detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');
            return undefined;
        }
        if (typeof RTCRtpTransceiver !== 'undefined') {
            logger.debug('detectDevice() | ReactNative UnifiedPlan handler chosen');
            return 'ReactNativeUnifiedPlan';
        }
        else {
            logger.debug('detectDevice() | ReactNative PlanB handler chosen');
            return 'ReactNative';
        }
    }
    // Browser.
    else if (userAgent ||
        (typeof navigator === 'object' && typeof navigator.userAgent === 'string')) {
        userAgent ?? (userAgent = navigator.userAgent);
        const uaParser = new ua_parser_js_1.UAParser(userAgent);
        logger.debug('detectDevice() | browser detected [userAgent:%s, parsed:%o]', userAgent, uaParser.getResult());
        const browser = uaParser.getBrowser();
        const browserName = browser.name?.toLowerCase();
        const browserVersion = parseInt(browser.major ?? '0');
        const engine = uaParser.getEngine();
        const engineName = engine.name?.toLowerCase();
        const os = uaParser.getOS();
        const osName = os.name?.toLowerCase();
        const osVersion = parseFloat(os.version ?? '0');
        const device = uaParser.getDevice();
        const deviceModel = device.model?.toLowerCase();
        const isIOS = osName === 'ios' || deviceModel === 'ipad';
        const isChrome = browserName &&
            [
                'chrome',
                'chromium',
                'mobile chrome',
                'chrome webview',
                'chrome headless',
            ].includes(browserName);
        const isFirefox = browserName &&
            ['firefox', 'mobile firefox', 'mobile focus'].includes(browserName);
        const isSafari = browserName && ['safari', 'mobile safari'].includes(browserName);
        const isEdge = browserName && ['edge'].includes(browserName);
        // Chrome, Chromium, and Edge.
        if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return 'Chrome111';
        }
        else if ((isChrome && !isIOS && browserVersion >= 74) ||
            (isEdge && !isIOS && browserVersion >= 88)) {
            return 'Chrome74';
        }
        else if (isChrome && !isIOS && browserVersion >= 70) {
            return 'Chrome70';
        }
        else if (isChrome && !isIOS && browserVersion >= 67) {
            return 'Chrome67';
        }
        else if (isChrome && !isIOS && browserVersion >= 55) {
            return 'Chrome55';
        }
        // Firefox.
        else if (isFirefox && !isIOS && browserVersion >= 120) {
            return 'Firefox120';
        }
        else if (isFirefox && !isIOS && browserVersion >= 60) {
            return 'Firefox60';
        }
        // Firefox on iOS (so Safari).
        else if (isFirefox && isIOS && osVersion >= 14.3) {
            return 'Safari12';
        }
        // Safari with Unified-Plan support enabled.
        else if (isSafari &&
            browserVersion >= 12 &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Safari with Plab-B support.
        else if (isSafari && browserVersion >= 11) {
            return 'Safari11';
        }
        // Old Edge with ORTC support.
        else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
            return 'Edge11';
        }
        // Best effort for WebKit based browsers in iOS.
        else if (engineName === 'webkit' &&
            isIOS &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Best effort for Chromium based browsers.
        else if (engineName === 'blink') {
            // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
            const match = userAgent.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 111) {
                    return 'Chrome111';
                }
                else if (version >= 74) {
                    return 'Chrome74';
                }
                else if (version >= 70) {
                    return 'Chrome70';
                }
                else if (version >= 67) {
                    return 'Chrome67';
                }
                else {
                    return 'Chrome55';
                }
            }
            else {
                return 'Chrome111';
            }
        }
        // Unsupported browser.
        else {
            logger.warn('detectDevice() | browser not supported [name:%s, version:%s]', browserName, browserVersion);
            return undefined;
        }
    }
    // Unknown device.
    else {
        logger.warn('detectDevice() | unknown device');
        return undefined;
    }
}
class Device {
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    constructor({ handlerName, handlerFactory } = {}) {
        // Loaded flag.
        this._loaded = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        if (handlerName && handlerFactory) {
            throw new TypeError('just one of handlerName or handlerInterface can be given');
        }
        if (handlerFactory) {
            this._handlerFactory = handlerFactory;
        }
        else {
            if (handlerName) {
                logger.debug('constructor() | handler given: %s', handlerName);
            }
            else {
                handlerName = detectDevice();
                if (handlerName) {
                    logger.debug('constructor() | detected handler: %s', handlerName);
                }
                else {
                    throw new errors_1.UnsupportedError('device not supported');
                }
            }
            switch (handlerName) {
                case 'Chrome111': {
                    this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                    break;
                }
                case 'Chrome74': {
                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                    break;
                }
                case 'Chrome70': {
                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                    break;
                }
                case 'Chrome67': {
                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                    break;
                }
                case 'Chrome55': {
                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                    break;
                }
                case 'Firefox120': {
                    this._handlerFactory = Firefox120_1.Firefox120.createFactory();
                    break;
                }
                case 'Firefox60': {
                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                    break;
                }
                case 'Safari12': {
                    this._handlerFactory = Safari12_1.Safari12.createFactory();
                    break;
                }
                case 'Safari11': {
                    this._handlerFactory = Safari11_1.Safari11.createFactory();
                    break;
                }
                case 'Edge11': {
                    this._handlerFactory = Edge11_1.Edge11.createFactory();
                    break;
                }
                case 'ReactNativeUnifiedPlan': {
                    this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                    break;
                }
                case 'ReactNative': {
                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                    break;
                }
                default: {
                    throw new TypeError(`unknown handlerName "${handlerName}"`);
                }
            }
        }
        // Create a temporal handler to get its name.
        const handler = this._handlerFactory();
        this._handlerName = handler.name;
        handler.close();
        this._extendedRtpCapabilities = undefined;
        this._recvRtpCapabilities = undefined;
        this._canProduceByKind = {
            audio: false,
            video: false,
        };
        this._sctpCapabilities = undefined;
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
        return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
    get loaded() {
        return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get rtpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get sctpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._sctpCapabilities;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Initialize the Device.
     */
    async load({ routerRtpCapabilities, }) {
        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
        // Temporal handler to get its capabilities.
        let handler;
        try {
            if (this._loaded) {
                throw new errors_1.InvalidStateError('already loaded');
            }
            // Clone given router RTP capabilities to not modify input data.
            const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(clonedRouterRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
            // Clone obtained native RTP capabilities to not modify input data.
            const clonedNativeRtpCapabilities = utils.clone(nativeRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(clonedNativeRtpCapabilities);
            // Get extended RTP capabilities.
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities);
            logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
            // Check whether we can produce audio/video.
            this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities);
            // Generate our receiving RTP capabilities for receiving media.
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
            // Generate our SCTP capabilities.
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
            // This may throw.
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger.debug('load() succeeded');
            this._loaded = true;
            handler.close();
        }
        catch (error) {
            if (handler) {
                handler.close();
            }
            throw error;
        }
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    canProduce(kind) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind "${kind}"`);
        }
        return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        logger.debug('createSendTransport()');
        return this.createTransport({
            direction: 'send',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData,
        });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        logger.debug('createRecvTransport()');
        return this.createTransport({
            direction: 'recv',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData,
        });
    }
    createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, }) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof iceParameters !== 'object') {
            throw new TypeError('missing iceParameters');
        }
        else if (!Array.isArray(iceCandidates)) {
            throw new TypeError('missing iceCandidates');
        }
        else if (typeof dtlsParameters !== 'object') {
            throw new TypeError('missing dtlsParameters');
        }
        else if (sctpParameters && typeof sctpParameters !== 'object') {
            throw new TypeError('wrong sctpParameters');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Create a new Transport.
        const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind,
        });
        // Emit observer event.
        this._observer.safeEmit('newtransport', transport);
        return transport;
    }
}
exports.Device = Device;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Logger.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Logger.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const APP_NAME = 'mediasoup-client';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Producer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Producer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Producer = void 0;
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
const logger = new Logger_1.Logger('Producer');
class Producer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
        // '@replacetrack' event here, so RTCRtpSender.track won't be null.
        this.handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
    get rtpSender() {
        return this._rtpSender;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Producer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses sending media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Producer closed');
            return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@pause', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Producer closed');
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@resume', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
    async replaceTrack({ track, }) {
        logger.debug('replaceTrack() [track:%o]', track);
        if (this._closed) {
            // This must be done here. Otherwise there is no chance to stop the given
            // track.
            if (track && this._stopTracks) {
                try {
                    track.stop();
                }
                catch (error) { }
            }
            throw new errors_1.InvalidStateError('closed');
        }
        else if (track && track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        // Do nothing if this is the same track as the current handled one.
        if (track === this._track) {
            logger.debug('replaceTrack() | same track, ignored');
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@replacetrack', track, resolve, reject);
        });
        // Destroy the previous track.
        this.destroyTrack();
        // Set the new track.
        this._track = track;
        // If this Producer was paused/resumed and the state of the new
        // track does not match, fix it.
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
                this._track.enabled = true;
            }
            else if (this._paused) {
                this._track.enabled = false;
            }
        }
        // Handle the effective track.
        this.handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._kind !== 'video') {
            throw new errors_1.UnsupportedError('not a video Producer');
        }
        else if (typeof spatialLayer !== 'number') {
            throw new TypeError('invalid spatialLayer');
        }
        if (spatialLayer === this._maxSpatialLayer) {
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
        }).catch(() => { });
        this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (typeof params !== 'object') {
            throw new TypeError('invalid params');
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setrtpencodingparameters', params, resolve, reject);
        });
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        if (!this._track) {
            return;
        }
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        if (!this._track) {
            return;
        }
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            // Just stop the track unless the app set stopTracks: false.
            if (this._stopTracks) {
                this._track.stop();
            }
        }
        catch (error) { }
    }
}
exports.Producer = Producer;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/RtpParameters.js":
/*!************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/RtpParameters.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/SctpParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/SctpParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Transport.js":
/*!********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Transport.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transport = void 0;
const awaitqueue_1 = __webpack_require__(/*! awaitqueue */ "./node_modules/awaitqueue/lib/index.js");
const queue_microtask_1 = __importDefault(__webpack_require__(/*! queue-microtask */ "./node_modules/queue-microtask/index.js"));
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEvents_1 = __webpack_require__(/*! ./enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ./ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const Producer_1 = __webpack_require__(/*! ./Producer */ "./node_modules/mediasoup-client/lib/Producer.js");
const Consumer_1 = __webpack_require__(/*! ./Consumer */ "./node_modules/mediasoup-client/lib/Consumer.js");
const DataProducer_1 = __webpack_require__(/*! ./DataProducer */ "./node_modules/mediasoup-client/lib/DataProducer.js");
const DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ "./node_modules/mediasoup-client/lib/DataConsumer.js");
const logger = new Logger_1.Logger('Transport');
class ConsumerCreationTask {
    constructor(consumerOptions) {
        this.consumerOptions = consumerOptions;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
class Transport extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind, }) {
        super();
        // Closed flag.
        this._closed = false;
        // Transport ICE gathering state.
        this._iceGatheringState = 'new';
        // Transport connection state.
        this._connectionState = 'new';
        // Map of Producers indexed by id.
        this._producers = new Map();
        // Map of Consumers indexed by id.
        this._consumers = new Map();
        // Map of DataProducers indexed by id.
        this._dataProducers = new Map();
        // Map of DataConsumers indexed by id.
        this._dataConsumers = new Map();
        // Whether the Consumer for RTP probation has been created.
        this._probatorConsumerCreated = false;
        // AwaitQueue instance to make async tasks happen sequentially.
        this._awaitQueue = new awaitqueue_1.AwaitQueue();
        // Consumer creation tasks awaiting to be processed.
        this._pendingConsumerTasks = [];
        // Consumer creation in progress flag.
        this._consumerCreationInProgress = false;
        // Consumers pending to be paused.
        this._pendingPauseConsumers = new Map();
        // Consumer pause in progress flag.
        this._consumerPauseInProgress = false;
        // Consumers pending to be resumed.
        this._pendingResumeConsumers = new Map();
        // Consumer resume in progress flag.
        this._consumerResumeInProgress = false;
        // Consumers pending to be closed.
        this._pendingCloseConsumers = new Map();
        // Consumer close in progress flag.
        this._consumerCloseInProgress = false;
        // Observer instance.
        this._observer = new enhancedEvents_1.EnhancedEventEmitter();
        logger.debug('constructor() [id:%s, direction:%s]', id, direction);
        this._id = id;
        this._direction = direction;
        this._extendedRtpCapabilities = extendedRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize = sctpParameters
            ? sctpParameters.maxMessageSize
            : null;
        // Clone and sanitize additionalSettings.
        const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
        delete clonedAdditionalSettings.iceServers;
        delete clonedAdditionalSettings.iceTransportPolicy;
        delete clonedAdditionalSettings.bundlePolicy;
        delete clonedAdditionalSettings.rtcpMuxPolicy;
        delete clonedAdditionalSettings.sdpSemantics;
        this._handler = handlerFactory();
        this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings: clonedAdditionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
        });
        this._appData = appData ?? {};
        this.handleHandler();
    }
    /**
     * Transport id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Transport direction.
     */
    get direction() {
        return this._direction;
    }
    /**
     * RTC handler instance.
     */
    get handler() {
        return this._handler;
    }
    /**
     * ICE gathering state.
     */
    get iceGatheringState() {
        return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
    get connectionState() {
        return this._connectionState;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Close the Transport.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        // Stop the AwaitQueue.
        this._awaitQueue.stop();
        // Close the handler.
        this._handler.close();
        // Change connection state to 'closed' since the handler may not emit
        // '@connectionstatechange' event.
        this._connectionState = 'closed';
        // Close all Producers.
        for (const producer of this._producers.values()) {
            producer.transportClosed();
        }
        this._producers.clear();
        // Close all Consumers.
        for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
        }
        this._consumers.clear();
        // Close all DataProducers.
        for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
        }
        this._dataProducers.clear();
        // Close all DataConsumers.
        for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this._dataConsumers.clear();
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */
    async restartIce({ iceParameters, }) {
        logger.debug('restartIce()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!iceParameters) {
            throw new TypeError('missing iceParameters');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');
    }
    /**
     * Update ICE servers.
     */
    async updateIceServers({ iceServers, } = {}) {
        logger.debug('updateIceServers()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!Array.isArray(iceServers)) {
            throw new TypeError('missing iceServers');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');
    }
    /**
     * Create a Producer.
     */
    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {}, } = {}) {
        logger.debug('produce() [track:%o]', track);
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!track) {
            throw new TypeError('missing track');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        }
        else if (track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('produce') === 0) {
            throw new TypeError('no "produce" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Enqueue command.
        return (this._awaitQueue
            .push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
                throw TypeError('encodings must be an array');
            }
            else if (encodings && encodings.length === 0) {
                normalizedEncodings = undefined;
            }
            else if (encodings) {
                normalizedEncodings = encodings.map((encoding) => {
                    const normalizedEncoding = { active: true };
                    if (encoding.active === false) {
                        normalizedEncoding.active = false;
                    }
                    if (typeof encoding.dtx === 'boolean') {
                        normalizedEncoding.dtx = encoding.dtx;
                    }
                    if (typeof encoding.scalabilityMode === 'string') {
                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                    }
                    if (typeof encoding.scaleResolutionDownBy === 'number') {
                        normalizedEncoding.scaleResolutionDownBy =
                            encoding.scaleResolutionDownBy;
                    }
                    if (typeof encoding.maxBitrate === 'number') {
                        normalizedEncoding.maxBitrate = encoding.maxBitrate;
                    }
                    if (typeof encoding.maxFramerate === 'number') {
                        normalizedEncoding.maxFramerate = encoding.maxFramerate;
                    }
                    if (typeof encoding.adaptivePtime === 'boolean') {
                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                    }
                    if (typeof encoding.priority === 'string') {
                        normalizedEncoding.priority = encoding.priority;
                    }
                    if (typeof encoding.networkPriority === 'string') {
                        normalizedEncoding.networkPriority = encoding.networkPriority;
                    }
                    return normalizedEncoding;
                });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
                track,
                encodings: normalizedEncodings,
                codecOptions,
                codec,
                onRtpSender,
            });
            try {
                // This will fill rtpParameters's missing fields with default values.
                ortc.validateRtpParameters(rtpParameters);
                const { id } = await new Promise((resolve, reject) => {
                    this.safeEmit('produce', {
                        kind: track.kind,
                        rtpParameters,
                        appData,
                    }, resolve, reject);
                });
                const producer = new Producer_1.Producer({
                    id,
                    localId,
                    rtpSender,
                    track,
                    rtpParameters,
                    stopTracks,
                    disableTrackOnPause,
                    zeroRtpOnPause,
                    appData,
                });
                this._producers.set(producer.id, producer);
                this.handleProducer(producer);
                // Emit observer event.
                this._observer.safeEmit('newproducer', producer);
                return producer;
            }
            catch (error) {
                this._handler.stopSending(localId).catch(() => { });
                throw error;
            }
        }, 'transport.produce()')
            // This catch is needed to stop the given track if the command above
            // failed due to closed Transport.
            .catch((error) => {
            if (stopTracks) {
                try {
                    track.stop();
                }
                catch (error2) { }
            }
            throw error;
        }));
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */
    async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {}, }) {
        logger.debug('consume()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind '${kind}'`);
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given RTP parameters to not modify input data.
        const clonedRtpParameters = utils.clone(rtpParameters);
        // Ensure the device can consume it.
        const canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);
        if (!canConsume) {
            throw new errors_1.UnsupportedError('cannot consume this Producer');
        }
        const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters: clonedRtpParameters,
            streamId,
            onRtpReceiver,
            appData,
        });
        // Store the Consumer creation task.
        this._pendingConsumerTasks.push(consumerCreationTask);
        // There is no Consumer creation in progress, create it now.
        (0, queue_microtask_1.default)(() => {
            if (this._closed) {
                return;
            }
            if (this._consumerCreationInProgress === false) {
                void this.createPendingConsumers();
            }
        });
        return consumerCreationTask.promise;
    }
    /**
     * Create a DataProducer
     */
    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {}, } = {}) {
        logger.debug('produceData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('producedata') === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                ordered,
                maxPacketLifeTime,
                maxRetransmits,
                label,
                protocol,
            });
            // This will fill sctpStreamParameters's missing fields with default values.
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
                this.safeEmit('producedata', {
                    sctpStreamParameters,
                    label,
                    protocol,
                    appData,
                }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
                id,
                dataChannel,
                sctpStreamParameters,
                appData,
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            // Emit observer event.
            this._observer.safeEmit('newdataproducer', dataProducer);
            return dataProducer;
        }, 'transport.produceData()');
    }
    /**
     * Create a DataConsumer
     */
    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {}, }) {
        logger.debug('consumeData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof dataProducerId !== 'string') {
            throw new TypeError('missing dataProducerId');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given SCTP stream parameters to not modify input data.
        const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
        // This may throw.
        ortc.validateSctpStreamParameters(clonedSctpStreamParameters);
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
                sctpStreamParameters: clonedSctpStreamParameters,
                label,
                protocol,
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters: clonedSctpStreamParameters,
                appData,
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            // Emit observer event.
            this._observer.safeEmit('newdataconsumer', dataConsumer);
            return dataConsumer;
        }, 'transport.consumeData()');
    }
    // This method is guaranteed to never throw.
    async createPendingConsumers() {
        this._consumerCreationInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
                logger.debug('createPendingConsumers() | there is no Consumer to be created');
                return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            // Clear pending Consumer tasks.
            this._pendingConsumerTasks = [];
            // Video Consumer in order to create the probator.
            let videoConsumerForProbator = undefined;
            // Fill options list.
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
                const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
                optionsList.push({
                    trackId: id,
                    kind: kind,
                    rtpParameters,
                    streamId,
                    onRtpReceiver,
                });
            }
            try {
                const results = await this._handler.receive(optionsList);
                for (let idx = 0; idx < results.length; ++idx) {
                    const task = pendingConsumerTasks[idx];
                    const result = results[idx];
                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                    const { localId, rtpReceiver, track } = result;
                    const consumer = new Consumer_1.Consumer({
                        id: id,
                        localId,
                        producerId: producerId,
                        rtpReceiver,
                        track,
                        rtpParameters,
                        appData: appData,
                    });
                    this._consumers.set(consumer.id, consumer);
                    this.handleConsumer(consumer);
                    // If this is the first video Consumer and the Consumer for RTP probation
                    // has not yet been created, it's time to create it.
                    if (!this._probatorConsumerCreated &&
                        !videoConsumerForProbator &&
                        kind === 'video') {
                        videoConsumerForProbator = consumer;
                    }
                    // Emit observer event.
                    this._observer.safeEmit('newconsumer', consumer);
                    task.resolve(consumer);
                }
            }
            catch (error) {
                for (const task of pendingConsumerTasks) {
                    task.reject(error);
                }
            }
            // If RTP probation must be handled, do it now.
            if (videoConsumerForProbator) {
                try {
                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                    await this._handler.receive([
                        {
                            trackId: 'probator',
                            kind: 'video',
                            rtpParameters: probatorRtpParameters,
                        },
                    ]);
                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');
                    this._probatorConsumerCreated = true;
                }
                catch (error) {
                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);
                }
            }
        }, 'transport.createPendingConsumers()')
            .then(() => {
            this._consumerCreationInProgress = false;
            // There are pending Consumer tasks, enqueue their creation.
            if (this._pendingConsumerTasks.length > 0) {
                void this.createPendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    pausePendingConsumers() {
        this._consumerPauseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
                return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            // Clear pending pause Consumer map.
            this._pendingPauseConsumers.clear();
            try {
                const localIds = pendingPauseConsumers.map(consumer => consumer.localId);
                await this._handler.pauseReceiving(localIds);
            }
            catch (error) {
                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);
            }
        }, 'transport.pausePendingConsumers')
            .then(() => {
            this._consumerPauseInProgress = false;
            // There are pending Consumers to be paused, do it.
            if (this._pendingPauseConsumers.size > 0) {
                this.pausePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    resumePendingConsumers() {
        this._consumerResumeInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
                return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            // Clear pending resume Consumer map.
            this._pendingResumeConsumers.clear();
            try {
                const localIds = pendingResumeConsumers.map(consumer => consumer.localId);
                await this._handler.resumeReceiving(localIds);
            }
            catch (error) {
                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);
            }
        }, 'transport.resumePendingConsumers')
            .then(() => {
            this._consumerResumeInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingResumeConsumers.size > 0) {
                this.resumePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    closePendingConsumers() {
        this._consumerCloseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
                logger.debug('closePendingConsumers() | there is no Consumer to be closed');
                return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            // Clear pending close Consumer map.
            this._pendingCloseConsumers.clear();
            try {
                await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));
            }
            catch (error) {
                logger.error('closePendingConsumers() | failed to close Consumers:', error);
            }
        }, 'transport.closePendingConsumers')
            .then(() => {
            this._consumerCloseInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingCloseConsumers.size > 0) {
                this.closePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    handleHandler() {
        const handler = this._handler;
        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
                errback(new errors_1.InvalidStateError('closed'));
                return;
            }
            this.safeEmit('connect', { dtlsParameters }, callback, errback);
        });
        handler.on('@icegatheringstatechange', (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
                return;
            }
            logger.debug('ICE gathering state changed to %s', iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
                this.safeEmit('icegatheringstatechange', iceGatheringState);
            }
        });
        handler.on('@connectionstatechange', (connectionState) => {
            if (connectionState === this._connectionState) {
                return;
            }
            logger.debug('connection state changed to %s', connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
                this.safeEmit('connectionstatechange', connectionState);
            }
        });
    }
    handleProducer(producer) {
        producer.on('@close', () => {
            this._producers.delete(producer.id);
            if (this._closed) {
                return;
            }
            this._awaitQueue
                .push(async () => await this._handler.stopSending(producer.localId), 'producer @close event')
                .catch((error) => logger.warn('producer.close() failed:%o', error));
        });
        producer.on('@pause', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@resume', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@replacetrack', (track, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setrtpencodingparameters', (params, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getSenderStats(producer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleConsumer(consumer) {
        consumer.on('@close', () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
                return;
            }
            // Store the Consumer into the close list.
            this._pendingCloseConsumers.set(consumer.id, consumer);
            // There is no Consumer close in progress, do it now.
            if (this._consumerCloseInProgress === false) {
                this.closePendingConsumers();
            }
        });
        consumer.on('@pause', () => {
            // If Consumer is pending to be resumed, remove from pending resume list.
            if (this._pendingResumeConsumers.has(consumer.id)) {
                this._pendingResumeConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingPauseConsumers.set(consumer.id, consumer);
            // There is no Consumer pause in progress, do it now.
            (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerPauseInProgress === false) {
                    this.pausePendingConsumers();
                }
            });
        });
        consumer.on('@resume', () => {
            // If Consumer is pending to be paused, remove from pending pause list.
            if (this._pendingPauseConsumers.has(consumer.id)) {
                this._pendingPauseConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingResumeConsumers.set(consumer.id, consumer);
            // There is no Consumer resume in progress, do it now.
            (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerResumeInProgress === false) {
                    this.resumePendingConsumers();
                }
            });
        });
        consumer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getReceiverStats(consumer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleDataProducer(dataProducer) {
        dataProducer.on('@close', () => {
            this._dataProducers.delete(dataProducer.id);
        });
    }
    handleDataConsumer(dataConsumer) {
        dataConsumer.on('@close', () => {
            this._dataConsumers.delete(dataConsumer.id);
        });
    }
}
exports.Transport = Transport;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/enhancedEvents.js":
/*!*************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/enhancedEvents.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancedEventEmitter = void 0;
const npm_events_package_1 = __webpack_require__(/*! npm-events-package */ "./node_modules/npm-events-package/events.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const enhancedEventEmitterLogger = new Logger_1.Logger('EnhancedEventEmitter');
class EnhancedEventEmitter extends npm_events_package_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(Infinity);
    }
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */
    safeEmit(eventName, ...args) {
        try {
            return super.emit(eventName, ...args);
        }
        catch (error) {
            enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
            try {
                super.emit('listenererror', eventName, error);
            }
            catch (error2) {
                // Ignore it.
            }
            return Boolean(super.listenerCount(eventName));
        }
    }
    on(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        super.once(eventName, listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
    }
    removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
    }
    listenerCount(eventName) {
        return super.listenerCount(eventName);
    }
    listeners(eventName) {
        return super.listeners(eventName);
    }
    rawListeners(eventName) {
        return super.rawListeners(eventName);
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
class UnsupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnsupportedError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            Error.captureStackTrace(this, UnsupportedError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
class InvalidStateError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidStateError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            // Just in V8.
            Error.captureStackTrace(this, InvalidStateError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.InvalidStateError = InvalidStateError;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome111.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome111.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome111 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ "./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Chrome111');
const NAME = 'Chrome111';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome111 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome111();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', () => {
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            // Set rid and verify scalabilityMode in each encoding.
            // NOTE: Even if WebRTC allows different scalabilityMode (different number
            // of temporal layers) per simulcast stream, we need that those are the
            // same in all them, so let's pick up the highest value.
            // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
                const temporalLayers = encoding.scalabilityMode
                    ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers
                    : 3;
                if (temporalLayers > maxTemporalLayers) {
                    maxTemporalLayers = temporalLayers;
                }
            }
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome111 = Chrome111;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome55 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const logger = new Logger_1.Logger('Chrome55');
const NAME = 'Chrome55';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome55 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome55();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) {
            throw new Error('track not found');
        }
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async setMaxSpatialLayer(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    spatialLayer) {
        throw new errors_1.UnsupportedError(' not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId ?? rtpParameters.rtcp.cname;
            const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
                throw new Error('remote track not found');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome55 = Chrome55;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome67 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const logger = new Logger_1.Logger('Chrome67');
const NAME = 'Chrome67';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome67 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome67();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc
            .getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        this._pc.removeTrack(rtpSender);
        if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
        }
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
        }
        // Add the new track to the local stream.
        if (track) {
            this._sendStream.addTrack(track);
        }
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
                throw new Error('new RTCRtpReceiver not');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
        if (!rtpReceiver) {
            throw new Error('associated RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome67 = Chrome67;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome70 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Chrome70');
const NAME = 'Chrome70';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome70 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome70();
    }
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // If encodings are given, apply them now.
        if (encodings) {
            logger.debug('send() | applying given encodings');
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings ?? []).length; ++idx) {
                const encoding = parameters.encodings[idx];
                const desiredEncoding = encodings[idx];
                // Should not happen but just in case.
                if (!desiredEncoding) {
                    break;
                }
                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
        }
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // Hack for VP9 SVC.
        if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome70 = Chrome70;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome74 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ "./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Chrome74');
const NAME = 'Chrome74';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome74 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome74();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', () => {
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome74 = Chrome74;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Edge11.js":
/*!**************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Edge11 = void 0;
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const edgeUtils = __importStar(__webpack_require__(/*! ./ortc/edgeUtils */ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const logger = new Logger_1.Logger('Edge11');
const NAME = 'Edge11';
class Edge11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Edge11();
    }
    constructor() {
        super();
        // Map of RTCRtpSenders indexed by id.
        this._rtpSenders = new Map();
        // Map of RTCRtpReceivers indexed by id.
        this._rtpReceivers = new Map();
        // Next localId for sending tracks.
        this._nextSendLocalId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close the ICE gatherer.
        // NOTE: Not yet implemented by Edge.
        try {
            this._iceGatherer.close();
        }
        catch (error) { }
        // Close the ICE transport.
        try {
            this._iceTransport.stop();
        }
        catch (error) { }
        // Close the DTLS transport.
        try {
            this._dtlsTransport.stop();
        }
        catch (error) { }
        // Close RTCRtpSenders.
        for (const rtpSender of this._rtpSenders.values()) {
            try {
                rtpSender.stop();
            }
            catch (error) { }
        }
        // Close RTCRtpReceivers.
        for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
                rtpReceiver.stop();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        return edgeUtils.getCapabilities();
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: { OS: 0, MIS: 0 },
        };
    }
    run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars
    proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars
    extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._remoteIceParameters = iceParameters;
        this._remoteIceCandidates = iceCandidates;
        this._remoteDtlsParameters = dtlsParameters;
        this._cname = `CNAME-${utils.generateRandomNumber()}`;
        this.setIceGatherer({ iceServers, iceTransportPolicy });
        this.setIceTransport();
        this.setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Edge 11 does not implement iceGatherer.gater().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        this._remoteIceParameters = iceParameters;
        if (!this._transportReady) {
            return;
        }
        logger.debug('restartIce() | calling iceTransport.start()');
        this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        this._iceTransport.addRemoteCandidate({});
    }
    async getTransportStats() {
        return this._iceTransport.getStats();
    }
    async send(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    { track, encodings, codecOptions, codec }) {
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        logger.debug('send() | calling new RTCRtpSender()');
        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
        const useRtx = rtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
        if (!encodings) {
            encodings = [{}];
        }
        for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
                encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
        }
        rtpParameters.encodings = encodings;
        // Fill RTCRtpParameters.rtcp.
        rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true,
        };
        // NOTE: Convert our standard RTCRtpParameters into those that Edge
        // expects.
        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
        logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
        await rtpSender.send(edgeRtpParameters);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Store it.
        this._rtpSenders.set(localId, rtpSender);
        return { localId, rtpParameters, rtpSender };
    }
    async stopSending(localId) {
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        this._rtpSenders.delete(localId);
        try {
            logger.debug('stopSending() | calling rtpSender.stop()');
            rtpSender.stop();
        }
        catch (error) {
            logger.warn('stopSending() | rtpSender.stop() failed:%o', error);
            throw error;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        rtpSender.setTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) {
            throw new Error('RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receive(optionsList) {
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger.debug('receive() | calling new RTCRtpReceiver()');
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener('error', (event) => {
                logger.error('rtpReceiver "error" event [event:%o]', event);
            });
            // NOTE: Convert our standard RTCRtpParameters into those that Edge
            // expects.
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            // Store it.
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
                throw new Error('RTCRtpReceiver not found');
            }
            this._rtpReceivers.delete(localId);
            try {
                logger.debug('stopReceiving() | calling rtpReceiver.stop()');
                rtpReceiver.stop();
            }
            catch (error) {
                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
            }
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        const rtpReceiver = this._rtpReceivers.get(localId);
        if (!rtpReceiver) {
            throw new Error('RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async receiveDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    setIceGatherer({ iceServers, iceTransportPolicy, }) {
        // @ts-expect-error --- On purpose
        const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers ?? [],
            gatherPolicy: iceTransportPolicy ?? 'all',
        });
        iceGatherer.addEventListener('error', (event) => {
            logger.error('iceGatherer "error" event [event:%o]', event);
        });
        // NOTE: Not yet implemented by Edge, which starts gathering automatically.
        try {
            iceGatherer.gather();
        }
        catch (error) {
            logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
        }
        this._iceGatherer = iceGatherer;
    }
    setIceTransport() {
        const iceTransport = new RTCIceTransport(this._iceGatherer);
        // NOTE: Not yet implemented by Edge.
        iceTransport.addEventListener('statechange', () => {
            switch (iceTransport.state) {
                case 'checking': {
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                }
                case 'connected':
                case 'completed': {
                    this.emit('@connectionstatechange', 'connected');
                    break;
                }
                case 'failed': {
                    this.emit('@connectionstatechange', 'failed');
                    break;
                }
                case 'disconnected': {
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                }
                case 'closed': {
                    this.emit('@connectionstatechange', 'closed');
                    break;
                }
            }
        });
        // NOTE: Not standard, but implemented by Edge.
        iceTransport.addEventListener('icestatechange', () => {
            switch (iceTransport.state) {
                case 'checking': {
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                }
                case 'connected':
                case 'completed': {
                    this.emit('@connectionstatechange', 'connected');
                    break;
                }
                case 'failed': {
                    this.emit('@connectionstatechange', 'failed');
                    break;
                }
                case 'disconnected': {
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                }
                case 'closed': {
                    this.emit('@connectionstatechange', 'closed');
                    break;
                }
            }
        });
        iceTransport.addEventListener('candidatepairchange', (event) => {
            logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
        });
        this._iceTransport = iceTransport;
    }
    setDtlsTransport() {
        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
        // NOTE: Not yet implemented by Edge.
        dtlsTransport.addEventListener('statechange', () => {
            logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
        });
        // NOTE: Not standard, but implemented by Edge.
        dtlsTransport.addEventListener('dtlsstatechange', () => {
            logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === 'closed') {
                this.emit('@connectionstatechange', 'closed');
            }
        });
        dtlsTransport.addEventListener('error', (event) => {
            logger.error('dtlsTransport "error" event [event:%o]', event);
        });
        this._dtlsTransport = dtlsTransport;
    }
    async setupTransport({ localDtlsRole, }) {
        logger.debug('setupTransport()');
        // Get our local DTLS parameters.
        const dtlsParameters = this._dtlsTransport.getLocalParameters();
        dtlsParameters.role = localDtlsRole;
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        // Start the RTCIceTransport.
        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
        // Add remote ICE candidates.
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        // Also signal a 'complete' candidate as per spec.
        // NOTE: It should be {complete: true} but Edge prefers {}.
        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
        // won't enter the 'completed' state.
        this._iceTransport.addRemoteCandidate({});
        // NOTE: Edge does not like SHA less than 256.
        this._remoteDtlsParameters.fingerprints =
            this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
                return (fingerprint.algorithm === 'sha-256' ||
                    fingerprint.algorithm === 'sha-384' ||
                    fingerprint.algorithm === 'sha-512');
            });
        // Start the RTCDtlsTransport.
        this._dtlsTransport.start(this._remoteDtlsParameters);
        this._transportReady = true;
    }
}
exports.Edge11 = Edge11;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Firefox120.js":
/*!******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox120.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Firefox120 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Firefox120');
const NAME = 'Firefox120';
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox120 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Firefox120();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        // NOTE: We need to add a real video track to get the RID extension mapping,
        // otherwiser Firefox doesn't include it in the SDP.
        const canvas = document.createElement('canvas');
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext('2d');
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv',
                sendEncodings: [
                    { rid: 'r0', maxBitrate: 100000 },
                    { rid: 'r1', maxBitrate: 500000 },
                ],
            });
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            }
            catch (error) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error) { }
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                canvas.remove();
            }
            catch (error2) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error2) { }
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox120 = Firefox120;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Firefox60 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Firefox60');
const NAME = 'Firefox60';
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox60 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Firefox60();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        // NOTE: We need to add a real video track to get the RID extension mapping.
        const canvas = document.createElement('canvas');
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext('2d');
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv',
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
                { rid: 'r0', maxBitrate: 100000 },
                { rid: 'r1', maxBitrate: 500000 },
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            }
            catch (error) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error) { }
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                canvas.remove();
            }
            catch (error2) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error2) { }
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings) {
            encodings = utils.clone(encodings);
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
            // Clone the encodings and reverse them because Firefox likes them
            // from high to low.
            encodings.reverse();
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
        // second argument, but Firefox does not support it.
        if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim (but
        // reverse them back since we reversed them above to satisfy Firefox).
        else {
            sendingRtpParameters.encodings = encodings.reverse();
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        // NOTE: We require encodings given from low to high, however Firefox
        // requires them in reverse order, so do magic here.
        spatialLayer = parameters.encodings.length - 1 - spatialLayer;
        parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox60 = Firefox60;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerInterface = void 0;
const enhancedEvents_1 = __webpack_require__(/*! ../enhancedEvents */ "./node_modules/mediasoup-client/lib/enhancedEvents.js");
class HandlerInterface extends enhancedEvents_1.EnhancedEventEmitter {
    constructor() {
        super();
    }
}
exports.HandlerInterface = HandlerInterface;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReactNative = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const logger = new Logger_1.Logger('ReactNative');
const NAME = 'ReactNative';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNative extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new ReactNative();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-expect-error --- Proprietary API in react-native-webrtc.
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) {
            throw new Error('track not found');
        }
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async setMaxSpatialLayer(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    spatialLayer) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        const mapStreamId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            let streamId = options.streamId ?? rtpParameters.rtcp.cname;
            // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
            // remote tracks. This is because react-native-webrtc does not react on new
            // tracks generated within already existing streams, so force the streamId
            // to be different. See:
            // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
                throw new Error('remote track not found');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNative = ReactNative;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReactNativeUnifiedPlan = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ "./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('ReactNativeUnifiedPlan');
const NAME = 'ReactNativeUnifiedPlan';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new ReactNativeUnifiedPlan();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-expect-error --- Proprietary API in react-native-webrtc.
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
        // because transceiver.mid is not available until setRemoteDescription()
        // is called, so this is best effort.
        // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
        // NOTE: So let's fill MID in sendingRtpParameters later.
        // NOTE: This is fixed in react-native-webrtc 111.0.3.
        let localId = transceiver.mid ?? undefined;
        if (!localId) {
            logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');
        }
        // Set MID.
        // NOTE: As per above, it could be unset yet.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
        // we can read generated MID (if not done above) and fill sendingRtpParameters.
        // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
        // needed starting from that version.
        if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
        }
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari11.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safari11 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const logger = new Logger_1.Logger('Safari11');
const NAME = 'Safari11';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari11();
    }
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'L1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc
            .getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
        }
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable') {
            return;
        }
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
        }
        // Add the new track to the local stream.
        if (track) {
            this._sendStream.addTrack(track);
        }
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) {
            throw new Error('associated RTCRtpSender not found');
        }
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
                throw new Error('new RTCRtpReceiver not');
            }
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
        if (!rtpReceiver) {
            throw new Error('associated RTCRtpReceiver not found');
        }
        return rtpReceiver.getStats();
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        // Unimplemented.
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari11 = Safari11;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari12.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safari12 = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
const sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
const sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
const ortcUtils = __importStar(__webpack_require__(/*! ./ortc/utils */ "./node_modules/mediasoup-client/lib/handlers/ortc/utils.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
const HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
const RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
const scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
const logger = new Logger_1.Logger('Safari12');
const NAME = 'Safari12';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari12 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari12();
    }
    constructor() {
        super();
        // Closed flag.
        this._closed = false;
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
        this.emit('@close');
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject,
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS,
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities, }) {
        this.assertNotClosed();
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities),
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities),
        };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        }, proprietaryConstraints);
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', () => {
                this.emit('@connectionstatechange', this._pc.connectionState);
            });
        }
        else {
            this._pc.addEventListener('iceconnectionstatechange', () => {
                logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
                switch (this._pc.iceConnectionState) {
                    case 'checking': {
                        this.emit('@connectionstatechange', 'connecting');
                        break;
                    }
                    case 'connected':
                    case 'completed': {
                        this.emit('@connectionstatechange', 'connected');
                        break;
                    }
                    case 'failed': {
                        this.emit('@connectionstatechange', 'failed');
                        break;
                    }
                    case 'disconnected': {
                        this.emit('@connectionstatechange', 'disconnected');
                        break;
                    }
                    case 'closed': {
                        this.emit('@connectionstatechange', 'closed');
                        break;
                    }
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari12 = Safari12;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCapabilities = getCapabilities;
exports.mangleRtpParameters = mangleRtpParameters;
const utils = __importStar(__webpack_require__(/*! ../../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */
function getCapabilities() {
    const nativeCaps = RTCRtpReceiver.getCapabilities();
    const caps = utils.clone(nativeCaps);
    for (const codec of caps.codecs ?? []) {
        // Rename numChannels to channels.
        // @ts-expect-error --- On purpose.
        codec.channels = codec.numChannels;
        // @ts-expect-error --- On purpose.
        delete codec.numChannels;
        // Add mimeType.
        // @ts-expect-error --- On purpose (due to codec.name).
        codec.mimeType = codec.mimeType ?? `${codec.kind}/${codec.name}`;
        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
        if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) {
                parameters.apt = Number(parameters.apt);
            }
            if (parameters['packetization-mode']) {
                parameters['packetization-mode'] = Number(parameters['packetization-mode']);
            }
        }
        // Delete emty parameter String in rtcpFeedback.
        for (const feedback of codec.rtcpFeedback ?? []) {
            if (!feedback.parameter) {
                feedback.parameter = '';
            }
        }
    }
    return caps;
}
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */
function mangleRtpParameters(rtpParameters) {
    const params = utils.clone(rtpParameters);
    // Rename mid to muxId.
    if (params.mid) {
        // @ts-expect-error --- On purpose (due to muxId).
        params.muxId = params.mid;
        delete params.mid;
    }
    for (const codec of params.codecs) {
        // Rename channels to numChannels.
        if (codec.channels) {
            // @ts-expect-error --- On purpose.
            codec.numChannels = codec.channels;
            delete codec.channels;
        }
        // Add codec.name (requried by Edge).
        // @ts-expect-error --- On purpose (due to name).
        if (codec.mimeType && !codec.name) {
            // @ts-expect-error --- On purpose (due to name).
            codec.name = codec.mimeType.split('/')[1];
        }
        // Remove mimeType.
        // @ts-expect-error --- On purpose.
        delete codec.mimeType;
    }
    return params;
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ortc/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addNackSuppportForOpus = addNackSuppportForOpus;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */
function addNackSuppportForOpus(rtpCapabilities) {
    for (const codec of rtpCapabilities.codecs ?? []) {
        if ((codec.mimeType.toLowerCase() === 'audio/opus' ||
            codec.mimeType.toLowerCase() === 'audio/multiopus') &&
            !codec.rtcpFeedback?.some(fb => fb.type === 'nack' && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
                codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: 'nack' });
        }
    }
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const utils = __importStar(__webpack_require__(/*! ../../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
class MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false, }) {
        this._mediaObject = {};
        this._planB = planB;
        if (iceParameters) {
            this.setIceParameters(iceParameters);
        }
        if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
                const candidateObject = {};
                // mediasoup does mandates rtcp-mux so candidates component is always
                // RTP (1).
                candidateObject.component = 1;
                candidateObject.foundation = candidate.foundation;
                // Be ready for new candidate.address field in mediasoup server side
                // field and keep backward compatibility with deprecated candidate.ip.
                candidateObject.ip = candidate.address ?? candidate.ip;
                candidateObject.port = candidate.port;
                candidateObject.priority = candidate.priority;
                candidateObject.transport = candidate.protocol;
                candidateObject.type = candidate.type;
                if (candidate.tcpType) {
                    candidateObject.tcptype = candidate.tcpType;
                }
                this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = 'end-of-candidates';
            this._mediaObject.iceOptions = 'renomination';
        }
        if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
        }
    }
    get mid() {
        return String(this._mediaObject.mid);
    }
    get closed() {
        return this._mediaObject.port === 0;
    }
    getObject() {
        return this._mediaObject;
    }
    setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
    }
    pause() {
        this._mediaObject.direction = 'inactive';
    }
    disable() {
        this.pause();
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
    }
    close() {
        this.disable();
        this._mediaObject.port = 0;
    }
}
exports.MediaSection = MediaSection;
class AnswerMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (offerMediaObject.type) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'recvonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                for (const codec of answerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const codecParameters = utils.clone(codec.parameters) ?? {};
                    let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                    if (codecOptions) {
                        const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate, } = codecOptions;
                        const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                        switch (codec.mimeType.toLowerCase()) {
                            case 'audio/opus':
                            case 'audio/multiopus': {
                                if (opusStereo !== undefined) {
                                    offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                                    codecParameters.stereo = opusStereo ? 1 : 0;
                                }
                                if (opusFec !== undefined) {
                                    offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                                    codecParameters.useinbandfec = opusFec ? 1 : 0;
                                }
                                if (opusDtx !== undefined) {
                                    offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                                    codecParameters.usedtx = opusDtx ? 1 : 0;
                                }
                                if (opusMaxPlaybackRate !== undefined) {
                                    codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                                }
                                if (opusMaxAverageBitrate !== undefined) {
                                    codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                                }
                                if (opusPtime !== undefined) {
                                    offerCodec.parameters.ptime = opusPtime;
                                    codecParameters.ptime = opusPtime;
                                }
                                // If opusNack is not set, we must remove NACK support for OPUS.
                                // Otherwise it would be enabled for those handlers that artificially
                                // announce it in their RTP capabilities.
                                if (!opusNack) {
                                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                    codecRtcpFeedback = codecRtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                }
                                break;
                            }
                            case 'video/vp8':
                            case 'video/vp9':
                            case 'video/h264':
                            case 'video/h265': {
                                if (videoGoogleStartBitrate !== undefined) {
                                    codecParameters['x-google-start-bitrate'] =
                                        videoGoogleStartBitrate;
                                }
                                if (videoGoogleMaxBitrate !== undefined) {
                                    codecParameters['x-google-max-bitrate'] =
                                        videoGoogleMaxBitrate;
                                }
                                if (videoGoogleMinBitrate !== undefined) {
                                    codecParameters['x-google-min-bitrate'] =
                                        videoGoogleMinBitrate;
                                }
                                break;
                            }
                        }
                    }
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codecParameters)) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codecParameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codecRtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = answerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of answerRtpParameters.headerExtensions) {
                    // Don't add a header extension if not present in the offer.
                    const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
                    if (!found) {
                        continue;
                    }
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                // Allow both 1 byte and 2 bytes length header extensions.
                if (extmapAllowMixed &&
                    offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
                    this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
                }
                // Simulcast.
                if (offerMediaObject.simulcast) {
                    this._mediaObject.simulcast = {
                        dir1: 'recv',
                        list1: offerMediaObject.simulcast.list1,
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                // Simulcast (draft version 03).
                else if (offerMediaObject.simulcast_03) {
                    this._mediaObject.simulcast_03 = {
                        value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv'),
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                if (this._planB && this._mediaObject.type === 'video') {
                    this._mediaObject.xGoogleFlag = 'conference';
                }
                break;
            }
            case 'application': {
                // New spec.
                if (typeof offerMediaObject.sctpPort === 'number') {
                    this._mediaObject.payloads = 'webrtc-datachannel';
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                }
                // Old spec.
                else if (offerMediaObject.sctpmap) {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: 'webrtc-datachannel',
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize,
                    };
                }
                break;
            }
        }
    }
    setDtlsRole(role) {
        switch (role) {
            case 'client': {
                this._mediaObject.setup = 'active';
                break;
            }
            case 'server': {
                this._mediaObject.setup = 'passive';
                break;
            }
            case 'auto': {
                this._mediaObject.setup = 'actpass';
                break;
            }
        }
    }
    resume() {
        this._mediaObject.direction = 'recvonly';
    }
    muxSimulcastStreams(encodings) {
        if (!this._mediaObject.simulcast?.list1) {
            return;
        }
        const layers = {};
        for (const encoding of encodings) {
            if (encoding.rid) {
                layers[encoding.rid] = encoding;
            }
        }
        const raw = this._mediaObject.simulcast.list1;
        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
        for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
                simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
        }
        this._mediaObject.simulcast.list1 = simulcastStreams
            .map(simulcastFormats => simulcastFormats.map(f => `${f.paused ? '~' : ''}${f.scid}`).join(','))
            .join(';');
    }
}
exports.AnswerMediaSection = AnswerMediaSection;
class OfferMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false, }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            if (!sctpParameters) {
                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
            }
            else {
                this._mediaObject.protocol = 'UDP/DTLS/SCTP';
            }
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.protocol = 'RTP/AVP';
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (kind) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'sendonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                if (!this._planB) {
                    this._mediaObject.msid = `${streamId ?? '-'} ${trackId}`;
                }
                for (const codec of offerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codec.parameters)) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codec.parameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codec.rtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = offerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of offerRtpParameters.headerExtensions) {
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                const encoding = offerRtpParameters.encodings[0];
                const ssrc = encoding.ssrc;
                const rtxSsrc = encoding.rtx?.ssrc;
                this._mediaObject.ssrcs = [];
                this._mediaObject.ssrcGroups = [];
                if (offerRtpParameters.rtcp.cname) {
                    this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: 'cname',
                        value: offerRtpParameters.rtcp.cname,
                    });
                }
                if (this._planB) {
                    this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: 'msid',
                        value: `${streamId ?? '-'} ${trackId}`,
                    });
                }
                if (rtxSsrc) {
                    if (offerRtpParameters.rtcp.cname) {
                        this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: 'cname',
                            value: offerRtpParameters.rtcp.cname,
                        });
                    }
                    if (this._planB) {
                        this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: 'msid',
                            value: `${streamId ?? '-'} ${trackId}`,
                        });
                    }
                    // Associate original and retransmission SSRCs.
                    this._mediaObject.ssrcGroups.push({
                        semantics: 'FID',
                        ssrcs: `${ssrc} ${rtxSsrc}`,
                    });
                }
                break;
            }
            case 'application': {
                // New spec.
                if (!oldDataChannelSpec) {
                    this._mediaObject.payloads = 'webrtc-datachannel';
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                }
                // Old spec.
                else {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: 'webrtc-datachannel',
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize,
                    };
                }
                break;
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
        // Always 'actpass'.
        this._mediaObject.setup = 'actpass';
    }
    resume() {
        this._mediaObject.direction = 'sendonly';
    }
    planBReceive({ offerRtpParameters, streamId, trackId, }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx?.ssrc;
        const payloads = this._mediaObject.payloads.split(' ');
        for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
                continue;
            }
            const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate,
            };
            if (codec.channels > 1) {
                rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
                payload: codec.payloadType,
                config: '',
            };
            for (const key of Object.keys(codec.parameters)) {
                if (fmtp.config) {
                    fmtp.config += ';';
                }
                fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
                this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter,
                });
            }
        }
        this._mediaObject.payloads += ` ${offerRtpParameters.codecs
            .filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType))
            .map((codec) => codec.payloadType)
            .join(' ')}`;
        this._mediaObject.payloads = this._mediaObject.payloads.trim();
        if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
                id: ssrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname,
            });
        }
        this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId ?? '-'} ${trackId}`,
        });
        if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: 'cname',
                    value: offerRtpParameters.rtcp.cname,
                });
            }
            this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'msid',
                value: `${streamId ?? '-'} ${trackId}`,
            });
            // Associate original and retransmission SSRCs.
            this._mediaObject.ssrcGroups.push({
                semantics: 'FID',
                ssrcs: `${ssrc} ${rtxSsrc}`,
            });
        }
    }
    planBStopReceiving({ offerRtpParameters, }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx?.ssrc;
        this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
        if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
        }
    }
}
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    return mimeTypeMatch[2];
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoteSdp = void 0;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
const Logger_1 = __webpack_require__(/*! ../../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
const MediaSection_1 = __webpack_require__(/*! ./MediaSection */ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js");
const logger = new Logger_1.Logger('RemoteSdp');
class RemoteSdp {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, }) {
        // MediaSection instances with same order as in the SDP.
        this._mediaSections = [];
        // MediaSection indices indexed by MID.
        this._midToIndex = new Map();
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._planB = planB;
        this._sdpObject = {
            version: 0,
            origin: {
                address: '0.0.0.0',
                ipVer: 4,
                netType: 'IN',
                sessionId: 10000,
                sessionVersion: 0,
                username: 'mediasoup-client',
            },
            name: '-',
            timing: { start: 0, stop: 0 },
            media: [],
        };
        // If ICE parameters are given, add ICE-Lite indicator.
        if (iceParameters?.iceLite) {
            this._sdpObject.icelite = 'ice-lite';
        }
        // If DTLS parameters are given, assume WebRTC and BUNDLE.
        if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };
            // NOTE: We take the latest fingerprint.
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
                type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                hash: dtlsParameters.fingerprints[numFingerprints - 1].value,
            };
            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];
        }
        // If there are plain RPT parameters, override SDP origin.
        if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
    }
    updateIceParameters(iceParameters) {
        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
        }
    }
    updateDtlsRole(role) {
        logger.debug('updateDtlsRole() [role:%s]', role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
        }
    }
    getNextMediaSectionIdx() {
        // If a closed media section is found, return its index.
        for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
                return { idx, reuseMid: mediaSection.mid };
            }
        }
        // If no closed media section is found, return next one.
        return { idx: this._mediaSections.length };
    }
    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false, }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed,
        });
        // Unified-Plan with closed media section replacement.
        if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
        }
        // Unified-Plan or Plan-B with different media kind.
        else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
        }
        // Plan-B with same media kind.
        else {
            this._replaceMediaSection(mediaSection);
        }
    }
    receive({ mid, kind, offerRtpParameters, streamId, trackId, }) {
        const idx = this._midToIndex.get(mid);
        let mediaSection;
        if (idx !== undefined) {
            mediaSection = this._mediaSections[idx];
        }
        // Unified-Plan or different media kind.
        if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
                iceParameters: this._iceParameters,
                iceCandidates: this._iceCandidates,
                dtlsParameters: this._dtlsParameters,
                plainRtpParameters: this._plainRtpParameters,
                planB: this._planB,
                mid,
                kind,
                offerRtpParameters,
                streamId,
                trackId,
            });
            // Let's try to recycle a closed media section (if any).
            // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
            const oldMediaSection = this._mediaSections.find(m => m.closed);
            if (oldMediaSection) {
                this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            }
            else {
                this._addMediaSection(mediaSection);
            }
        }
        // Plan-B.
        else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
        }
    }
    pauseMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.pause();
    }
    resumeSendingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    resumeReceivingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    disableMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
    closeMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        // NOTE: Closing the first m section is a pain since it invalidates the
        // bundled transport, so let's avoid it.
        if (mid === this._firstMid) {
            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
            this.disableMediaSection(mid);
            return false;
        }
        mediaSection.close();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
        return true;
    }
    muxMediaSectionSimulcast(mid, encodings) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.muxSimulcastStreams(encodings);
        this._replaceMediaSection(mediaSection);
    }
    planBStopReceiving({ mid, offerRtpParameters, }) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.planBStopReceiving({ offerRtpParameters });
        this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject,
        });
        this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation({ oldDataChannelSpec = false, } = {}) {
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: 'datachannel',
            kind: 'application',
            oldDataChannelSpec,
        });
        this._addMediaSection(mediaSection);
    }
    getSdp() {
        // Increase SDP version.
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
        if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
        }
        // Add to the vector.
        this._mediaSections.push(newMediaSection);
        // Add to the map.
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        // Add to the SDP object.
        this._sdpObject.media.push(newMediaSection.getObject());
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
        // Store it in the map.
        if (typeof reuseMid === 'string') {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === undefined) {
                throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the map.
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
        }
        else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === undefined) {
                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
        }
    }
    _findMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        return this._mediaSections[idx];
    }
    _regenerateBundleMids() {
        if (!this._dtlsParameters) {
            return;
        }
        this._sdpObject.groups[0].mids = this._mediaSections
            .filter((mediaSection) => !mediaSection.closed)
            .map((mediaSection) => mediaSection.mid)
            .join(' ');
    }
}
exports.RemoteSdp = RemoteSdp;


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;
exports.getCname = getCname;
exports.applyCodecParameters = applyCodecParameters;
const sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
/**
 * This function must be called with an SDP with 1 m=audio and 1 m=video
 * sections.
 */
function extractRtpCapabilities({ sdpObject, }) {
    // Map of RtpCodecParameters indexed by payload type.
    const codecsMap = new Map();
    // Array of RtpHeaderExtensions.
    const headerExtensions = [];
    // Whether a m=audio/video section has been already found.
    let gotAudio = false;
    let gotVideo = false;
    for (const m of sdpObject.media) {
        const kind = m.type;
        switch (kind) {
            case 'audio': {
                if (gotAudio) {
                    continue;
                }
                gotAudio = true;
                break;
            }
            case 'video': {
                if (gotVideo) {
                    continue;
                }
                gotVideo = true;
                break;
            }
            default: {
                continue;
            }
        }
        // Get codecs.
        for (const rtp of m.rtp) {
            const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: [],
            };
            codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
        for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
                continue;
            }
            // Specials case to convert parameter value to string.
            if (parameters?.hasOwnProperty('profile-level-id')) {
                parameters['profile-level-id'] = String(parameters['profile-level-id']);
            }
            codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
        for (const fb of m.rtcpFb || []) {
            const feedback = {
                type: fb.type,
                parameter: fb.subtype,
            };
            if (!feedback.parameter) {
                delete feedback.parameter;
            }
            // rtcp-fb payload is not '*', so just apply it to its corresponding
            // codec.
            if (fb.payload !== '*') {
                const codec = codecsMap.get(fb.payload);
                if (!codec) {
                    continue;
                }
                codec.rtcpFeedback.push(feedback);
            }
            // If rtcp-fb payload is '*' it must be applied to all codecs with same
            // kind (with some exceptions such as RTX codec).
            else {
                for (const codec of codecsMap.values()) {
                    if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                        codec.rtcpFeedback.push(feedback);
                    }
                }
            }
        }
        // Get RTP header extensions.
        for (const ext of m.ext || []) {
            // Ignore encrypted extensions (not yet supported in mediasoup).
            if (ext['encrypt-uri']) {
                continue;
            }
            const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value,
            };
            headerExtensions.push(headerExtension);
        }
    }
    const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: headerExtensions,
    };
    return rtpCapabilities;
}
function extractDtlsParameters({ sdpObject, }) {
    let setup = sdpObject.setup;
    let fingerprint = sdpObject.fingerprint;
    if (!setup || !fingerprint) {
        const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);
        if (mediaObject) {
            setup ?? (setup = mediaObject.setup);
            fingerprint ?? (fingerprint = mediaObject.fingerprint);
        }
    }
    if (!setup) {
        throw new Error('no a=setup found at SDP session or media level');
    }
    else if (!fingerprint) {
        throw new Error('no a=fingerprint found at SDP session or media level');
    }
    let role;
    switch (setup) {
        case 'active': {
            role = 'client';
            break;
        }
        case 'passive': {
            role = 'server';
            break;
        }
        case 'actpass': {
            role = 'auto';
            break;
        }
    }
    const dtlsParameters = {
        role,
        fingerprints: [
            {
                algorithm: fingerprint.type,
                value: fingerprint.hash,
            },
        ],
    };
    return dtlsParameters;
}
function getCname({ offerMediaObject, }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        return '';
    }
    return ssrcCnameLine.value;
}
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters({ offerRtpParameters, answerMediaObject, }) {
    for (const codec of offerRtpParameters.codecs) {
        const mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') {
            continue;
        }
        const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);
        if (!rtp) {
            continue;
        }
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp || [];
        let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
        if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: '' };
            answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
            case 'audio/opus': {
                const spropStereo = codec.parameters['sprop-stereo'];
                if (spropStereo !== undefined) {
                    parameters.stereo = spropStereo ? 1 : 0;
                }
                break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
                fmtp.config += ';';
            }
            fmtp.config += `${key}=${parameters[key]}`;
        }
    }
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings({ offerMediaObject, track, }) {
    // First media SSRC (or the only one).
    let firstSsrc;
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        if (line.attribute !== 'msid') {
            continue;
        }
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc) {
                firstSsrc = ssrc;
            }
        }
    }
    if (ssrcs.size === 0) {
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    }
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID') {
            continue;
        }
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know that they
            // are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
    }
    return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, track, numStreams, }) {
    if (numStreams <= 1) {
        throw new TypeError('numStreams must be greater than 1');
    }
    let firstSsrc;
    let firstRtxSsrc;
    let streamId;
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
        if (line.attribute !== 'msid') {
            return false;
        }
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(' ')[0];
            return true;
        }
        else {
            return false;
        }
    });
    if (!ssrcMsidLine) {
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    }
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line) => {
        if (line.semantics !== 'FID') {
            return false;
        }
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname' && line.id === firstSsrc);
    if (!ssrcCnameLine) {
        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
        }
    }
    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' '),
    });
    for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`,
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`,
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`,
        });
    }
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings({ offerMediaObject, }) {
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        const ssrc = line.id;
        ssrcs.add(ssrc);
    }
    if (ssrcs.size === 0) {
        throw new Error('no a=ssrc lines found');
    }
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID') {
            continue;
        }
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know
            // that they are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
    }
    return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, numStreams, }) {
    if (numStreams <= 1) {
        throw new TypeError('numStreams must be greater than 1');
    }
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === 'msid');
    if (!ssrcMsidLine) {
        throw new Error('a=ssrc line with msid information not found');
    }
    const [streamId, trackId] = ssrcMsidLine.value.split(' ');
    const firstSsrc = Number(ssrcMsidLine.id);
    let firstRtxSsrc;
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line) => {
        if (line.semantics !== 'FID') {
            return false;
        }
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        throw new Error('a=ssrc line with cname information not found');
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
        }
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' '),
    });
    for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`,
        });
    }
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
exports.debug = debug_1.default;
const Device_1 = __webpack_require__(/*! ./Device */ "./node_modules/mediasoup-client/lib/Device.js");
Object.defineProperty(exports, "Device", ({ enumerable: true, get: function () { return Device_1.Device; } }));
Object.defineProperty(exports, "detectDevice", ({ enumerable: true, get: function () { return Device_1.detectDevice; } }));
const types = __importStar(__webpack_require__(/*! ./types */ "./node_modules/mediasoup-client/lib/types.js"));
exports.types = types;
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.7.17';
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
Object.defineProperty(exports, "parseScalabilityMode", ({ enumerable: true, get: function () { return scalabilityModes_1.parse; } }));


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/ortc.js":
/*!***************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/ortc.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateRtpCapabilities = validateRtpCapabilities;
exports.validateRtpParameters = validateRtpParameters;
exports.validateSctpStreamParameters = validateSctpStreamParameters;
exports.validateSctpCapabilities = validateSctpCapabilities;
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
exports.reduceCodecs = reduceCodecs;
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
exports.canSend = canSend;
exports.canReceive = canReceive;
const h264 = __importStar(__webpack_require__(/*! h264-profile-level-id */ "./node_modules/h264-profile-level-id/lib/index.js"));
const utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
const RTP_PROBATOR_MID = 'probator';
const RTP_PROBATOR_SSRC = 1234;
const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs)) {
        throw new TypeError('caps.codecs is not an array');
    }
    else if (!caps.codecs) {
        caps.codecs = [];
    }
    for (const codec of caps.codecs) {
        validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
        throw new TypeError('caps.headerExtensions is not an array');
    }
    else if (!caps.headerExtensions) {
        caps.headerExtensions = [];
    }
    for (const ext of caps.headerExtensions) {
        validateRtpHeaderExtension(ext);
    }
}
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string') {
        throw new TypeError('params.mid is not a string');
    }
    // codecs is mandatory.
    if (!Array.isArray(params.codecs)) {
        throw new TypeError('missing params.codecs');
    }
    for (const codec of params.codecs) {
        validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
        throw new TypeError('params.headerExtensions is not an array');
    }
    else if (!params.headerExtensions) {
        params.headerExtensions = [];
    }
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings)) {
        throw new TypeError('params.encodings is not an array');
    }
    else if (!params.encodings) {
        params.encodings = [];
    }
    for (const encoding of params.encodings) {
        validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== 'object') {
        throw new TypeError('params.rtcp is not an object');
    }
    else if (!params.rtcp) {
        params.rtcp = {};
    }
    validateRtcpParameters(params.rtcp);
}
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // streamId is mandatory.
    if (typeof params.streamId !== 'number') {
        throw new TypeError('missing params.streamId');
    }
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === 'boolean') {
        orderedGiven = true;
    }
    else {
        params.ordered = true;
    }
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime &&
        typeof params.maxPacketLifeTime !== 'number') {
        throw new TypeError('invalid params.maxPacketLifeTime');
    }
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
        throw new TypeError('invalid params.maxRetransmits');
    }
    if (params.maxPacketLifeTime && params.maxRetransmits) {
        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
    }
    if (orderedGiven &&
        params.ordered &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
    }
    else if (!orderedGiven &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
    }
    // label is optional.
    if (params.label && typeof params.label !== 'string') {
        throw new TypeError('invalid params.label');
    }
    // protocol is optional.
    if (params.protocol && typeof params.protocol !== 'string') {
        throw new TypeError('invalid params.protocol');
    }
}
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // numStreams is mandatory.
    if (!caps.numStreams || typeof caps.numStreams !== 'object') {
        throw new TypeError('missing caps.numStreams');
    }
    validateNumSctpStreams(caps.numStreams);
}
/**
 * Generate extended RTP capabilities for sending and receiving.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps) {
    const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    // Match media codecs and keep the order preferred by remoteCaps.
    for (const remoteCodec of remoteCaps.codecs ?? []) {
        if (isRtxCodec(remoteCodec)) {
            continue;
        }
        const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
        if (!matchingLocalCodec) {
            continue;
        }
        const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
    }
    // Match RTX codecs.
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) &&
            localCodec.parameters.apt === extendedCodec.localPayloadType);
        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) &&
            remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType =
                matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType =
                matchingRemoteRtxCodec.preferredPayloadType;
        }
    }
    // Match header extensions.
    for (const remoteExt of remoteCaps.headerExtensions) {
        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
        if (!matchingLocalExt) {
            continue;
        }
        const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: 'sendrecv',
        };
        switch (remoteExt.direction) {
            case 'sendrecv': {
                extendedExt.direction = 'sendrecv';
                break;
            }
            case 'recvonly': {
                extendedExt.direction = 'sendonly';
                break;
            }
            case 'sendonly': {
                extendedExt.direction = 'recvonly';
                break;
            }
            case 'inactive': {
                extendedExt.direction = 'inactive';
                break;
            }
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
}
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpCapabilities.codecs.push(codec);
        // Add RTX codec.
        if (!extendedCodec.remoteRtxPayloadType) {
            continue;
        }
        const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
                apt: extendedCodec.remotePayloadType,
            },
            rtcpFeedback: [],
        };
        rtpCapabilities.codecs.push(rtxCodec);
        // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions not valid for receiving.
        if (extendedExtension.direction !== 'sendrecv' &&
            extendedExtension.direction !== 'recvonly') {
            continue;
        }
        const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction,
        };
        rtpCapabilities.headerExtensions.push(ext);
    }
    return rtpCapabilities;
}
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
}
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (rtpParameters.headerExtensions.some(ext => ext.uri ===
        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'goog-remb');
        }
    }
    else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc');
        }
    }
    else {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');
        }
    }
    return rtpParameters;
}
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    // If no capability codec is given, take the first one (and RTX).
    if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
        }
    }
    // Otherwise look for a compatible set of codecs.
    else {
        for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
                filteredCodecs.push(codecs[idx]);
                if (isRtxCodec(codecs[idx + 1])) {
                    filteredCodecs.push(codecs[idx + 1]);
                }
                break;
            }
        }
        if (filteredCodecs.length === 0) {
            throw new TypeError('no matching codec found');
        }
    }
    return filteredCodecs;
}
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
    // Clone given reference video RTP parameters.
    videoRtpParameters = utils.clone(videoRtpParameters);
    // This may throw.
    validateRtpParameters(videoRtpParameters);
    const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
        rtcp: { cname: 'probator' },
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
}
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, extendedRtpCapabilities) {
    return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);
}
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
    // This may throw.
    validateRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0) {
        return false;
    }
    const firstMediaCodec = rtpParameters.codecs[0];
    return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
}
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is optional.
    if (codec.preferredPayloadType &&
        typeof codec.preferredPayloadType !== 'number') {
        throw new TypeError('invalid codec.preferredPayloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
    if (typeof fb !== 'object') {
        throw new TypeError('fb is not an object');
    }
    // type is mandatory.
    if (!fb.type || typeof fb.type !== 'string') {
        throw new TypeError('missing fb.type');
    }
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== 'string') {
        fb.parameter = '';
    }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // kind is mandatory.
    if (ext.kind !== 'audio' && ext.kind !== 'video') {
        throw new TypeError('invalid ext.kind');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // preferredId is mandatory.
    if (typeof ext.preferredId !== 'number') {
        throw new TypeError('missing ext.preferredId');
    }
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
        throw new TypeError('invalid ext.preferredEncrypt');
    }
    else if (!ext.preferredEncrypt) {
        ext.preferredEncrypt = false;
    }
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== 'string') {
        throw new TypeError('invalid ext.direction');
    }
    else if (!ext.direction) {
        ext.direction = 'sendrecv';
    }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // payloadType is mandatory.
    if (typeof codec.payloadType !== 'number') {
        throw new TypeError('missing codec.payloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // id is mandatory.
    if (typeof ext.id !== 'number') {
        throw new TypeError('missing ext.id');
    }
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
        throw new TypeError('invalid ext.encrypt');
    }
    else if (!ext.encrypt) {
        ext.encrypt = false;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== 'object') {
        ext.parameters = {};
    }
    for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError('invalid header extension parameter');
        }
    }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
    if (typeof encoding !== 'object') {
        throw new TypeError('encoding is not an object');
    }
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
        throw new TypeError('invalid encoding.ssrc');
    }
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== 'string') {
        throw new TypeError('invalid encoding.rid');
    }
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== 'object') {
        throw new TypeError('invalid encoding.rtx');
    }
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== 'number') {
            throw new TypeError('missing encoding.rtx.ssrc');
        }
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
        encoding.dtx = false;
    }
    // scalabilityMode is optional.
    if (encoding.scalabilityMode &&
        typeof encoding.scalabilityMode !== 'string') {
        throw new TypeError('invalid encoding.scalabilityMode');
    }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
    if (typeof rtcp !== 'object') {
        throw new TypeError('rtcp is not an object');
    }
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== 'string') {
        throw new TypeError('invalid rtcp.cname');
    }
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
        rtcp.reducedSize = true;
    }
}
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== 'object') {
        throw new TypeError('numStreams is not an object');
    }
    // OS is mandatory.
    if (typeof numStreams.OS !== 'number') {
        throw new TypeError('missing numStreams.OS');
    }
    // MIS is mandatory.
    if (typeof numStreams.MIS !== 'number') {
        throw new TypeError('missing numStreams.MIS');
    }
}
function isRtxCodec(codec) {
    if (!codec) {
        return false;
    }
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) {
        return false;
    }
    if (aCodec.clockRate !== bCodec.clockRate) {
        return false;
    }
    if (aCodec.channels !== bCodec.channels) {
        return false;
    }
    // Per codec special checks.
    switch (aMimeType) {
        case 'video/h264': {
            if (strict) {
                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
                if (aPacketizationMode !== bPacketizationMode) {
                    return false;
                }
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                    return false;
                }
                let selectedProfileLevelId;
                try {
                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
                }
                catch (error) {
                    return false;
                }
                if (modify) {
                    if (selectedProfileLevelId) {
                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                        bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                    }
                    else {
                        delete aCodec.parameters['profile-level-id'];
                        delete bCodec.parameters['profile-level-id'];
                    }
                }
            }
            break;
        }
        case 'video/vp9': {
            if (strict) {
                const aProfileId = aCodec.parameters['profile-id'] || 0;
                const bProfileId = bCodec.parameters['profile-id'] || 0;
                if (aProfileId !== bProfileId) {
                    return false;
                }
            }
            break;
        }
    }
    return true;
}
function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
        return false;
    }
    if (aExt.uri !== bExt.uri) {
        return false;
    }
    return true;
}
function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback ?? []) {
        const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type &&
            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter)));
        if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
        }
    }
    return reducedRtcpFeedback;
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/scalabilityModes.js":
/*!***************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = parse;
const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode ?? '');
    if (match) {
        return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2]),
        };
    }
    else {
        return {
            spatialLayers: 1,
            temporalLayers: 1,
        };
    }
}


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/types.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/types.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Device */ "./node_modules/mediasoup-client/lib/Device.js"), exports);
__exportStar(__webpack_require__(/*! ./Transport */ "./node_modules/mediasoup-client/lib/Transport.js"), exports);
__exportStar(__webpack_require__(/*! ./Producer */ "./node_modules/mediasoup-client/lib/Producer.js"), exports);
__exportStar(__webpack_require__(/*! ./Consumer */ "./node_modules/mediasoup-client/lib/Consumer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataProducer */ "./node_modules/mediasoup-client/lib/DataProducer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataConsumer */ "./node_modules/mediasoup-client/lib/DataConsumer.js"), exports);
__exportStar(__webpack_require__(/*! ./RtpParameters */ "./node_modules/mediasoup-client/lib/RtpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./SctpParameters */ "./node_modules/mediasoup-client/lib/SctpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./handlers/HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js"), exports);


/***/ }),

/***/ "./node_modules/mediasoup-client/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = clone;
exports.generateRandomNumber = generateRandomNumber;
exports.deepFreeze = deepFreeze;
/**
 * Clones the given value.
 */
function clone(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(value);
    }
    else {
        return JSON.parse(JSON.stringify(value));
    }
}
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
    return Math.round(Math.random() * 10000000);
}
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(object) {
    // Retrieve the property names defined on object.
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self.
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/npm-events-package/events.js":
/*!***************************************************!*\
  !*** ./node_modules/npm-events-package/events.js ***!
  \***************************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/queue-microtask/index.js":
/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))


/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/***/ ((module) => {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding)
          ? 'rtpmap:%d %s/%s/%s'
          : o.rate
            ? 'rtpmap:%d %s/%s'
            : 'rtpmap:%d %s';
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    {
      // a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null)
          ? 'rtcp:%d %s IP%d %s'
          : 'rtcp:%d';
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%s trr-int %d'
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null)
          ? 'rtcp-fb:%s %s %s'
          : 'rtcp-fb:%s %s';
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
      format: function (o) {
        return (
          'extmap:%d' +
          (o.direction ? '/%s' : '%v') +
          (o['encrypt-uri'] ? ' %s' : '%v') +
          ' %s' +
          (o.config ? ' %s' : '')
        );
      }
    },
    {
      // a=extmap-allow-mixed
      name: 'extmapAllowMixed',
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null)
          ? 'crypto:%d %s %s %s'
          : 'crypto:%d %s %s';
      }
    },
    {
      // a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    {
      // a=connection:new
      name: 'connectionType',
      reg: /^connection:(new|existing)/,
      format: 'connection:%s'
    },
    {
      // a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    {
      // a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: 'ptime:%d'
    },
    {
      // a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: 'maxptime:%d'
    },
    {
      // a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    {
      // a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    {
      // a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null)
          ? 'sctpmap:%s %s %s'
          : 'sctpmap:%s %s';
      }
    },
    {
      // a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        // a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        // recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        // a=simulcast:
        '^simulcast:' +
        // send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        // space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        // end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    {
      // a=bundle-only
      name: 'bundleOnly',
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: 'label',
      reg: /^label:(.+)/,
      format: 'label:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: 'sctpPort',
      reg: /^sctp-port:(\d+)$/,
      format: 'sctp-port:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: 'maxMessageSize',
      reg: /^max-message-size:(\d+)$/,
      format: 'max-message-size:%s'
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push:'tsRefClocks',
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ['clksrc', 'clksrcExt'],
      format: function (o) {
        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name:'mediaClk',
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
      format: function (o) {
        var str = 'mediaclk:';
        str += (o.id != null ? 'id=%s %s' : '%v%s');
        str += (o.mediaClockValue != null ? '=%s' : '');
        str += (o.rateNumerator != null ? ' rate=%s' : '');
        str += (o.rateDenominator != null ? '/%s' : '');
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: 'keywords',
      reg: /^keywds:(.+)$/,
      format: 'keywds:%s'
    },
    {
      // a=content:main
      name: 'content',
      reg: /^content:(.+)/,
      format: 'content:%s'
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: 'bfcpFloorCtrl',
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: 'floorctrl:%s'
    },
    {
      // a=confid:1
      name: 'bfcpConfId',
      reg: /^confid:(\d+)/,
      format: 'confid:%s'
    },
    {
      // a=userid:1
      name: 'bfcpUserId',
      reg: /^userid:(\d+)/,
      format: 'userid:%s'
    },
    {
      // a=floorid:1
      name: 'bfcpFloorId',
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ['id', 'mStream'],
      format: 'floorid:%s mstrm:%s'
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});


/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var parser = __webpack_require__(/*! ./parser */ "./node_modules/sdp-transform/lib/parser.js");
var writer = __webpack_require__(/*! ./writer */ "./node_modules/sdp-transform/lib/writer.js");

exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__(/*! ./grammar */ "./node_modules/sdp-transform/lib/grammar.js");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};


/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var grammar = __webpack_require__(/*! ./grammar */ "./node_modules/sdp-transform/lib/grammar.js");

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),

/***/ "./node_modules/ua-parser-js/src/ua-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v1.0.39
   Copyright Â© 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '1.0.39',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major',
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded',
        UA_MAX_LENGTH = 500;

    var AMAZON  = 'Amazon',
        APPLE   = 'Apple',
        ASUS    = 'ASUS',
        BLACKBERRY = 'BlackBerry',
        BROWSER = 'Browser',
        CHROME  = 'Chrome',
        EDGE    = 'Edge',
        FIREFOX = 'Firefox',
        GOOGLE  = 'Google',
        HUAWEI  = 'Huawei',
        LG      = 'LG',
        MICROSOFT = 'Microsoft',
        MOTOROLA  = 'Motorola',
        OPERA   = 'Opera',
        SAMSUNG = 'Samsung',
        SHARP   = 'Sharp',
        SONY    = 'Sony',
        XIAOMI  = 'Xiaomi',
        ZEBRA   = 'Zebra',
        FACEBOOK    = 'Facebook',
        CHROMIUM_OS = 'Chromium OS',
        MAC_OS  = 'Mac OS',
        SUFFIX_BROWSER = ' Browser';

    ///////////
    // Helper
    //////////

    var extend = function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        enumerize = function (arr) {
            var enums = {};
            for (var i=0; i<arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
        },
        has = function (str1, str2) {
            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        },
        lowerize = function (str) {
            return str.toLowerCase();
        },
        majorize = function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
        },
        trim = function (str, len) {
            if (typeof(str) === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY);
                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
    };

    ///////////////
    // Map helper
    //////////////

    var rgxMapper = function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    if (!regex[j]) { break; }
                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length === 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length === 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length === 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        strMapper = function (str, map) {

            for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return map.hasOwnProperty('*') ? map['*'] : str;
    };

    ///////////////
    // String map
    //////////////

    // Safari < 3.0
    var oldSafariMap = {
            '1.0'   : '/8',
            '1.2'   : '/1',
            '1.3'   : '/3',
            '2.0'   : '/412',
            '2.0.2' : '/416',
            '2.0.3' : '/417',
            '2.0.4' : '/419',
            '?'     : '/'
        },
        windowsVersionMap = {
            'ME'        : '4.90',
            'NT 3.11'   : 'NT3.51',
            'NT 4.0'    : 'NT4.0',
            '2000'      : 'NT 5.0',
            'XP'        : ['NT 5.1', 'NT 5.2'],
            'Vista'     : 'NT 6.0',
            '7'         : 'NT 6.1',
            '8'         : 'NT 6.2',
            '8.1'       : 'NT 6.3',
            '10'        : ['NT 6.4', 'NT 10.0'],
            'RT'        : 'ARM'
    };

    //////////////
    // Regex map
    /////////////

    var regexes = {

        browser : [[

            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [

            // Presto based
            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
            ], [NAME, VERSION], [
            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA+' Mini']], [
            /\bop(?:rg)?x\/([\w\.]+)/i                                          // Opera GX
            ], [VERSION, [NAME, OPERA+' GX']], [
            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [

            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i            // Baidu
            ], [VERSION, [NAME, 'Baidu']], [
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,      
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,             // Avant/IEMobile/SlimBrowser
            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio)\/([-\w\.]+)/i,
                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio
            /(heytap|ovi)browser\/([\d\.]+)/i,                                  // HeyTap/Ovi
            /(weibo)__([\d\.]+)/i                                               // Weibo
            ], [NAME, VERSION], [
            /quark(?:pc)?\/([-\w\.]+)/i                                         // Quark
            ], [VERSION, [NAME, 'Quark']], [
            /\bddg\/([\w\.]+)/i                                                 // DuckDuckGo
            ], [VERSION, [NAME, 'DuckDuckGo']], [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
            ], [VERSION, [NAME, 'UC'+BROWSER]], [
            /microm.+\bqbcore\/([\w\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
            ], [VERSION, [NAME, 'IE']], [
            /ya(?:search)?browser\/([\w\.]+)/i                                  // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /slbrowser\/([\w\.]+)/i                                             // Smart Lenovo Browser
            ], [VERSION, [NAME, 'Smart Lenovo '+BROWSER]], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [
            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
            ], [VERSION, [NAME, FIREFOX+' Focus']], [
            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
            ], [VERSION, [NAME, OPERA+' Touch']], [
            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, OPERA+' Coast']], [
            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [
            /fxios\/([-\w\.]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, FIREFOX]], [
            /\bqihu|(qi?ho?o?|360)browser/i                                     // 360
            ], [[NAME, '360' + SUFFIX_BROWSER]], [
            /\b(qq)\/([\w\.]+)/i                                                // QQ
            ], [[NAME, /(.+)/, '$1Browser'], VERSION], [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1' + SUFFIX_BROWSER], VERSION], [              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i                                        // Samsung Internet
            ], [VERSION, [NAME, SAMSUNG + ' Internet']], [
            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [
            /metasr[\/ ]?([\d\.]+)/i                                            // Sogou Explorer
            ], [VERSION, [NAME, 'Sogou Explorer']], [
            /(sogou)mo\w+\/([\d\.]+)/i                                          // Sogou Mobile
            ], [[NAME, 'Sogou Mobile'], VERSION], [
            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
            /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i                        // QQBrowser/2345 Browser
            ], [NAME, VERSION], [
            /(lbbrowser|rekonq)/i,                                              // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i                                                // LinkedIn App for iOS & Android
            ], [NAME], [

            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION], [
            /(Klarna)\/([\w\.]+)/i,                                             // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,                             // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,                                  // Naver InApp
            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(alipay)client\/([\w\.]+)/i,                                       // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,                               // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i                     // Chromium/Instagram/Snapchat
            ], [NAME, VERSION], [
            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i                        // TikTok
            ], [VERSION, [NAME, 'TikTok']], [

            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
            ], [VERSION, [NAME, CHROME+' Headless']], [

            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
            ], [[NAME, CHROME+' WebView'], VERSION], [

            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
            ], [VERSION, [NAME, 'Android '+BROWSER]], [

            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i                      // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile
            ], [VERSION, NAME], [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
            ], [NAME, [VERSION, strMapper, oldSafariMap]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(wolvic)\/([\w\.]+)/i                                              // Wolvic
            ], [NAME, VERSION], [
            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
            ], [VERSION, [NAME, FIREFOX+' Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i                                              // Links
            ], [NAME, [VERSION, /_/g, '.']], [
            
            /(cobalt)\/([\w\.]+)/i                                              // Cobalt
            ], [NAME, [VERSION, /master.|lts./, ""]]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|arm(v?8e?l?|_?64))\b/i                                 // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i                            // PowerPC
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, lowerize]]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i                          // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [
            /(macintosh);/i
            ], [MODEL, [VENDOR, APPLE]], [

            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [

            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,                  // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,        // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
            /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,                     // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i                        // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [
            /\b(opd2\d{3}a?) bui/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, TABLET]], [

            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

            // Google
            /(pixel c)\b/i                                                      // Google Pixel C
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i                         // Google Pixel
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [

            // Sony
            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,                           // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i                                                    // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

            // HTC
            /(nexus 9)/i                                                        // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
            ], [MODEL, [VENDOR, 'TCL'], [TYPE, TABLET]], [

            // itel
            /(itel) ((\w+))/i
            ], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { 'tablet' : ['p10001l', 'w7001'], '*' : 'mobile' }]], [

            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
                
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
            ], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [

            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
            ], [MODEL, [VENDOR, 'Nothing'], [TYPE, MOBILE]], [

            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
            /(asus)-?(\w+)/i,                                                   // Asus
            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,                                          // Lenovo
            /(jolla)/i,                                                         // Jolla
            /(oppo) ?([\w ]+) bui/i                                             // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(kobo)\s(ereader|touch)/i,                                         // Kobo
            /(archos) (gamepad2?)/i,                                            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(nook)[\w ]+build\/(\w+)/i,                                        // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,                                   // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,                                  // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,                                      // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,                                    // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i                                   // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(surface duo)/i                                                    // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /(u304aa)/i                                                         // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
            /\bsie-(\w*)/i                                                      // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
            /\b(rct\w+) b/i                                                     // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
            /\b(venue[\d ]{2,7}) b/i                                            // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
            /\b(q(?:mv|ta)\w+) b/i                                              // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i                       // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
            /\b(tm\d{3}\w+) b/i
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
            /\b(k88) b/i                                                        // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
            /\b(nx\d{3}j) b/i                                                   // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
            /\b(gen\d{3}) b.+49h/i                                              // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
            /\b(zur\d{3}) b/i                                                   // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
            /\b((zeki)?tb.*\b) b/i                                              // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i                                // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
            /\b(ns-?\w{0,9}) b/i                                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
            /\b((nxa|next)-?\w{0,9}) b/i                                        // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
            /\b(lvtel\-)?(v1[12]) b/i                                           // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
            /\b(ph-1) /i                                                        // Essential PH-1
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
            /\b(v(100md|700na|7011|917g).*\b) b/i                               // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
            /\b(trio[-\w\. ]+) b/i                                              // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
            /\btu_(1491) b/i                                                    // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
            /(shield[\w ]+) b/i                                                 // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
            /(sprint) (\w+)/i                                                   // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i             // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i        // LG SmartTV
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
            /(apple) ?tv/i                                                      // Apple TV
            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /droid.+aft(\w+)( bui|\))/i                                         // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i                                               // Sharp
            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[
            /(bravia[\w ]+)( bui|\))/i                                              // Sony
            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
            /(mitv-\w{5}) bui/i                                                 // Xiaomi
            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
            /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i         // HbbTV devices
            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i                   // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /(ouya)/i,                                                          // Ouya
            /(nintendo) ([wids3utch]+)/i                                        // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+; (shield) bui/i                                            // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
            /(playstation [345portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i                                   // Samsung Galaxy Watch
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [
            /((pebble))app/i                                                    // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i                              // Apple Watch
            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [
            /droid.+; (glass) \d/i                                              // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
            /droid.+; (wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
            /(quest( \d| pro)?)/i                                               // Oculus Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [
            /(aeobc)\b/i                                                        // Echo Dot
            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i    // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [
            /(android[-\w\. ]{0,9});.+buil/i                                    // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, EDGE+'HTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,                                      // iCab
            /\b(libweb)/i
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i             // Windows Phone
            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
            /windows nt 6\.2; (arm)/i,                                        // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ], [[VERSION, strMapper, windowsVersionMap], [NAME, 'Windows']], [

            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,              // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i                             // Mac OS
            ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [

            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS
            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,                                     // Tizen/KaiOS
            /\((series40);/i                                                    // Series 40
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i         // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX+' OS']], [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
            ], [VERSION, [NAME, 'webOS']], [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i                              // watchOS
            ], [VERSION, [NAME, 'watchOS']], [

            // Google Chromecast
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
            ], [VERSION, [NAME, CHROME+'cast']], [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i                                  // Chromium OS
            ], [[NAME, CHROMIUM_OS], VERSION],[

            // Smart TVs
            /panasonic;(viera)/i,                                               // Panasonic Viera
            /(netrange)mmh/i,                                                   // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,                                         // NetTV

            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,                                           // Mint
            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,                                         // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,                                                // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i                                                    // Haiku
            ], [NAME, VERSION], [
            /(sunos) ?([\w\.\d]*)/i                                             // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,                                  // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i                                                // UNIX
            ], [NAME, VERSION]
        ]
    };

    /////////////////
    // Constructor
    ////////////////

    var UAParser = function (ua, extensions) {

        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
        }

        var _navigator = (typeof window !== UNDEF_TYPE && window.navigator) ? window.navigator : undefined;
        var _ua = ua || ((_navigator && _navigator.userAgent) ? _navigator.userAgent : EMPTY);
        var _uach = (_navigator && _navigator.userAgentData) ? _navigator.userAgentData : undefined;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;

        this.getBrowser = function () {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            // Brave-specific detection
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
                _browser[NAME] = 'Brave';
            }
            return _browser;
        };
        this.getCPU = function () {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function () {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
                _device[TYPE] = MOBILE;
            }
            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
            if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
                _device[MODEL] = 'iPad';
                _device[TYPE] = TABLET;
            }
            return _device;
        };
        this.getEngine = function () {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function () {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != 'Unknown') {
                _os[NAME] = _uach.platform  
                                    .replace(/chrome os/i, CHROMIUM_OS)
                                    .replace(/macos/i, MAC_OS);           // backward compatibility
            }
            return _os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return _ua;
        };
        this.setUA = function (ua) {
            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

    ///////////
    // Export
    //////////

    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if ("function" === FUNC_TYPE && __webpack_require__.amdO) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof window !== UNDEF_TYPE) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/amd options */
/******/ (() => {
/******/ 	__webpack_require__.amdO = {};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!**************************************!*\
  !*** ./services/mediaSoupService.js ***!
  \**************************************/


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSocket = void 0;
var _socketService = _interopRequireDefault(__webpack_require__(/*! ./socketService.js */ "./services/socketService.js"));
var _chatService = __webpack_require__(/*! ./chatService.js */ "./services/chatService.js");
var _mediasoupClient = __webpack_require__(/*! mediasoup-client */ "./node_modules/mediasoup-client/lib/index.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } // const { io } = require('socket.io-client');
// const socket = io('http://localhost:3000');
// import { socket, createConnection} from './socketService.js';
var localVideo = document.getElementById('localVideo');
// const remoteVideo = document.getElementById('remoteVideo');
var start = document.getElementById('start');
// const join = document.getElementById('join');

var rtpCapabilities;
var device;
var sendTransport;
var recvTransport;
var producer;
var consumer;
var isProducer = false;
start.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        // await initializeSocket();
        console.log('start button');
        _context.next = 3;
        return initializeDevice();
      case 3:
        setTimeout(function () {
          createSendTransport();
        }, 500);
      case 4:
      case "end":
        return _context.stop();
    }
  }, _callee);
})));
var urlParams = new URLSearchParams(window.location.search);
var roomId = urlParams.get('roomId');
var userName = urlParams.get('username');
console.log('roomid: ', roomId);
var socket;
_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
    while (1) switch (_context2.prev = _context2.next) {
      case 0:
        socket = _socketService["default"].initialize();
        _socketService["default"].connect();
        socket.on('connect', function () {
          console.log('Socket connected:', socket.id);
          (0, _chatService.chatroom)(roomId, userName, socket);
        });
      case 3:
      case "end":
        return _context2.stop();
    }
  }, _callee2);
})) // socket  = await connectSocket(roomId, userName);
// socket.on('connect', () => {
//     console.log('Socket connected:', socket.id);
//     chatroom(roomId, userName, socket)
// });
();
var getSocket = exports.getSocket = function getSocket() {
  return _socketService["default"].getSocket();
};
function socketConnection() {
  return _socketConnection.apply(this, arguments);
} //   createConnection(roomId,userName).then((result) => {
//     console.log('socket in media: ', result);
//     chatroom(roomId,userName,result);
//     socket = result;
//     socketInstance(socket);
//   }).catch((err) => {
//     console.log(err);
//   })
// Make sure to await the socket connection
// (async () => {
//     // await socketConnection();
// })();
function _socketConnection() {
  _socketConnection = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var result;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          try {
            result = createConnection(roomId, userName);
            console.log('socket in media: ');

            // Initialize message service before chatroom
            // await socketInstance(result);

            // Then initialize chatroom
            (0, _chatService.chatroom)(roomId, userName, result);

            // let socket = result;
          } catch (err) {
            console.error('Socket connection error:', err);
          }
        case 1:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _socketConnection.apply(this, arguments);
}
function streamSuccess(stream) {
  localVideo.srcObject = stream;
}
function mediaStream() {
  return _mediaStream.apply(this, arguments);
} // socket.on('connect', () => {
//     console.log(`A client connected: ${socket.id}`);
//     socket.emit('room',roomId,(data) => {
//             console.log("new client joined the room")
//             mediaStream();
//             rtpCapabilities = data.rtpCapabilities;
//     });
// })
function _mediaStream() {
  _mediaStream = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          navigator.mediaDevices.getUserMedia({
            audio: false,
            video: true
          }).then(function (stream) {
            streamSuccess(stream);
          })["catch"](function (err) {
            console.log(err);
          });
        case 1:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _mediaStream.apply(this, arguments);
}
function initializeDevice() {
  return _initializeDevice.apply(this, arguments);
} //get all the producers that are already in the room
function _initializeDevice() {
  _initializeDevice = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var routerRtpCapabilities;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          console.log("Initializing device");
          device = new _mediasoupClient.Device();
          routerRtpCapabilities = rtpCapabilities;
          _context5.next = 5;
          return device.load({
            routerRtpCapabilities: routerRtpCapabilities
          });
        case 5:
          console.log('Device loaded with rtpCapabilities: ', device.rtpCapabilities);
          // socket.emit('getRtpCapabilities',{},async (rtpCapabilities) => {
          //     console.log('getting rtpCapabilities: ',rtpCapabilities)
          //     const routerRtpCapabilities = rtpCapabilities;
          //     device = new mediasoupClient.Device();
          //     await device.load({routerRtpCapabilities});
          //     console.log('Device loaded with rtpCapabilities: ',device.rtpCapabilities);

          // })
        case 6:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _initializeDevice.apply(this, arguments);
}
function getProducers() {
  return _getProducers.apply(this, arguments);
}
function _getProducers() {
  _getProducers = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          console.log('producer exists');
          socket.emit('getProducers', {}, function (_ref3) {
            var producerList = _ref3.producerList;
            console.log("Producer ids: ", producerList);
            producerList.forEach(function (element) {
              console.log("you are both producer and consumer");
              newConsumer(element);
            });
          });
        case 2:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _getProducers.apply(this, arguments);
}
function createSendTransport() {
  return _createSendTransport.apply(this, arguments);
}
function _createSendTransport() {
  _createSendTransport = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          if (!device) console.log("Device not initialized");
          socket.emit('createTransport', {
            rtpCapabilities: device.rtpCapabilities,
            consumer: false
          }, /*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(params) {
              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    console.log("Params from send tranport: ", params);
                    _context9.prev = 1;
                    _context9.next = 4;
                    return device.createSendTransport(params);
                  case 4:
                    sendTransport = _context9.sent;
                    sendTransport.on('connect', /*#__PURE__*/function () {
                      var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref5, callback, errback) {
                        var dtlsParameters;
                        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                          while (1) switch (_context7.prev = _context7.next) {
                            case 0:
                              dtlsParameters = _ref5.dtlsParameters;
                              console.log("dtlsparameters: ", dtlsParameters);
                              try {
                                console.log("producer connect event");
                                socket.emit('producer-connect', {
                                  id: sendTransport.id,
                                  dtlsParameters: dtlsParameters
                                });
                                callback();
                              } catch (err) {
                                console.log("Error emitting produce-connect: ", err);
                                errback(err);
                              }
                            case 3:
                            case "end":
                              return _context7.stop();
                          }
                        }, _callee7);
                      }));
                      return function (_x6, _x7, _x8) {
                        return _ref6.apply(this, arguments);
                      };
                    }());
                    sendTransport.on('produce', /*#__PURE__*/function () {
                      var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(parameters, callback, errback) {
                        var _socket$emit, id;
                        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                          while (1) switch (_context8.prev = _context8.next) {
                            case 0:
                              try {
                                console.log('produce event');
                                _socket$emit = socket.emit('produce', {
                                  id: sendTransport.id,
                                  kind: parameters.kind,
                                  rtpParameters: parameters.rtpParameters
                                }, function (_ref8) {
                                  var id = _ref8.id,
                                    producerExists = _ref8.producerExists;
                                  console.log("producer exists: ", producerExists);
                                  callback({
                                    id: id
                                  });
                                  if (producerExists) getProducers();
                                }), id = _socket$emit.id;
                              } catch (err) {
                                errback(err);
                              }
                            case 1:
                            case "end":
                              return _context8.stop();
                          }
                        }, _callee8);
                      }));
                      return function (_x9, _x10, _x11) {
                        return _ref7.apply(this, arguments);
                      };
                    }());
                    sendTransport.on('icestatechange', function (state) {
                      console.log("IceStateChange: ", state);
                    });
                    sendTransport.on('connectionstatechange', function (state) {
                      console.log("ConnectionStateChange: ", state);
                    });
                    _context9.next = 11;
                    return produceMedia();
                  case 11:
                    _context9.next = 16;
                    break;
                  case 13:
                    _context9.prev = 13;
                    _context9.t0 = _context9["catch"](1);
                    console.log("Error creating sendTransport: ", _context9.t0);
                  case 16:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9, null, [[1, 13]]);
            }));
            return function (_x5) {
              return _ref4.apply(this, arguments);
            };
          }());
        case 2:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  }));
  return _createSendTransport.apply(this, arguments);
}
function produceMedia() {
  return _produceMedia.apply(this, arguments);
}
function _produceMedia() {
  _produceMedia = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
    var stream, track;
    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          console.log("producing media");
          _context11.next = 3;
          return navigator.mediaDevices.getUserMedia({
            video: true
          });
        case 3:
          stream = _context11.sent;
          // localVideo.srcObject = stream;
          track = stream.getVideoTracks()[0];
          console.log(track);
          _context11.prev = 6;
          console.log('before producing');
          _context11.next = 10;
          return sendTransport.produce({
            track: track
          });
        case 10:
          producer = _context11.sent;
          console.log("produced media");
          _context11.next = 17;
          break;
        case 14:
          _context11.prev = 14;
          _context11.t0 = _context11["catch"](6);
          console.log("error in producing media: ", _context11.t0);
        case 17:
        case "end":
          return _context11.stop();
      }
    }, _callee11, null, [[6, 14]]);
  }));
  return _produceMedia.apply(this, arguments);
}
var consumingTransports = [];
function newConsumer(_x) {
  return _newConsumer.apply(this, arguments);
} // socket.on('newProducer',({producerId}) => {
//     console.log("inform about new producer: ",producerId);
//     newConsumer(producerId);
// })
function _newConsumer() {
  _newConsumer = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(remoteProducerId) {
    return _regeneratorRuntime().wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          if (!device) console.log("Device not initialized");
          if (!consumingTransports.includes(remoteProducerId)) {
            _context14.next = 6;
            break;
          }
          console.log("already consumed");
          return _context14.abrupt("return");
        case 6:
          console.log('pusing into consuming transports');
          consumingTransports.push(remoteProducerId);
        case 8:
          socket.emit('createTransport', {
            rtpCapabilities: device.rtpCapabilities,
            consumer: true
          }, /*#__PURE__*/function () {
            var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(params) {
              return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                while (1) switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.prev = 0;
                    _context13.next = 3;
                    return device.createRecvTransport(params);
                  case 3:
                    recvTransport = _context13.sent;
                    console.log("recv transport created: ", params);
                    recvTransport.on('connect', /*#__PURE__*/function () {
                      var _ref11 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref10, callback, errback) {
                        var dtlsParameters;
                        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                          while (1) switch (_context12.prev = _context12.next) {
                            case 0:
                              dtlsParameters = _ref10.dtlsParameters;
                              try {
                                console.log('consumer connect');
                                socket.emit('consumer-connect', {
                                  dtlsParameters: dtlsParameters,
                                  consumerTransportId: params.id
                                });
                                callback();
                              } catch (err) {
                                console.log("Error emitting consumer-connect: ", err);
                                errback(err);
                              }
                            case 2:
                            case "end":
                              return _context12.stop();
                          }
                        }, _callee12);
                      }));
                      return function (_x13, _x14, _x15) {
                        return _ref11.apply(this, arguments);
                      };
                    }());
                    recvTransport.on('connectionstatechange', function (state) {
                      console.log("Consumer ConnectionStateChange: ", state);
                    });
                    console.log("calling consume");
                    console.log("remote producer id: ", remoteProducerId);
                    _context13.next = 11;
                    return consume(remoteProducerId, params.id, recvTransport);
                  case 11:
                    _context13.next = 16;
                    break;
                  case 13:
                    _context13.prev = 13;
                    _context13.t0 = _context13["catch"](0);
                    console.log("error in recv transport: ", _context13.t0);
                  case 16:
                  case "end":
                    return _context13.stop();
                }
              }, _callee13, null, [[0, 13]]);
            }));
            return function (_x12) {
              return _ref9.apply(this, arguments);
            };
          }());
        case 9:
        case "end":
          return _context14.stop();
      }
    }, _callee14);
  }));
  return _newConsumer.apply(this, arguments);
}
function consume(_x2, _x3, _x4) {
  return _consume.apply(this, arguments);
}
function _consume() {
  _consume = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(remoteProducerId, consumerTransportId, recvTransport) {
    return _regeneratorRuntime().wrap(function _callee16$(_context16) {
      while (1) switch (_context16.prev = _context16.next) {
        case 0:
          console.log("consume...");
          socket.emit('consume', {
            rtpCapabilities: device.rtpCapabilities,
            remoteProducerId: remoteProducerId,
            consumerTransportId: consumerTransportId
          }, /*#__PURE__*/function () {
            var _ref12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(params) {
              var _consumer, track, video;
              return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                while (1) switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.prev = 0;
                    console.log("before consuming");
                    console.log('producerId: ', params.producerId);
                    _context15.next = 5;
                    return recvTransport.consume({
                      id: params.id,
                      producerId: params.producerId,
                      kind: params.kind,
                      rtpParameters: params.rtpParameters
                    });
                  case 5:
                    consumer = _context15.sent;
                    console.log('track');
                    // Render the remote video track into a HTML video element.
                    _consumer = consumer, track = _consumer.track;
                    console.log(track);
                    video = document.createElement('video');
                    video.setAttribute('autoplay', 'true');
                    video.setAttribute('id', "td-".concat(remoteProducerId));
                    document.querySelector('.video').appendChild(video);
                    document.getElementById("td-".concat(remoteProducerId)).srcObject = new MediaStream([track]);
                    // console.log(remoteVideo.srcObject);
                    // remoteVideo.muted = true;
                    // remoteVideo.play().catch(error => console.error("Error playing video:", error));

                    socket.emit('resume', params.id);
                    _context15.next = 20;
                    break;
                  case 17:
                    _context15.prev = 17;
                    _context15.t0 = _context15["catch"](0);
                    console.log("error consuming: ", _context15.t0);
                  case 20:
                  case "end":
                    return _context15.stop();
                }
              }, _callee15, null, [[0, 17]]);
            }));
            return function (_x16) {
              return _ref12.apply(this, arguments);
            };
          }());
        case 2:
        case "end":
          return _context16.stop();
      }
    }, _callee16);
  }));
  return _consume.apply(this, arguments);
}
})();

var __webpack_exports___esModule = __webpack_exports__.__esModule;
var __webpack_exports__getSocket = __webpack_exports__.getSocket;
export { __webpack_exports___esModule as __esModule, __webpack_exports__getSocket as getSocket };

//# sourceMappingURL=media.bundle.js.map